(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports={
  "name": "cannon",
  "version": "0.6.2",
  "description": "A lightweight 3D physics engine written in JavaScript.",
  "homepage": "https://github.com/schteppe/cannon.js",
  "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
  "keywords": [
    "cannon.js",
    "cannon",
    "physics",
    "engine",
    "3d"
  ],
  "main": "./src/Cannon.js",
  "engines": {
    "node": "*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/schteppe/cannon.js.git"
  },
  "bugs": {
    "url": "https://github.com/schteppe/cannon.js/issues"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "devDependencies": {
    "jshint": "latest",
    "uglify-js": "latest",
    "nodeunit": "^0.9.0",
    "grunt": "~0.4.0",
    "grunt-contrib-jshint": "~0.1.1",
    "grunt-contrib-nodeunit": "^0.4.1",
    "grunt-contrib-concat": "~0.1.3",
    "grunt-contrib-uglify": "^0.5.1",
    "grunt-browserify": "^2.1.4",
    "grunt-contrib-yuidoc": "^0.5.2",
    "browserify": "*"
  },
  "dependencies": {}
}

},{}],2:[function(require,module,exports){
// Export classes
module.exports = {
    version :                       require('../package.json').version,

    AABB :                          require('./collision/AABB'),
    ArrayCollisionMatrix :          require('./collision/ArrayCollisionMatrix'),
    Body :                          require('./objects/Body'),
    Box :                           require('./shapes/Box'),
    Broadphase :                    require('./collision/Broadphase'),
    Constraint :                    require('./constraints/Constraint'),
    ContactEquation :               require('./equations/ContactEquation'),
    Narrowphase :                   require('./world/Narrowphase'),
    ConeTwistConstraint :           require('./constraints/ConeTwistConstraint'),
    ContactMaterial :               require('./material/ContactMaterial'),
    ConvexPolyhedron :              require('./shapes/ConvexPolyhedron'),
    Cylinder :                      require('./shapes/Cylinder'),
    DistanceConstraint :            require('./constraints/DistanceConstraint'),
    Equation :                      require('./equations/Equation'),
    EventTarget :                   require('./utils/EventTarget'),
    FrictionEquation :              require('./equations/FrictionEquation'),
    GSSolver :                      require('./solver/GSSolver'),
    GridBroadphase :                require('./collision/GridBroadphase'),
    Heightfield :                   require('./shapes/Heightfield'),
    HingeConstraint :               require('./constraints/HingeConstraint'),
    LockConstraint :                require('./constraints/LockConstraint'),
    Mat3 :                          require('./math/Mat3'),
    Material :                      require('./material/Material'),
    NaiveBroadphase :               require('./collision/NaiveBroadphase'),
    ObjectCollisionMatrix :         require('./collision/ObjectCollisionMatrix'),
    Pool :                          require('./utils/Pool'),
    Particle :                      require('./shapes/Particle'),
    Plane :                         require('./shapes/Plane'),
    PointToPointConstraint :        require('./constraints/PointToPointConstraint'),
    Quaternion :                    require('./math/Quaternion'),
    Ray :                           require('./collision/Ray'),
    RaycastVehicle :                require('./objects/RaycastVehicle'),
    RaycastResult :                 require('./collision/RaycastResult'),
    RigidVehicle :                  require('./objects/RigidVehicle'),
    RotationalEquation :            require('./equations/RotationalEquation'),
    RotationalMotorEquation :       require('./equations/RotationalMotorEquation'),
    SAPBroadphase :                 require('./collision/SAPBroadphase'),
    SPHSystem :                     require('./objects/SPHSystem'),
    Shape :                         require('./shapes/Shape'),
    Solver :                        require('./solver/Solver'),
    Sphere :                        require('./shapes/Sphere'),
    SplitSolver :                   require('./solver/SplitSolver'),
    Spring :                        require('./objects/Spring'),
    Transform :                     require('./math/Transform'),
    Trimesh :                       require('./shapes/Trimesh'),
    Vec3 :                          require('./math/Vec3'),
    Vec3Pool :                      require('./utils/Vec3Pool'),
    World :                         require('./world/World'),
};

},{"../package.json":1,"./collision/AABB":3,"./collision/ArrayCollisionMatrix":4,"./collision/Broadphase":5,"./collision/GridBroadphase":6,"./collision/NaiveBroadphase":7,"./collision/ObjectCollisionMatrix":8,"./collision/Ray":10,"./collision/RaycastResult":11,"./collision/SAPBroadphase":12,"./constraints/ConeTwistConstraint":13,"./constraints/Constraint":14,"./constraints/DistanceConstraint":15,"./constraints/HingeConstraint":16,"./constraints/LockConstraint":17,"./constraints/PointToPointConstraint":18,"./equations/ContactEquation":20,"./equations/Equation":21,"./equations/FrictionEquation":22,"./equations/RotationalEquation":23,"./equations/RotationalMotorEquation":24,"./material/ContactMaterial":25,"./material/Material":26,"./math/Mat3":28,"./math/Quaternion":29,"./math/Transform":30,"./math/Vec3":31,"./objects/Body":32,"./objects/RaycastVehicle":33,"./objects/RigidVehicle":34,"./objects/SPHSystem":35,"./objects/Spring":36,"./shapes/Box":38,"./shapes/ConvexPolyhedron":39,"./shapes/Cylinder":40,"./shapes/Heightfield":41,"./shapes/Particle":42,"./shapes/Plane":43,"./shapes/Shape":44,"./shapes/Sphere":45,"./shapes/Trimesh":46,"./solver/GSSolver":47,"./solver/Solver":48,"./solver/SplitSolver":49,"./utils/EventTarget":50,"./utils/Pool":52,"./utils/Vec3Pool":55,"./world/Narrowphase":56,"./world/World":57}],3:[function(require,module,exports){
var Vec3 = require('../math/Vec3');
var Utils = require('../utils/Utils');

module.exports = AABB;

/**
 * Axis aligned bounding box class.
 * @class AABB
 * @constructor
 * @param {Object} [options]
 * @param {Vec3}   [options.upperBound]
 * @param {Vec3}   [options.lowerBound]
 */
function AABB(options){
    options = options || {};

    /**
     * The lower bound of the bounding box.
     * @property lowerBound
     * @type {Vec3}
     */
    this.lowerBound = new Vec3();
    if(options.lowerBound){
        this.lowerBound.copy(options.lowerBound);
    }

    /**
     * The upper bound of the bounding box.
     * @property upperBound
     * @type {Vec3}
     */
    this.upperBound = new Vec3();
    if(options.upperBound){
        this.upperBound.copy(options.upperBound);
    }
}

var tmp = new Vec3();

/**
 * Set the AABB bounds from a set of points.
 * @method setFromPoints
 * @param {Array} points An array of Vec3's.
 * @param {Vec3} position
 * @param {Quaternion} quaternion
 * @param {number} skinSize
 * @return {AABB} The self object
 */
AABB.prototype.setFromPoints = function(points, position, quaternion, skinSize){
    var l = this.lowerBound,
        u = this.upperBound,
        q = quaternion;

    // Set to the first point
    l.copy(points[0]);
    if(q){
        q.vmult(l, l);
    }
    u.copy(l);

    for(var i = 1; i<points.length; i++){
        var p = points[i];

        if(q){
            q.vmult(p, tmp);
            p = tmp;
        }

        if(p.x > u.x){ u.x = p.x; }
        if(p.x < l.x){ l.x = p.x; }
        if(p.y > u.y){ u.y = p.y; }
        if(p.y < l.y){ l.y = p.y; }
        if(p.z > u.z){ u.z = p.z; }
        if(p.z < l.z){ l.z = p.z; }
    }

    // Add offset
    if (position) {
        position.vadd(l, l);
        position.vadd(u, u);
    }

    if(skinSize){
        l.x -= skinSize;
        l.y -= skinSize;
        l.z -= skinSize;
        u.x += skinSize;
        u.y += skinSize;
        u.z += skinSize;
    }

    return this;
};

/**
 * Copy bounds from an AABB to this AABB
 * @method copy
 * @param  {AABB} aabb Source to copy from
 * @return {AABB} The this object, for chainability
 */
AABB.prototype.copy = function(aabb){
    this.lowerBound.copy(aabb.lowerBound);
    this.upperBound.copy(aabb.upperBound);
    return this;
};

/**
 * Clone an AABB
 * @method clone
 */
AABB.prototype.clone = function(){
    return new AABB().copy(this);
};

/**
 * Extend this AABB so that it covers the given AABB too.
 * @method extend
 * @param  {AABB} aabb
 */
AABB.prototype.extend = function(aabb){
    this.lowerBound.x = Math.min(this.lowerBound.x, aabb.lowerBound.x);
    this.upperBound.x = Math.max(this.upperBound.x, aabb.upperBound.x);
    this.lowerBound.y = Math.min(this.lowerBound.y, aabb.lowerBound.y);
    this.upperBound.y = Math.max(this.upperBound.y, aabb.upperBound.y);
    this.lowerBound.z = Math.min(this.lowerBound.z, aabb.lowerBound.z);
    this.upperBound.z = Math.max(this.upperBound.z, aabb.upperBound.z);
};

/**
 * Returns true if the given AABB overlaps this AABB.
 * @method overlaps
 * @param  {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.overlaps = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    var overlapsX = ((l2.x <= u1.x && u1.x <= u2.x) || (l1.x <= u2.x && u2.x <= u1.x));
    var overlapsY = ((l2.y <= u1.y && u1.y <= u2.y) || (l1.y <= u2.y && u2.y <= u1.y));
    var overlapsZ = ((l2.z <= u1.z && u1.z <= u2.z) || (l1.z <= u2.z && u2.z <= u1.z));

    return overlapsX && overlapsY && overlapsZ;
};

// Mostly for debugging
AABB.prototype.volume = function(){
    var l = this.lowerBound,
        u = this.upperBound;
    return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);
};


/**
 * Returns true if the given AABB is fully contained in this AABB.
 * @method contains
 * @param {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.contains = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |---------------|
    // l1              u1

    return (
        (l1.x <= l2.x && u1.x >= u2.x) &&
        (l1.y <= l2.y && u1.y >= u2.y) &&
        (l1.z <= l2.z && u1.z >= u2.z)
    );
};

/**
 * @method getCorners
 * @param {Vec3} a
 * @param {Vec3} b
 * @param {Vec3} c
 * @param {Vec3} d
 * @param {Vec3} e
 * @param {Vec3} f
 * @param {Vec3} g
 * @param {Vec3} h
 */
AABB.prototype.getCorners = function(a, b, c, d, e, f, g, h){
    var l = this.lowerBound,
        u = this.upperBound;

    a.copy(l);
    b.set( u.x, l.y, l.z );
    c.set( u.x, u.y, l.z );
    d.set( l.x, u.y, u.z );
    e.set( u.x, l.y, l.z );
    f.set( l.x, u.y, l.z );
    g.set( l.x, l.y, u.z );
    h.copy(u);
};

var transformIntoFrame_corners = [
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3()
];

/**
 * Get the representation of an AABB in another frame.
 * @method toLocalFrame
 * @param  {Transform} frame
 * @param  {AABB} target
 * @return {AABB} The "target" AABB object.
 */
AABB.prototype.toLocalFrame = function(frame, target){

    var corners = transformIntoFrame_corners;
    var a = corners[0];
    var b = corners[1];
    var c = corners[2];
    var d = corners[3];
    var e = corners[4];
    var f = corners[5];
    var g = corners[6];
    var h = corners[7];

    // Get corners in current frame
    this.getCorners(a, b, c, d, e, f, g, h);

    // Transform them to new local frame
    for(var i=0; i !== 8; i++){
        var corner = corners[i];
        frame.pointToLocal(corner, corner);
    }

    return target.setFromPoints(corners);
};

/**
 * Get the representation of an AABB in the global frame.
 * @method toWorldFrame
 * @param  {Transform} frame
 * @param  {AABB} target
 * @return {AABB} The "target" AABB object.
 */
AABB.prototype.toWorldFrame = function(frame, target){

    var corners = transformIntoFrame_corners;
    var a = corners[0];
    var b = corners[1];
    var c = corners[2];
    var d = corners[3];
    var e = corners[4];
    var f = corners[5];
    var g = corners[6];
    var h = corners[7];

    // Get corners in current frame
    this.getCorners(a, b, c, d, e, f, g, h);

    // Transform them to new local frame
    for(var i=0; i !== 8; i++){
        var corner = corners[i];
        frame.pointToWorld(corner, corner);
    }

    return target.setFromPoints(corners);
};

/**
 * Check if the AABB is hit by a ray.
 * @param  {Ray} ray
 * @return {number}
 */
AABB.prototype.overlapsRay = function(ray){
    var t = 0;

    // ray.direction is unit direction vector of ray
    var dirFracX = 1 / ray._direction.x;
    var dirFracY = 1 / ray._direction.y;
    var dirFracZ = 1 / ray._direction.z;

    // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner
    var t1 = (this.lowerBound.x - ray.from.x) * dirFracX;
    var t2 = (this.upperBound.x - ray.from.x) * dirFracX;
    var t3 = (this.lowerBound.y - ray.from.y) * dirFracY;
    var t4 = (this.upperBound.y - ray.from.y) * dirFracY;
    var t5 = (this.lowerBound.z - ray.from.z) * dirFracZ;
    var t6 = (this.upperBound.z - ray.from.z) * dirFracZ;

    // var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
    // var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));
    var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
    var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

    // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us
    if (tmax < 0){
        //t = tmax;
        return false;
    }

    // if tmin > tmax, ray doesn't intersect AABB
    if (tmin > tmax){
        //t = tmax;
        return false;
    }

    return true;
};
},{"../math/Vec3":31,"../utils/Utils":54}],4:[function(require,module,exports){
module.exports = ArrayCollisionMatrix;

/**
 * Collision "matrix". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
 * @class ArrayCollisionMatrix
 * @constructor
 */
function ArrayCollisionMatrix() {

    /**
     * The matrix storage
     * @property matrix
     * @type {Array}
     */
    this.matrix = [];
}

/**
 * Get an element
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
ArrayCollisionMatrix.prototype.get = function(i, j) {
    i = i.index;
    j = j.index;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
    }
    return this.matrix[(i*(i + 1)>>1) + j-1];
};

/**
 * Set an element
 * @method set
 * @param {Number} i
 * @param {Number} j
 * @param {Number} value
 */
ArrayCollisionMatrix.prototype.set = function(i, j, value) {
    i = i.index;
    j = j.index;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
    }
    this.matrix[(i*(i + 1)>>1) + j-1] = value ? 1 : 0;
};

/**
 * Sets all elements to zero
 * @method reset
 */
ArrayCollisionMatrix.prototype.reset = function() {
    for (var i=0, l=this.matrix.length; i!==l; i++) {
        this.matrix[i]=0;
    }
};

/**
 * Sets the max number of objects
 * @method setNumObjects
 * @param {Number} n
 */
ArrayCollisionMatrix.prototype.setNumObjects = function(n) {
    this.matrix.length = n*(n-1)>>1;
};

},{}],5:[function(require,module,exports){
var Body = require('../objects/Body');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Shape = require('../shapes/Shape');
var Plane = require('../shapes/Plane');

module.exports = Broadphase;

/**
 * Base class for broadphase implementations
 * @class Broadphase
 * @constructor
 * @author schteppe
 */
function Broadphase(){
    /**
    * The world to search for collisions in.
    * @property world
    * @type {World}
    */
    this.world = null;

    /**
     * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.
     * @property useBoundingBoxes
     * @type {Boolean}
     */
    this.useBoundingBoxes = false;

    /**
     * Set to true if the objects in the world moved.
     * @property {Boolean} dirty
     */
    this.dirty = true;
}

/**
 * Get the collision pairs from the world
 * @method collisionPairs
 * @param {World} world The world to search in
 * @param {Array} p1 Empty array to be filled with body objects
 * @param {Array} p2 Empty array to be filled with body objects
 */
Broadphase.prototype.collisionPairs = function(world,p1,p2){
    throw new Error("collisionPairs not implemented for this BroadPhase class!");
};

/**
 * Check if a body pair needs to be intersection tested at all.
 * @method needBroadphaseCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @return {bool}
 */
Broadphase.prototype.needBroadphaseCollision = function(bodyA,bodyB){

    // Check collision filter masks
    if( (bodyA.collisionFilterGroup & bodyB.collisionFilterMask)===0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask)===0){
        return false;
    }

    // Check types
    if(((bodyA.type & Body.STATIC)!==0 || bodyA.sleepState === Body.SLEEPING) &&
       ((bodyB.type & Body.STATIC)!==0 || bodyB.sleepState === Body.SLEEPING)) {
        // Both bodies are static or sleeping. Skip.
        return false;
    }

    return true;
};

/**
 * Check if the bounding volumes of two bodies intersect.
 * @method intersectionTest
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {array} pairs1
 * @param {array} pairs2
  */
Broadphase.prototype.intersectionTest = function(bodyA, bodyB, pairs1, pairs2){
    if(this.useBoundingBoxes){
        this.doBoundingBoxBroadphase(bodyA,bodyB,pairs1,pairs2);
    } else {
        this.doBoundingSphereBroadphase(bodyA,bodyB,pairs1,pairs2);
    }
};

/**
 * Check if the bounding spheres of two bodies are intersecting.
 * @method doBoundingSphereBroadphase
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Array} pairs1 bodyA is appended to this array if intersection
 * @param {Array} pairs2 bodyB is appended to this array if intersection
 */
var Broadphase_collisionPairs_r = new Vec3(), // Temp objects
    Broadphase_collisionPairs_normal =  new Vec3(),
    Broadphase_collisionPairs_quat =  new Quaternion(),
    Broadphase_collisionPairs_relpos  =  new Vec3();
Broadphase.prototype.doBoundingSphereBroadphase = function(bodyA,bodyB,pairs1,pairs2){
    var r = Broadphase_collisionPairs_r;
    bodyB.position.vsub(bodyA.position,r);
    var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);
    var norm2 = r.norm2();
    if(norm2 < boundingRadiusSum2){
        pairs1.push(bodyA);
        pairs2.push(bodyB);
    }
};

/**
 * Check if the bounding boxes of two bodies are intersecting.
 * @method doBoundingBoxBroadphase
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
Broadphase.prototype.doBoundingBoxBroadphase = function(bodyA,bodyB,pairs1,pairs2){
    if(bodyA.aabbNeedsUpdate){
        bodyA.computeAABB();
    }
    if(bodyB.aabbNeedsUpdate){
        bodyB.computeAABB();
    }

    // Check AABB / AABB
    if(bodyA.aabb.overlaps(bodyB.aabb)){
        pairs1.push(bodyA);
        pairs2.push(bodyB);
    }
};

/**
 * Removes duplicate pairs from the pair arrays.
 * @method makePairsUnique
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
var Broadphase_makePairsUnique_temp = { keys:[] },
    Broadphase_makePairsUnique_p1 = [],
    Broadphase_makePairsUnique_p2 = [];
Broadphase.prototype.makePairsUnique = function(pairs1,pairs2){
    var t = Broadphase_makePairsUnique_temp,
        p1 = Broadphase_makePairsUnique_p1,
        p2 = Broadphase_makePairsUnique_p2,
        N = pairs1.length;

    for(var i=0; i!==N; i++){
        p1[i] = pairs1[i];
        p2[i] = pairs2[i];
    }

    pairs1.length = 0;
    pairs2.length = 0;

    for(var i=0; i!==N; i++){
        var id1 = p1[i].id,
            id2 = p2[i].id;
        var key = id1 < id2 ? id1+","+id2 :  id2+","+id1;
        t[key] = i;
        t.keys.push(key);
    }

    for(var i=0; i!==t.keys.length; i++){
        var key = t.keys.pop(),
            pairIndex = t[key];
        pairs1.push(p1[pairIndex]);
        pairs2.push(p2[pairIndex]);
        delete t[key];
    }
};

/**
 * To be implemented by subcasses
 * @method setWorld
 * @param {World} world
 */
Broadphase.prototype.setWorld = function(world){
};

/**
 * Check if the bounding spheres of two bodies overlap.
 * @method boundingSphereCheck
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @return {boolean}
 */
var bsc_dist = new Vec3();
Broadphase.boundingSphereCheck = function(bodyA,bodyB){
    var dist = bsc_dist;
    bodyA.position.vsub(bodyB.position,dist);
    return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius,2) > dist.norm2();
};

/**
 * Returns all the bodies within the AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param  {array} result An array to store resulting bodies in.
 * @return {array}
 */
Broadphase.prototype.aabbQuery = function(world, aabb, result){
    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
    return [];
};
},{"../math/Quaternion":29,"../math/Vec3":31,"../objects/Body":32,"../shapes/Plane":43,"../shapes/Shape":44}],6:[function(require,module,exports){
module.exports = GridBroadphase;

var Broadphase = require('./Broadphase');
var Vec3 = require('../math/Vec3');
var Shape = require('../shapes/Shape');

/**
 * Axis aligned uniform grid broadphase.
 * @class GridBroadphase
 * @constructor
 * @extends Broadphase
 * @todo Needs support for more than just planes and spheres.
 * @param {Vec3} aabbMin
 * @param {Vec3} aabbMax
 * @param {Number} nx Number of boxes along x
 * @param {Number} ny Number of boxes along y
 * @param {Number} nz Number of boxes along z
 */
function GridBroadphase(aabbMin,aabbMax,nx,ny,nz){
    Broadphase.apply(this);
    this.nx = nx || 10;
    this.ny = ny || 10;
    this.nz = nz || 10;
    this.aabbMin = aabbMin || new Vec3(100,100,100);
    this.aabbMax = aabbMax || new Vec3(-100,-100,-100);
	var nbins = this.nx * this.ny * this.nz;
	if (nbins <= 0) {
		throw "GridBroadphase: Each dimension's n must be >0";
	}
    this.bins = [];
	this.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow
	this.bins.length = nbins;
	this.binLengths.length = nbins;
	for (var i=0;i<nbins;i++) {
		this.bins[i]=[];
		this.binLengths[i]=0;
	}
}
GridBroadphase.prototype = new Broadphase();
GridBroadphase.prototype.constructor = GridBroadphase;

/**
 * Get all the collision pairs in the physics world
 * @method collisionPairs
 * @param {World} world
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
var GridBroadphase_collisionPairs_d = new Vec3();
var GridBroadphase_collisionPairs_binPos = new Vec3();
GridBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){
    var N = world.numObjects(),
        bodies = world.bodies;

    var max = this.aabbMax,
        min = this.aabbMin,
        nx = this.nx,
        ny = this.ny,
        nz = this.nz;

	var xstep = ny*nz;
	var ystep = nz;
	var zstep = 1;

    var xmax = max.x,
        ymax = max.y,
        zmax = max.z,
        xmin = min.x,
        ymin = min.y,
        zmin = min.z;

    var xmult = nx / (xmax-xmin),
        ymult = ny / (ymax-ymin),
        zmult = nz / (zmax-zmin);

    var binsizeX = (xmax - xmin) / nx,
        binsizeY = (ymax - ymin) / ny,
        binsizeZ = (zmax - zmin) / nz;

	var binRadius = Math.sqrt(binsizeX*binsizeX + binsizeY*binsizeY + binsizeZ*binsizeZ) * 0.5;

    var types = Shape.types;
    var SPHERE =            types.SPHERE,
        PLANE =             types.PLANE,
        BOX =               types.BOX,
        COMPOUND =          types.COMPOUND,
        CONVEXPOLYHEDRON =  types.CONVEXPOLYHEDRON;

    var bins=this.bins,
		binLengths=this.binLengths,
        Nbins=this.bins.length;

    // Reset bins
    for(var i=0; i!==Nbins; i++){
        binLengths[i] = 0;
    }

    var ceil = Math.ceil;
	var min = Math.min;
	var max = Math.max;

	function addBoxToBins(x0,y0,z0,x1,y1,z1,bi) {
		var xoff0 = ((x0 - xmin) * xmult)|0,
			yoff0 = ((y0 - ymin) * ymult)|0,
			zoff0 = ((z0 - zmin) * zmult)|0,
			xoff1 = ceil((x1 - xmin) * xmult),
			yoff1 = ceil((y1 - ymin) * ymult),
			zoff1 = ceil((z1 - zmin) * zmult);

		if (xoff0 < 0) { xoff0 = 0; } else if (xoff0 >= nx) { xoff0 = nx - 1; }
		if (yoff0 < 0) { yoff0 = 0; } else if (yoff0 >= ny) { yoff0 = ny - 1; }
		if (zoff0 < 0) { zoff0 = 0; } else if (zoff0 >= nz) { zoff0 = nz - 1; }
		if (xoff1 < 0) { xoff1 = 0; } else if (xoff1 >= nx) { xoff1 = nx - 1; }
		if (yoff1 < 0) { yoff1 = 0; } else if (yoff1 >= ny) { yoff1 = ny - 1; }
		if (zoff1 < 0) { zoff1 = 0; } else if (zoff1 >= nz) { zoff1 = nz - 1; }

		xoff0 *= xstep;
		yoff0 *= ystep;
		zoff0 *= zstep;
		xoff1 *= xstep;
		yoff1 *= ystep;
		zoff1 *= zstep;

		for (var xoff = xoff0; xoff <= xoff1; xoff += xstep) {
			for (var yoff = yoff0; yoff <= yoff1; yoff += ystep) {
				for (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {
					var idx = xoff+yoff+zoff;
					bins[idx][binLengths[idx]++] = bi;
				}
			}
		}
	}

    // Put all bodies into the bins
    for(var i=0; i!==N; i++){
        var bi = bodies[i];
        var si = bi.shape;

        switch(si.type){
        case SPHERE:
            // Put in bin
            // check if overlap with other bins
            var x = bi.position.x,
                y = bi.position.y,
                z = bi.position.z;
            var r = si.radius;

			addBoxToBins(x-r, y-r, z-r, x+r, y+r, z+r, bi);
            break;

        case PLANE:
            if(si.worldNormalNeedsUpdate){
                si.computeWorldNormal(bi.quaternion);
            }
            var planeNormal = si.worldNormal;

			//Relative position from origin of plane object to the first bin
			//Incremented as we iterate through the bins
			var xreset = xmin + binsizeX*0.5 - bi.position.x,
				yreset = ymin + binsizeY*0.5 - bi.position.y,
				zreset = zmin + binsizeZ*0.5 - bi.position.z;

            var d = GridBroadphase_collisionPairs_d;
			d.set(xreset, yreset, zreset);

			for (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
				for (var yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
					for (var zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
						if (d.dot(planeNormal) < binRadius) {
							var idx = xoff + yoff + zoff;
							bins[idx][binLengths[idx]++] = bi;
						}
					}
				}
			}
            break;

        default:
			if (bi.aabbNeedsUpdate) {
				bi.computeAABB();
			}

			addBoxToBins(
				bi.aabb.lowerBound.x,
				bi.aabb.lowerBound.y,
				bi.aabb.lowerBound.z,
				bi.aabb.upperBound.x,
				bi.aabb.upperBound.y,
				bi.aabb.upperBound.z,
				bi);
            break;
        }
    }

    // Check each bin
    for(var i=0; i!==Nbins; i++){
		var binLength = binLengths[i];
		//Skip bins with no potential collisions
		if (binLength > 1) {
			var bin = bins[i];

			// Do N^2 broadphase inside
			for(var xi=0; xi!==binLength; xi++){
				var bi = bin[xi];
				for(var yi=0; yi!==xi; yi++){
					var bj = bin[yi];
					if(this.needBroadphaseCollision(bi,bj)){
						this.intersectionTest(bi,bj,pairs1,pairs2);
					}
				}
			}
		}
    }

//	for (var zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
//		console.log("layer "+zi);
//		for (var yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
//			var row = '';
//			for (var xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
//				var idx = xoff + yoff + zoff;
//				row += ' ' + binLengths[idx];
//			}
//			console.log(row);
//		}
//	}

    this.makePairsUnique(pairs1,pairs2);
};

},{"../math/Vec3":31,"../shapes/Shape":44,"./Broadphase":5}],7:[function(require,module,exports){
module.exports = NaiveBroadphase;

var Broadphase = require('./Broadphase');
var AABB = require('./AABB');

/**
 * Naive broadphase implementation, used in lack of better ones.
 * @class NaiveBroadphase
 * @constructor
 * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
 * @extends Broadphase
 */
function NaiveBroadphase(){
    Broadphase.apply(this);
}
NaiveBroadphase.prototype = new Broadphase();
NaiveBroadphase.prototype.constructor = NaiveBroadphase;

/**
 * Get all the collision pairs in the physics world
 * @method collisionPairs
 * @param {World} world
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
NaiveBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){
    var bodies = world.bodies,
        n = bodies.length,
        i,j,bi,bj;

    // Naive N^2 ftw!
    for(i=0; i!==n; i++){
        for(j=0; j!==i; j++){

            bi = bodies[i];
            bj = bodies[j];

            if(!this.needBroadphaseCollision(bi,bj)){
                continue;
            }

            this.intersectionTest(bi,bj,pairs1,pairs2);
        }
    }
};

var tmpAABB = new AABB();

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    for(var i = 0; i < world.bodies.length; i++){
        var b = world.bodies[i];

        if(b.aabbNeedsUpdate){
            b.computeAABB();
        }

        // Ugly hack until Body gets aabb
        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"./AABB":3,"./Broadphase":5}],8:[function(require,module,exports){
module.exports = ObjectCollisionMatrix;

/**
 * Records what objects are colliding with each other
 * @class ObjectCollisionMatrix
 * @constructor
 */
function ObjectCollisionMatrix() {

    /**
     * The matrix storage
     * @property matrix
     * @type {Object}
     */
	this.matrix = {};
}

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
ObjectCollisionMatrix.prototype.get = function(i, j) {
	i = i.id;
	j = j.id;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
    }
	return i+'-'+j in this.matrix;
};

/**
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
ObjectCollisionMatrix.prototype.set = function(i, j, value) {
	i = i.id;
	j = j.id;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
	}
	if (value) {
		this.matrix[i+'-'+j] = true;
	}
	else {
		delete this.matrix[i+'-'+j];
	}
};

/**
 * Empty the matrix
 * @method reset
 */
ObjectCollisionMatrix.prototype.reset = function() {
	this.matrix = {};
};

/**
 * Set max number of objects
 * @method setNumObjects
 * @param {Number} n
 */
ObjectCollisionMatrix.prototype.setNumObjects = function(n) {
};

},{}],9:[function(require,module,exports){
module.exports = OverlapKeeper;

/**
 * @class OverlapKeeper
 * @constructor
 */
function OverlapKeeper() {
    this.current = [];
    this.previous = [];
}

OverlapKeeper.prototype.getKey = function(i, j) {
    if (j < i) {
        var temp = j;
        j = i;
        i = temp;
    }
    return (i << 16) | j;
};


/**
 * @method set
 * @param {Number} i
 * @param {Number} j
 */
OverlapKeeper.prototype.set = function(i, j) {
    // Insertion sort. This way the diff will have linear complexity.
    var key = this.getKey(i, j);
    var current = this.current;
    var index = 0;
    while(key > current[index]){
        index++;
    }
    if(key === current[index]){
        return; // Pair was already added
    }
    for(var j=current.length-1; j>=index; j--){
        current[j + 1] = current[j];
    }
    current[index] = key;
};

/**
 * @method tick
 */
OverlapKeeper.prototype.tick = function() {
    var tmp = this.current;
    this.current = this.previous;
    this.previous = tmp;
    this.current.length = 0;
};

function unpackAndPush(array, key){
    array.push((key & 0xFFFF0000) >> 16, key & 0x0000FFFF);
}

/**
 * @method getDiff
 * @param  {array} additions
 * @param  {array} removals
 */
OverlapKeeper.prototype.getDiff = function(additions, removals) {
    var a = this.current;
    var b = this.previous;
    var al = a.length;
    var bl = b.length;

    var j=0;
    for (var i = 0; i < al; i++) {
        var found = false;
        var keyA = a[i];
        while(keyA > b[j]){
            j++;
        }
        found = keyA === b[j];

        if(!found){
            unpackAndPush(additions, keyA);
        }
    }
    j = 0;
    for (var i = 0; i < bl; i++) {
        var found = false;
        var keyB = b[i];
        while(keyB > a[j]){
            j++;
        }
        found = a[j] === keyB;

        if(!found){
            unpackAndPush(removals, keyB);
        }
    }
};
},{}],10:[function(require,module,exports){
module.exports = Ray;

var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Transform = require('../math/Transform');
var ConvexPolyhedron = require('../shapes/ConvexPolyhedron');
var Box = require('../shapes/Box');
var RaycastResult = require('../collision/RaycastResult');
var Shape = require('../shapes/Shape');
var AABB = require('../collision/AABB');

/**
 * A line in 3D space that intersects bodies and return points.
 * @class Ray
 * @constructor
 * @param {Vec3} from
 * @param {Vec3} to
 */
function Ray(from, to){
    /**
     * @property {Vec3} from
     */
    this.from = from ? from.clone() : new Vec3();

    /**
     * @property {Vec3} to
     */
    this.to = to ? to.clone() : new Vec3();

    /**
     * @private
     * @property {Vec3} _direction
     */
    this._direction = new Vec3();

    /**
     * The precision of the ray. Used when checking parallelity etc.
     * @property {Number} precision
     */
    this.precision = 0.0001;

    /**
     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
     * @property {Boolean} checkCollisionResponse
     */
    this.checkCollisionResponse = true;

    /**
     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
     * @property {Boolean} skipBackfaces
     */
    this.skipBackfaces = false;

    /**
     * @property {number} collisionFilterMask
     * @default -1
     */
    this.collisionFilterMask = -1;

    /**
     * @property {number} collisionFilterGroup
     * @default -1
     */
    this.collisionFilterGroup = -1;

    /**
     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
     * @property {number} mode
     */
    this.mode = Ray.ANY;

    /**
     * Current result object.
     * @property {RaycastResult} result
     */
    this.result = new RaycastResult();

    /**
     * Will be set to true during intersectWorld() if the ray hit anything.
     * @property {Boolean} hasHit
     */
    this.hasHit = false;

    /**
     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
     * @property {Function} callback
     */
    this.callback = function(result){};
}
Ray.prototype.constructor = Ray;

Ray.CLOSEST = 1;
Ray.ANY = 2;
Ray.ALL = 4;

var tmpAABB = new AABB();
var tmpArray = [];

/**
 * Do itersection against all bodies in the given World.
 * @method intersectWorld
 * @param  {World} world
 * @param  {object} options
 * @return {Boolean} True if the ray hit anything, otherwise false.
 */
Ray.prototype.intersectWorld = function (world, options) {
    this.mode = options.mode || Ray.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionFilterMask = typeof(options.collisionFilterMask) !== 'undefined' ? options.collisionFilterMask : -1;
    this.collisionFilterGroup = typeof(options.collisionFilterGroup) !== 'undefined' ? options.collisionFilterGroup : -1;
    if(options.from){
        this.from.copy(options.from);
    }
    if(options.to){
        this.to.copy(options.to);
    }
    this.callback = options.callback || function(){};
    this.hasHit = false;

    this.result.reset();
    this._updateDirection();

    this.getAABB(tmpAABB);
    tmpArray.length = 0;
    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
    this.intersectBodies(tmpArray);

    return this.hasHit;
};

var v1 = new Vec3(),
    v2 = new Vec3();

/*
 * As per "Barycentric Technique" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division
 */
Ray.pointInTriangle = pointInTriangle;
function pointInTriangle(p, a, b, c) {
    c.vsub(a,v0);
    b.vsub(a,v1);
    p.vsub(a,v2);

    var dot00 = v0.dot( v0 );
    var dot01 = v0.dot( v1 );
    var dot02 = v0.dot( v2 );
    var dot11 = v1.dot( v1 );
    var dot12 = v1.dot( v2 );

    var u,v;

    return  ( (u = dot11 * dot02 - dot01 * dot12) >= 0 ) &&
            ( (v = dot00 * dot12 - dot01 * dot02) >= 0 ) &&
            ( u + v < ( dot00 * dot11 - dot01 * dot01 ) );
}

/**
 * Shoot a ray at a body, get back information about the hit.
 * @method intersectBody
 * @private
 * @param {Body} body
 * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
 */
var intersectBody_xi = new Vec3();
var intersectBody_qi = new Quaternion();
Ray.prototype.intersectBody = function (body, result) {
    if(result){
        this.result = result;
        this._updateDirection();
    }
    var checkCollisionResponse = this.checkCollisionResponse;

    if(checkCollisionResponse && !body.collisionResponse){
        return;
    }

    if((this.collisionFilterGroup & body.collisionFilterMask)===0 || (body.collisionFilterGroup & this.collisionFilterMask)===0){
        return;
    }

    var xi = intersectBody_xi;
    var qi = intersectBody_qi;

    for (var i = 0, N = body.shapes.length; i < N; i++) {
        var shape = body.shapes[i];

        if(checkCollisionResponse && !shape.collisionResponse){
            continue; // Skip
        }

        body.quaternion.mult(body.shapeOrientations[i], qi);
        body.quaternion.vmult(body.shapeOffsets[i], xi);
        xi.vadd(body.position, xi);

        this.intersectShape(
            shape,
            qi,
            xi,
            body
        );

        if(this.result._shouldStop){
            break;
        }
    }
};

/**
 * @method intersectBodies
 * @param {Array} bodies An array of Body objects.
 * @param {RaycastResult} [result] Deprecated
 */
Ray.prototype.intersectBodies = function (bodies, result) {
    if(result){
        this.result = result;
        this._updateDirection();
    }

    for ( var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i ++ ) {
        this.intersectBody(bodies[i]);
    }
};

/**
 * Updates the _direction vector.
 * @private
 * @method _updateDirection
 */
Ray.prototype._updateDirection = function(){
    this.to.vsub(this.from, this._direction);
    this._direction.normalize();
};

/**
 * @method intersectShape
 * @private
 * @param {Shape} shape
 * @param {Quaternion} quat
 * @param {Vec3} position
 * @param {Body} body
 */
Ray.prototype.intersectShape = function(shape, quat, position, body){
    var from = this.from;


    // Checking boundingSphere
    var distance = distanceFromIntersection(from, this._direction, position);
    if ( distance > shape.boundingSphereRadius ) {
        return;
    }

    var intersectMethod = this[shape.type];
    if(intersectMethod){
        intersectMethod.call(this, shape, quat, position, body, shape);
    }
};

var vector = new Vec3();
var normal = new Vec3();
var intersectPoint = new Vec3();

var a = new Vec3();
var b = new Vec3();
var c = new Vec3();
var d = new Vec3();

var tmpRaycastResult = new RaycastResult();

/**
 * @method intersectBox
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectBox = function(shape, quat, position, body, reportedShape){
    return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body, reportedShape);
};
Ray.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;

/**
 * @method intersectPlane
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectPlane = function(shape, quat, position, body, reportedShape){
    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    // Get plane normal
    var worldNormal = new Vec3(0, 0, 1);
    quat.vmult(worldNormal, worldNormal);

    var len = new Vec3();
    from.vsub(position, len);
    var planeToFrom = len.dot(worldNormal);
    to.vsub(position, len);
    var planeToTo = len.dot(worldNormal);

    if(planeToFrom * planeToTo > 0){
        // "from" and "to" are on the same side of the plane... bail out
        return;
    }

    if(from.distanceTo(to) < planeToFrom){
        return;
    }

    var n_dot_dir = worldNormal.dot(direction);

    if (Math.abs(n_dot_dir) < this.precision) {
        // No intersection
        return;
    }

    var planePointToFrom = new Vec3();
    var dir_scaled_with_t = new Vec3();
    var hitPointWorld = new Vec3();

    from.vsub(position, planePointToFrom);
    var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
    direction.scale(t, dir_scaled_with_t);
    from.vadd(dir_scaled_with_t, hitPointWorld);

    this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);
};
Ray.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;

/**
 * Get the world AABB of the ray.
 * @method getAABB
 * @param  {AABB} aabb
 */
Ray.prototype.getAABB = function(result){
    var to = this.to;
    var from = this.from;
    result.lowerBound.x = Math.min(to.x, from.x);
    result.lowerBound.y = Math.min(to.y, from.y);
    result.lowerBound.z = Math.min(to.z, from.z);
    result.upperBound.x = Math.max(to.x, from.x);
    result.upperBound.y = Math.max(to.y, from.y);
    result.upperBound.z = Math.max(to.z, from.z);
};

var intersectConvexOptions = {
    faceList: [0]
};
var worldPillarOffset = new Vec3();
var intersectHeightfield_localRay = new Ray();
var intersectHeightfield_index = [];
var intersectHeightfield_minMax = [];

/**
 * @method intersectHeightfield
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectHeightfield = function(shape, quat, position, body, reportedShape){
    var data = shape.data,
        w = shape.elementSize;

    // Convert the ray to local heightfield coordinates
    var localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);
    localRay.from.copy(this.from);
    localRay.to.copy(this.to);
    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);
    localRay._updateDirection();

    // Get the index of the data points to test against
    var index = intersectHeightfield_index;
    var iMinX, iMinY, iMaxX, iMaxY;

    // Set to max
    iMinX = iMinY = 0;
    iMaxX = iMaxY = shape.data.length - 1;

    var aabb = new AABB();
    localRay.getAABB(aabb);

    shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);
    iMinX = Math.max(iMinX, index[0]);
    iMinY = Math.max(iMinY, index[1]);
    shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);
    iMaxX = Math.min(iMaxX, index[0] + 1);
    iMaxY = Math.min(iMaxY, index[1] + 1);

    for(var i = iMinX; i < iMaxX; i++){
        for(var j = iMinY; j < iMaxY; j++){

            if(this.result._shouldStop){
                return;
            }

            shape.getAabbAtIndex(i, j, aabb);
            if(!aabb.overlapsRay(localRay)){
                continue;
            }

            // Lower triangle
            shape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);

            if(this.result._shouldStop){
                return;
            }

            // Upper triangle
            shape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
        }
    }
};
Ray.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;

var Ray_intersectSphere_intersectionPoint = new Vec3();
var Ray_intersectSphere_normal = new Vec3();

/**
 * @method intersectSphere
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectSphere = function(shape, quat, position, body, reportedShape){
    var from = this.from,
        to = this.to,
        r = shape.radius;

    var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);
    var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
    var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);

    var delta = Math.pow(b, 2) - 4 * a * c;

    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
    var normal = Ray_intersectSphere_normal;

    if(delta < 0){
        // No intersection
        return;

    } else if(delta === 0){
        // single intersection point
        from.lerp(to, delta, intersectionPoint);

        intersectionPoint.vsub(position, normal);
        normal.normalize();

        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);

    } else {
        var d1 = (- b - Math.sqrt(delta)) / (2 * a);
        var d2 = (- b + Math.sqrt(delta)) / (2 * a);

        if(d1 >= 0 && d1 <= 1){
            from.lerp(to, d1, intersectionPoint);
            intersectionPoint.vsub(position, normal);
            normal.normalize();
            this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
        }

        if(this.result._shouldStop){
            return;
        }

        if(d2 >= 0 && d2 <= 1){
            from.lerp(to, d2, intersectionPoint);
            intersectionPoint.vsub(position, normal);
            normal.normalize();
            this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
        }
    }
};
Ray.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;


var intersectConvex_normal = new Vec3();
var intersectConvex_minDistNormal = new Vec3();
var intersectConvex_minDistIntersect = new Vec3();
var intersectConvex_vector = new Vec3();

/**
 * @method intersectConvex
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 * @param {object} [options]
 * @param {array} [options.faceList]
 */
Ray.prototype.intersectConvex = function intersectConvex(
    shape,
    quat,
    position,
    body,
    reportedShape,
    options
){
    var minDistNormal = intersectConvex_minDistNormal;
    var normal = intersectConvex_normal;
    var vector = intersectConvex_vector;
    var minDistIntersect = intersectConvex_minDistIntersect;
    var faceList = (options && options.faceList) || null;

    // Checking faces
    var faces = shape.faces,
        vertices = shape.vertices,
        normals = shape.faceNormals;
    var direction = this._direction;

    var from = this.from;
    var to = this.to;
    var fromToDistance = from.distanceTo(to);

    var minDist = -1;
    var Nfaces = faceList ? faceList.length : faces.length;
    var result = this.result;

    for (var j = 0; !result._shouldStop && j < Nfaces; j++) {
        var fi = faceList ? faceList[j] : j;

        var face = faces[fi];
        var faceNormal = normals[fi];
        var q = quat;
        var x = position;

        // determine if ray intersects the plane of the face
        // note: this works regardless of the direction of the face normal

        // Get plane point in world coordinates...
        vector.copy(vertices[face[0]]);
        q.vmult(vector,vector);
        vector.vadd(x,vector);

        // ...but make it relative to the ray from. We'll fix this later.
        vector.vsub(from,vector);

        // Get plane normal
        q.vmult(faceNormal,normal);

        // If this dot product is negative, we have something interesting
        var dot = direction.dot(normal);

        // Bail out if ray and plane are parallel
        if ( Math.abs( dot ) < this.precision ){
            continue;
        }

        // calc distance to plane
        var scalar = normal.dot(vector) / dot;

        // if negative distance, then plane is behind ray
        if (scalar < 0){
            continue;
        }

        // if (dot < 0) {

        // Intersection point is from + direction * scalar
        direction.mult(scalar,intersectPoint);
        intersectPoint.vadd(from,intersectPoint);

        // a is the point we compare points b and c with.
        a.copy(vertices[face[0]]);
        q.vmult(a,a);
        x.vadd(a,a);

        for(var i = 1; !result._shouldStop && i < face.length - 1; i++){
            // Transform 3 vertices to world coords
            b.copy(vertices[face[i]]);
            c.copy(vertices[face[i+1]]);
            q.vmult(b,b);
            q.vmult(c,c);
            x.vadd(b,b);
            x.vadd(c,c);

            var distance = intersectPoint.distanceTo(from);

            if(!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance){
                continue;
            }

            this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);
        }
        // }
    }
};
Ray.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;

var intersectTrimesh_normal = new Vec3();
var intersectTrimesh_localDirection = new Vec3();
var intersectTrimesh_localFrom = new Vec3();
var intersectTrimesh_localTo = new Vec3();
var intersectTrimesh_worldNormal = new Vec3();
var intersectTrimesh_worldIntersectPoint = new Vec3();
var intersectTrimesh_localAABB = new AABB();
var intersectTrimesh_triangles = [];
var intersectTrimesh_treeTransform = new Transform();

/**
 * @method intersectTrimesh
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 * @param {object} [options]
 * @todo Optimize by transforming the world to local space first.
 * @todo Use Octree lookup
 */
Ray.prototype.intersectTrimesh = function intersectTrimesh(
    mesh,
    quat,
    position,
    body,
    reportedShape,
    options
){
    var normal = intersectTrimesh_normal;
    var triangles = intersectTrimesh_triangles;
    var treeTransform = intersectTrimesh_treeTransform;
    var minDistNormal = intersectConvex_minDistNormal;
    var vector = intersectConvex_vector;
    var minDistIntersect = intersectConvex_minDistIntersect;
    var localAABB = intersectTrimesh_localAABB;
    var localDirection = intersectTrimesh_localDirection;
    var localFrom = intersectTrimesh_localFrom;
    var localTo = intersectTrimesh_localTo;
    var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
    var worldNormal = intersectTrimesh_worldNormal;
    var faceList = (options && options.faceList) || null;

    // Checking faces
    var indices = mesh.indices,
        vertices = mesh.vertices,
        normals = mesh.faceNormals;

    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    var minDist = -1;
    treeTransform.position.copy(position);
    treeTransform.quaternion.copy(quat);

    // Transform ray to local space!
    Transform.vectorToLocalFrame(position, quat, direction, localDirection);
    Transform.pointToLocalFrame(position, quat, from, localFrom);
    Transform.pointToLocalFrame(position, quat, to, localTo);

    localTo.x *= mesh.scale.x;
    localTo.y *= mesh.scale.y;
    localTo.z *= mesh.scale.z;
    localFrom.x *= mesh.scale.x;
    localFrom.y *= mesh.scale.y;
    localFrom.z *= mesh.scale.z;

    localTo.vsub(localFrom, localDirection);
    localDirection.normalize();

    var fromToDistanceSquared = localFrom.distanceSquared(localTo);

    mesh.tree.rayQuery(this, treeTransform, triangles);

    for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {
        var trianglesIndex = triangles[i];

        mesh.getNormal(trianglesIndex, normal);

        // determine if ray intersects the plane of the face
        // note: this works regardless of the direction of the face normal

        // Get plane point in world coordinates...
        mesh.getVertex(indices[trianglesIndex * 3], a);

        // ...but make it relative to the ray from. We'll fix this later.
        a.vsub(localFrom,vector);

        // If this dot product is negative, we have something interesting
        var dot = localDirection.dot(normal);

        // Bail out if ray and plane are parallel
        // if (Math.abs( dot ) < this.precision){
        //     continue;
        // }

        // calc distance to plane
        var scalar = normal.dot(vector) / dot;

        // if negative distance, then plane is behind ray
        if (scalar < 0){
            continue;
        }

        // Intersection point is from + direction * scalar
        localDirection.scale(scalar,intersectPoint);
        intersectPoint.vadd(localFrom,intersectPoint);

        // Get triangle vertices
        mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
        mesh.getVertex(indices[trianglesIndex * 3 + 2], c);

        var squaredDistance = intersectPoint.distanceSquared(localFrom);

        if(!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared){
            continue;
        }

        // transform intersectpoint and normal to world
        Transform.vectorToWorldFrame(quat, normal, worldNormal);
        Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
        this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);
    }
    triangles.length = 0;
};
Ray.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh;


/**
 * @method reportIntersection
 * @private
 * @param  {Vec3} normal
 * @param  {Vec3} hitPointWorld
 * @param  {Shape} shape
 * @param  {Body} body
 * @return {boolean} True if the intersections should continue
 */
Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex){
    var from = this.from;
    var to = this.to;
    var distance = from.distanceTo(hitPointWorld);
    var result = this.result;

    // Skip back faces?
    if(this.skipBackfaces && normal.dot(this._direction) > 0){
        return;
    }

    result.hitFaceIndex = typeof(hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;

    switch(this.mode){
    case Ray.ALL:
        this.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result.hasHit = true;
        this.callback(result);
        break;

    case Ray.CLOSEST:

        // Store if closer than current closest
        if(distance < result.distance || !result.hasHit){
            this.hasHit = true;
            result.hasHit = true;
            result.set(
                from,
                to,
                normal,
                hitPointWorld,
                shape,
                body,
                distance
            );
        }
        break;

    case Ray.ANY:

        // Report and stop.
        this.hasHit = true;
        result.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result._shouldStop = true;
        break;
    }
};

var v0 = new Vec3(),
    intersect = new Vec3();
function distanceFromIntersection(from, direction, position) {

    // v0 is vector from from to position
    position.vsub(from,v0);
    var dot = v0.dot(direction);

    // intersect = direction*dot + from
    direction.mult(dot,intersect);
    intersect.vadd(from,intersect);

    var distance = position.distanceTo(intersect);

    return distance;
}


},{"../collision/AABB":3,"../collision/RaycastResult":11,"../math/Quaternion":29,"../math/Transform":30,"../math/Vec3":31,"../shapes/Box":38,"../shapes/ConvexPolyhedron":39,"../shapes/Shape":44}],11:[function(require,module,exports){
var Vec3 = require('../math/Vec3');

module.exports = RaycastResult;

/**
 * Storage for Ray casting data.
 * @class RaycastResult
 * @constructor
 */
function RaycastResult(){

	/**
	 * @property {Vec3} rayFromWorld
	 */
	this.rayFromWorld = new Vec3();

	/**
	 * @property {Vec3} rayToWorld
	 */
	this.rayToWorld = new Vec3();

	/**
	 * @property {Vec3} hitNormalWorld
	 */
	this.hitNormalWorld = new Vec3();

	/**
	 * @property {Vec3} hitPointWorld
	 */
	this.hitPointWorld = new Vec3();

	/**
	 * @property {boolean} hasHit
	 */
	this.hasHit = false;

	/**
	 * The hit shape, or null.
	 * @property {Shape} shape
	 */
	this.shape = null;

	/**
	 * The hit body, or null.
	 * @property {Body} body
	 */
	this.body = null;

	/**
	 * The index of the hit triangle, if the hit shape was a trimesh.
	 * @property {number} hitFaceIndex
	 * @default -1
	 */
	this.hitFaceIndex = -1;

	/**
	 * Distance to the hit. Will be set to -1 if there was no hit.
	 * @property {number} distance
	 * @default -1
	 */
	this.distance = -1;

	/**
	 * If the ray should stop traversing the bodies.
	 * @private
	 * @property {Boolean} _shouldStop
	 * @default false
	 */
	this._shouldStop = false;
}

/**
 * Reset all result data.
 * @method reset
 */
RaycastResult.prototype.reset = function () {
	this.rayFromWorld.setZero();
	this.rayToWorld.setZero();
	this.hitNormalWorld.setZero();
	this.hitPointWorld.setZero();
	this.hasHit = false;
	this.shape = null;
	this.body = null;
	this.hitFaceIndex = -1;
	this.distance = -1;
	this._shouldStop = false;
};

/**
 * @method abort
 */
RaycastResult.prototype.abort = function(){
	this._shouldStop = true;
};

/**
 * @method set
 * @param {Vec3} rayFromWorld
 * @param {Vec3} rayToWorld
 * @param {Vec3} hitNormalWorld
 * @param {Vec3} hitPointWorld
 * @param {Shape} shape
 * @param {Body} body
 * @param {number} distance
 */
RaycastResult.prototype.set = function(
	rayFromWorld,
	rayToWorld,
	hitNormalWorld,
	hitPointWorld,
	shape,
	body,
	distance
){
	this.rayFromWorld.copy(rayFromWorld);
	this.rayToWorld.copy(rayToWorld);
	this.hitNormalWorld.copy(hitNormalWorld);
	this.hitPointWorld.copy(hitPointWorld);
	this.shape = shape;
	this.body = body;
	this.distance = distance;
};
},{"../math/Vec3":31}],12:[function(require,module,exports){
var Shape = require('../shapes/Shape');
var Broadphase = require('../collision/Broadphase');

module.exports = SAPBroadphase;

/**
 * Sweep and prune broadphase along one axis.
 *
 * @class SAPBroadphase
 * @constructor
 * @param {World} [world]
 * @extends Broadphase
 */
function SAPBroadphase(world){
    Broadphase.apply(this);

    /**
     * List of bodies currently in the broadphase.
     * @property axisList
     * @type {Array}
     */
    this.axisList = [];

    /**
     * The world to search in.
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * Axis to sort the bodies along. Set to 0 for x axis, and 1 for y axis. For best performance, choose an axis that the bodies are spread out more on.
     * @property axisIndex
     * @type {Number}
     */
    this.axisIndex = 0;

    var axisList = this.axisList;

    this._addBodyHandler = function(e){
        axisList.push(e.body);
    };

    this._removeBodyHandler = function(e){
        var idx = axisList.indexOf(e.body);
        if(idx !== -1){
            axisList.splice(idx,1);
        }
    };

    if(world){
        this.setWorld(world);
    }
}
SAPBroadphase.prototype = new Broadphase();

/**
 * Change the world
 * @method setWorld
 * @param  {World} world
 */
SAPBroadphase.prototype.setWorld = function(world){
    // Clear the old axis array
    this.axisList.length = 0;

    // Add all bodies from the new world
    for(var i=0; i<world.bodies.length; i++){
        this.axisList.push(world.bodies[i]);
    }

    // Remove old handlers, if any
    world.removeEventListener("addBody", this._addBodyHandler);
    world.removeEventListener("removeBody", this._removeBodyHandler);

    // Add handlers to update the list of bodies.
    world.addEventListener("addBody", this._addBodyHandler);
    world.addEventListener("removeBody", this._removeBodyHandler);

    this.world = world;
    this.dirty = true;
};

/**
 * @static
 * @method insertionSortX
 * @param  {Array} a
 * @return {Array}
 */
SAPBroadphase.insertionSortX = function(a) {
    for(var i=1,l=a.length;i<l;i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

/**
 * @static
 * @method insertionSortY
 * @param  {Array} a
 * @return {Array}
 */
SAPBroadphase.insertionSortY = function(a) {
    for(var i=1,l=a.length;i<l;i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

/**
 * @static
 * @method insertionSortZ
 * @param  {Array} a
 * @return {Array}
 */
SAPBroadphase.insertionSortZ = function(a) {
    for(var i=1,l=a.length;i<l;i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

/**
 * Collect all collision pairs
 * @method collisionPairs
 * @param  {World} world
 * @param  {Array} p1
 * @param  {Array} p2
 */
SAPBroadphase.prototype.collisionPairs = function(world,p1,p2){
    var bodies = this.axisList,
        N = bodies.length,
        axisIndex = this.axisIndex,
        i, j;

    if(this.dirty){
        this.sortList();
        this.dirty = false;
    }

    // Look through the list
    for(i=0; i !== N; i++){
        var bi = bodies[i];

        for(j=i+1; j < N; j++){
            var bj = bodies[j];

            if(!this.needBroadphaseCollision(bi,bj)){
                continue;
            }

            if(!SAPBroadphase.checkBounds(bi,bj,axisIndex)){
                break;
            }

            this.intersectionTest(bi,bj,p1,p2);
        }
    }
};

SAPBroadphase.prototype.sortList = function(){
    var axisList = this.axisList;
    var axisIndex = this.axisIndex;
    var N = axisList.length;

    // Update AABBs
    for(var i = 0; i!==N; i++){
        var bi = axisList[i];
        if(bi.aabbNeedsUpdate){
            bi.computeAABB();
        }
    }

    // Sort the list
    if(axisIndex === 0){
        SAPBroadphase.insertionSortX(axisList);
    } else if(axisIndex === 1){
        SAPBroadphase.insertionSortY(axisList);
    } else if(axisIndex === 2){
        SAPBroadphase.insertionSortZ(axisList);
    }
};

/**
 * Check if the bounds of two bodies overlap, along the given SAP axis.
 * @static
 * @method checkBounds
 * @param  {Body} bi
 * @param  {Body} bj
 * @param  {Number} axisIndex
 * @return {Boolean}
 */
SAPBroadphase.checkBounds = function(bi, bj, axisIndex){
    var biPos;
    var bjPos;

    if(axisIndex === 0){
        biPos = bi.position.x;
        bjPos = bj.position.x;
    } else if(axisIndex === 1){
        biPos = bi.position.y;
        bjPos = bj.position.y;
    } else if(axisIndex === 2){
        biPos = bi.position.z;
        bjPos = bj.position.z;
    }

    var ri = bi.boundingRadius,
        rj = bj.boundingRadius,
        boundA1 = biPos - ri,
        boundA2 = biPos + ri,
        boundB1 = bjPos - rj,
        boundB2 = bjPos + rj;

    return boundB1 < boundA2;
};

/**
 * Computes the variance of the body positions and estimates the best
 * axis to use. Will automatically set property .axisIndex.
 * @method autoDetectAxis
 */
SAPBroadphase.prototype.autoDetectAxis = function(){
    var sumX=0,
        sumX2=0,
        sumY=0,
        sumY2=0,
        sumZ=0,
        sumZ2=0,
        bodies = this.axisList,
        N = bodies.length,
        invN=1/N;

    for(var i=0; i!==N; i++){
        var b = bodies[i];

        var centerX = b.position.x;
        sumX += centerX;
        sumX2 += centerX*centerX;

        var centerY = b.position.y;
        sumY += centerY;
        sumY2 += centerY*centerY;

        var centerZ = b.position.z;
        sumZ += centerZ;
        sumZ2 += centerZ*centerZ;
    }

    var varianceX = sumX2 - sumX*sumX*invN,
        varianceY = sumY2 - sumY*sumY*invN,
        varianceZ = sumZ2 - sumZ*sumZ*invN;

    if(varianceX > varianceY){
        if(varianceX > varianceZ){
            this.axisIndex = 0;
        } else{
            this.axisIndex = 2;
        }
    } else if(varianceY > varianceZ){
        this.axisIndex = 1;
    } else{
        this.axisIndex = 2;
    }
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    if(this.dirty){
        this.sortList();
        this.dirty = false;
    }

    var axisIndex = this.axisIndex, axis = 'x';
    if(axisIndex === 1){ axis = 'y'; }
    if(axisIndex === 2){ axis = 'z'; }

    var axisList = this.axisList;
    var lower = aabb.lowerBound[axis];
    var upper = aabb.upperBound[axis];
    for(var i = 0; i < axisList.length; i++){
        var b = axisList[i];

        if(b.aabbNeedsUpdate){
            b.computeAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":5,"../shapes/Shape":44}],13:[function(require,module,exports){
module.exports = ConeTwistConstraint;

var Constraint = require('./Constraint');
var PointToPointConstraint = require('./PointToPointConstraint');
var ConeEquation = require('../equations/ConeEquation');
var RotationalEquation = require('../equations/RotationalEquation');
var ContactEquation = require('../equations/ContactEquation');
var Vec3 = require('../math/Vec3');

/**
 * @class ConeTwistConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Vec3} [options.pivotA]
 * @param {Vec3} [options.pivotB]
 * @param {Vec3} [options.axisA]
 * @param {Vec3} [options.axisB]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
function ConeTwistConstraint(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    // Set pivot point in between
    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3();

    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

    this.collideConnected = !!options.collideConnected;

    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;

    /**
     * @property {ConeEquation} coneEquation
     */
    var c = this.coneEquation = new ConeEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} twistEquation
     */
    var t = this.twistEquation = new RotationalEquation(bodyA,bodyB,options);
    this.twistAngle = typeof(options.twistAngle) !== 'undefined' ? options.twistAngle : 0;

    // Make the cone equation push the bodies toward the cone axis, not outward
    c.maxForce = 0;
    c.minForce = -maxForce;

    // Make the twist equation add torque toward the initial position
    t.maxForce = 0;
    t.minForce = -maxForce;

    this.equations.push(c, t);
}
ConeTwistConstraint.prototype = new PointToPointConstraint();
ConeTwistConstraint.constructor = ConeTwistConstraint;

var ConeTwistConstraint_update_tmpVec1 = new Vec3();
var ConeTwistConstraint_update_tmpVec2 = new Vec3();

ConeTwistConstraint.prototype.update = function(){
    var bodyA = this.bodyA,
        bodyB = this.bodyB,
        cone = this.coneEquation,
        twist = this.twistEquation;

    PointToPointConstraint.prototype.update.call(this);

    // Update the axes to the cone constraint
    bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
    bodyB.vectorToWorldFrame(this.axisB, cone.axisB);

    // Update the world axes in the twist constraint
    this.axisA.tangents(twist.axisA, twist.axisA);
    bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);

    this.axisB.tangents(twist.axisB, twist.axisB);
    bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);

    cone.angle = this.angle;
    twist.maxAngle = this.twistAngle;
};


},{"../equations/ConeEquation":19,"../equations/ContactEquation":20,"../equations/RotationalEquation":23,"../math/Vec3":31,"./Constraint":14,"./PointToPointConstraint":18}],14:[function(require,module,exports){
module.exports = Constraint;

var Utils = require('../utils/Utils');

/**
 * Constraint base class
 * @class Constraint
 * @author schteppe
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {boolean} [options.collideConnected=true]
 * @param {boolean} [options.wakeUpBodies=true]
 */
function Constraint(bodyA, bodyB, options){
    options = Utils.defaults(options,{
        collideConnected : true,
        wakeUpBodies : true,
    });

    /**
     * Equations to be solved in this constraint
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * @property {Body} bodyA
     */
    this.bodyA = bodyA;

    /**
     * @property {Body} bodyB
     */
    this.bodyB = bodyB;

    /**
     * @property {Number} id
     */
    this.id = Constraint.idCounter++;

    /**
     * Set to true if you want the bodies to collide when they are connected.
     * @property collideConnected
     * @type {boolean}
     */
    this.collideConnected = options.collideConnected;

    if(options.wakeUpBodies){
        if(bodyA){
            bodyA.wakeUp();
        }
        if(bodyB){
            bodyB.wakeUp();
        }
    }
}

/**
 * Update all the equations with data.
 * @method update
 */
Constraint.prototype.update = function(){
    throw new Error("method update() not implmemented in this Constraint subclass!");
};

/**
 * Enables all equations in the constraint.
 * @method enable
 */
Constraint.prototype.enable = function(){
    var eqs = this.equations;
    for(var i=0; i<eqs.length; i++){
        eqs[i].enabled = true;
    }
};

/**
 * Disables all equations in the constraint.
 * @method disable
 */
Constraint.prototype.disable = function(){
    var eqs = this.equations;
    for(var i=0; i<eqs.length; i++){
        eqs[i].enabled = false;
    }
};

Constraint.idCounter = 0;

},{"../utils/Utils":54}],15:[function(require,module,exports){
module.exports = DistanceConstraint;

var Constraint = require('./Constraint');
var ContactEquation = require('../equations/ContactEquation');

/**
 * Constrains two bodies to be at a constant distance from each others center of mass.
 * @class DistanceConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} [distance] The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
 * @param {Number} [maxForce=1e6]
 * @extends Constraint
 */
function DistanceConstraint(bodyA,bodyB,distance,maxForce){
    Constraint.call(this,bodyA,bodyB);

    if(typeof(distance)==="undefined") {
        distance = bodyA.position.distanceTo(bodyB.position);
    }

    if(typeof(maxForce)==="undefined") {
        maxForce = 1e6;
    }

    /**
     * @property {number} distance
     */
    this.distance = distance;

    /**
     * @property {ContactEquation} distanceEquation
     */
    var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
    this.equations.push(eq);

    // Make it bidirectional
    eq.minForce = -maxForce;
    eq.maxForce =  maxForce;
}
DistanceConstraint.prototype = new Constraint();

DistanceConstraint.prototype.update = function(){
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;
    var eq = this.distanceEquation;
    var halfDist = this.distance * 0.5;
    var normal = eq.ni;

    bodyB.position.vsub(bodyA.position, normal);
    normal.normalize();
    normal.mult(halfDist, eq.ri);
    normal.mult(-halfDist, eq.rj);
};
},{"../equations/ContactEquation":20,"./Constraint":14}],16:[function(require,module,exports){
module.exports = HingeConstraint;

var Constraint = require('./Constraint');
var PointToPointConstraint = require('./PointToPointConstraint');
var RotationalEquation = require('../equations/RotationalEquation');
var RotationalMotorEquation = require('../equations/RotationalMotorEquation');
var ContactEquation = require('../equations/ContactEquation');
var Vec3 = require('../math/Vec3');

/**
 * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
 * @class HingeConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.
 * @param {Vec3} [options.axisA] An axis that bodyA can rotate around, defined locally in bodyA.
 * @param {Vec3} [options.pivotB]
 * @param {Vec3} [options.axisB]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
function HingeConstraint(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;
    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();

    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

    /**
     * Rotation axis, defined locally in bodyA.
     * @property {Vec3} axisA
     */
    var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1,0,0);
    axisA.normalize();

    /**
     * Rotation axis, defined locally in bodyB.
     * @property {Vec3} axisB
     */
    var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1,0,0);
    axisB.normalize();

    /**
     * @property {RotationalEquation} rotationalEquation1
     */
    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} rotationalEquation2
     */
    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalMotorEquation} motorEquation
     */
    var motor = this.motorEquation = new RotationalMotorEquation(bodyA,bodyB,maxForce);
    motor.enabled = false; // Not enabled by default

    // Equations to be fed to the solver
    this.equations.push(
        r1, // rotational1
        r2, // rotational2
        motor
    );
}
HingeConstraint.prototype = new PointToPointConstraint();
HingeConstraint.constructor = HingeConstraint;

/**
 * @method enableMotor
 */
HingeConstraint.prototype.enableMotor = function(){
    this.motorEquation.enabled = true;
};

/**
 * @method disableMotor
 */
HingeConstraint.prototype.disableMotor = function(){
    this.motorEquation.enabled = false;
};

/**
 * @method setMotorSpeed
 * @param {number} speed
 */
HingeConstraint.prototype.setMotorSpeed = function(speed){
    this.motorEquation.targetVelocity = speed;
};

/**
 * @method setMotorMaxForce
 * @param {number} maxForce
 */
HingeConstraint.prototype.setMotorMaxForce = function(maxForce){
    this.motorEquation.maxForce = maxForce;
    this.motorEquation.minForce = -maxForce;
};

var HingeConstraint_update_tmpVec1 = new Vec3();
var HingeConstraint_update_tmpVec2 = new Vec3();

HingeConstraint.prototype.update = function(){
    var bodyA = this.bodyA,
        bodyB = this.bodyB,
        motor = this.motorEquation,
        r1 = this.rotationalEquation1,
        r2 = this.rotationalEquation2,
        worldAxisA = HingeConstraint_update_tmpVec1,
        worldAxisB = HingeConstraint_update_tmpVec2;

    var axisA = this.axisA;
    var axisB = this.axisB;

    PointToPointConstraint.prototype.update.call(this);

    // Get world axes
    bodyA.quaternion.vmult(axisA, worldAxisA);
    bodyB.quaternion.vmult(axisB, worldAxisB);

    worldAxisA.tangents(r1.axisA, r2.axisA);
    r1.axisB.copy(worldAxisB);
    r2.axisB.copy(worldAxisB);

    if(this.motorEquation.enabled){
        bodyA.quaternion.vmult(this.axisA, motor.axisA);
        bodyB.quaternion.vmult(this.axisB, motor.axisB);
    }
};


},{"../equations/ContactEquation":20,"../equations/RotationalEquation":23,"../equations/RotationalMotorEquation":24,"../math/Vec3":31,"./Constraint":14,"./PointToPointConstraint":18}],17:[function(require,module,exports){
module.exports = LockConstraint;

var Constraint = require('./Constraint');
var PointToPointConstraint = require('./PointToPointConstraint');
var RotationalEquation = require('../equations/RotationalEquation');
var RotationalMotorEquation = require('../equations/RotationalMotorEquation');
var ContactEquation = require('../equations/ContactEquation');
var Vec3 = require('../math/Vec3');

/**
 * Lock constraint. Will remove all degrees of freedom between the bodies.
 * @class LockConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
function LockConstraint(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    // Set pivot point in between
    var pivotA = new Vec3();
    var pivotB = new Vec3();
    var halfWay = new Vec3();
    bodyA.position.vadd(bodyB.position, halfWay);
    halfWay.scale(0.5, halfWay);
    bodyB.pointToLocalFrame(halfWay, pivotB);
    bodyA.pointToLocalFrame(halfWay, pivotA);

    // The point-to-point constraint will keep a point shared between the bodies
    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

    // Store initial rotation of the bodies as unit vectors in the local body spaces
    this.xA = bodyA.vectorToLocalFrame(Vec3.UNIT_X);
    this.xB = bodyB.vectorToLocalFrame(Vec3.UNIT_X);
    this.yA = bodyA.vectorToLocalFrame(Vec3.UNIT_Y);
    this.yB = bodyB.vectorToLocalFrame(Vec3.UNIT_Y);
    this.zA = bodyA.vectorToLocalFrame(Vec3.UNIT_Z);
    this.zB = bodyB.vectorToLocalFrame(Vec3.UNIT_Z);

    // ...and the following rotational equations will keep all rotational DOF's in place

    /**
     * @property {RotationalEquation} rotationalEquation1
     */
    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} rotationalEquation2
     */
    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} rotationalEquation3
     */
    var r3 = this.rotationalEquation3 = new RotationalEquation(bodyA,bodyB,options);

    this.equations.push(r1, r2, r3);
}
LockConstraint.prototype = new PointToPointConstraint();
LockConstraint.constructor = LockConstraint;

var LockConstraint_update_tmpVec1 = new Vec3();
var LockConstraint_update_tmpVec2 = new Vec3();

LockConstraint.prototype.update = function(){
    var bodyA = this.bodyA,
        bodyB = this.bodyB,
        motor = this.motorEquation,
        r1 = this.rotationalEquation1,
        r2 = this.rotationalEquation2,
        r3 = this.rotationalEquation3,
        worldAxisA = LockConstraint_update_tmpVec1,
        worldAxisB = LockConstraint_update_tmpVec2;

    PointToPointConstraint.prototype.update.call(this);

    // These vector pairs must be orthogonal
    bodyA.vectorToWorldFrame(this.xA, r1.axisA);
    bodyB.vectorToWorldFrame(this.yB, r1.axisB);

    bodyA.vectorToWorldFrame(this.yA, r2.axisA);
    bodyB.vectorToWorldFrame(this.zB, r2.axisB);

    bodyA.vectorToWorldFrame(this.zA, r3.axisA);
    bodyB.vectorToWorldFrame(this.xB, r3.axisB);
};


},{"../equations/ContactEquation":20,"../equations/RotationalEquation":23,"../equations/RotationalMotorEquation":24,"../math/Vec3":31,"./Constraint":14,"./PointToPointConstraint":18}],18:[function(require,module,exports){
module.exports = PointToPointConstraint;

var Constraint = require('./Constraint');
var ContactEquation = require('../equations/ContactEquation');
var Vec3 = require('../math/Vec3');

/**
 * Connects two bodies at given offset points.
 * @class PointToPointConstraint
 * @extends Constraint
 * @constructor
 * @param {Body} bodyA
 * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
 * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
 * @param {Vec3} pivotB See pivotA.
 * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.
 *
 * @example
 *     var bodyA = new Body({ mass: 1 });
 *     var bodyB = new Body({ mass: 1 });
 *     bodyA.position.set(-1, 0, 0);
 *     bodyB.position.set(1, 0, 0);
 *     bodyA.addShape(shapeA);
 *     bodyB.addShape(shapeB);
 *     world.addBody(bodyA);
 *     world.addBody(bodyB);
 *     var localPivotA = new Vec3(1, 0, 0);
 *     var localPivotB = new Vec3(-1, 0, 0);
 *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);
 *     world.addConstraint(constraint);
 */
function PointToPointConstraint(bodyA,pivotA,bodyB,pivotB,maxForce){
    Constraint.call(this,bodyA,bodyB);

    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;

    /**
     * Pivot, defined locally in bodyA.
     * @property {Vec3} pivotA
     */
    this.pivotA = pivotA ? pivotA.clone() : new Vec3();

    /**
     * Pivot, defined locally in bodyB.
     * @property {Vec3} pivotB
     */
    this.pivotB = pivotB ? pivotB.clone() : new Vec3();

    /**
     * @property {ContactEquation} equationX
     */
    var x = this.equationX = new ContactEquation(bodyA,bodyB);

    /**
     * @property {ContactEquation} equationY
     */
    var y = this.equationY = new ContactEquation(bodyA,bodyB);

    /**
     * @property {ContactEquation} equationZ
     */
    var z = this.equationZ = new ContactEquation(bodyA,bodyB);

    // Equations to be fed to the solver
    this.equations.push(x, y, z);

    // Make the equations bidirectional
    x.minForce = y.minForce = z.minForce = -maxForce;
    x.maxForce = y.maxForce = z.maxForce =  maxForce;

    x.ni.set(1, 0, 0);
    y.ni.set(0, 1, 0);
    z.ni.set(0, 0, 1);
}
PointToPointConstraint.prototype = new Constraint();

PointToPointConstraint.prototype.update = function(){
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;
    var x = this.equationX;
    var y = this.equationY;
    var z = this.equationZ;

    // Rotate the pivots to world space
    bodyA.quaternion.vmult(this.pivotA,x.ri);
    bodyB.quaternion.vmult(this.pivotB,x.rj);

    y.ri.copy(x.ri);
    y.rj.copy(x.rj);
    z.ri.copy(x.ri);
    z.rj.copy(x.rj);
};
},{"../equations/ContactEquation":20,"../math/Vec3":31,"./Constraint":14}],19:[function(require,module,exports){
module.exports = ConeEquation;

var Vec3 = require('../math/Vec3');
var Mat3 = require('../math/Mat3');
var Equation = require('./Equation');

/**
 * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
 * @class ConeEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec3} [options.axisA] Local axis in A
 * @param {Vec3} [options.axisB] Local axis in B
 * @param {Vec3} [options.angle] The "cone angle" to keep
 * @param {number} [options.maxForce=1e6]
 * @extends Equation
 */
function ConeEquation(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);

    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);

    /**
     * The cone angle to keep
     * @property {number} angle
     */
    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;
}

ConeEquation.prototype = new Equation();
ConeEquation.prototype.constructor = ConeEquation;

var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();

ConeEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,

        ni = this.axisA,
        nj = this.axisB,

        nixnj = tmpVec1,
        njxni = tmpVec2,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB;

    // Caluclate cross products
    ni.cross(nj, nixnj);
    nj.cross(ni, njxni);

    // The angle between two vector is:
    // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b

    // g = a * b
    // gdot = (b x a) * wi + (a x b) * wj
    // G = [0 bxa 0 axb]
    // W = [vi wi vj wj]
    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);

    var g = Math.cos(this.angle) - ni.dot(nj),
        GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = - g * a - GW * b - h * GiMf;

    return B;
};


},{"../math/Mat3":28,"../math/Vec3":31,"./Equation":21}],20:[function(require,module,exports){
module.exports = ContactEquation;

var Equation = require('./Equation');
var Vec3 = require('../math/Vec3');
var Mat3 = require('../math/Mat3');

/**
 * Contact/non-penetration constraint equation
 * @class ContactEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @extends Equation
 */
function ContactEquation(bodyA, bodyB, maxForce){
    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;
    Equation.call(this, bodyA, bodyB, 0, maxForce);

    /**
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0.0; // "bounciness": u1 = -e*u0

    /**
     * World-oriented vector that goes from the center of bi to the contact point.
     * @property {Vec3} ri
     */
    this.ri = new Vec3();

    /**
     * World-oriented vector that starts in body j position and goes to the contact point.
     * @property {Vec3} rj
     */
    this.rj = new Vec3();

    /**
     * Contact normal, pointing out of body i.
     * @property {Vec3} ni
     */
    this.ni = new Vec3();
}

ContactEquation.prototype = new Equation();
ContactEquation.prototype.constructor = ContactEquation;

var ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors
var ContactEquation_computeB_temp2 = new Vec3();
var ContactEquation_computeB_temp3 = new Vec3();
ContactEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,
        bi = this.bi,
        bj = this.bj,
        ri = this.ri,
        rj = this.rj,
        rixn = ContactEquation_computeB_temp1,
        rjxn = ContactEquation_computeB_temp2,

        vi = bi.velocity,
        wi = bi.angularVelocity,
        fi = bi.force,
        taui = bi.torque,

        vj = bj.velocity,
        wj = bj.angularVelocity,
        fj = bj.force,
        tauj = bj.torque,

        penetrationVec = ContactEquation_computeB_temp3,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB,

        n = this.ni;

    // Caluclate cross products
    ri.cross(n,rixn);
    rj.cross(n,rjxn);

    // g = xj+rj -(xi+ri)
    // G = [ -ni  -rixn  ni  rjxn ]
    n.negate(GA.spatial);
    rixn.negate(GA.rotational);
    GB.spatial.copy(n);
    GB.rotational.copy(rjxn);

    // Calculate the penetration vector
    penetrationVec.copy(bj.position);
    penetrationVec.vadd(rj,penetrationVec);
    penetrationVec.vsub(bi.position,penetrationVec);
    penetrationVec.vsub(ri,penetrationVec);

    var g = n.dot(penetrationVec);

    // Compute iteration
    var ePlusOne = this.restitution + 1;
    var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
    var GiMf = this.computeGiMf();

    var B = - g * a - GW * b - h*GiMf;

    return B;
};

var ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();

/**
 * Get the current relative velocity in the contact point.
 * @method getImpactVelocityAlongNormal
 * @return {number}
 */
ContactEquation.prototype.getImpactVelocityAlongNormal = function(){
    var vi = ContactEquation_getImpactVelocityAlongNormal_vi;
    var vj = ContactEquation_getImpactVelocityAlongNormal_vj;
    var xi = ContactEquation_getImpactVelocityAlongNormal_xi;
    var xj = ContactEquation_getImpactVelocityAlongNormal_xj;
    var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;

    this.bi.position.vadd(this.ri, xi);
    this.bj.position.vadd(this.rj, xj);

    this.bi.getVelocityAtWorldPoint(xi, vi);
    this.bj.getVelocityAtWorldPoint(xj, vj);

    vi.vsub(vj, relVel);

    return this.ni.dot(relVel);
};


},{"../math/Mat3":28,"../math/Vec3":31,"./Equation":21}],21:[function(require,module,exports){
module.exports = Equation;

var JacobianElement = require('../math/JacobianElement'),
    Vec3 = require('../math/Vec3');

/**
 * Equation base class
 * @class Equation
 * @constructor
 * @author schteppe
 * @param {Body} bi
 * @param {Body} bj
 * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.
 * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.
 */
function Equation(bi,bj,minForce,maxForce){
    this.id = Equation.id++;

    /**
     * @property {number} minForce
     */
    this.minForce = typeof(minForce)==="undefined" ? -1e6 : minForce;

    /**
     * @property {number} maxForce
     */
    this.maxForce = typeof(maxForce)==="undefined" ? 1e6 : maxForce;

    /**
     * @property bi
     * @type {Body}
     */
    this.bi = bi;

    /**
     * @property bj
     * @type {Body}
     */
    this.bj = bj;

    /**
     * SPOOK parameter
     * @property {number} a
     */
    this.a = 0.0;

    /**
     * SPOOK parameter
     * @property {number} b
     */
    this.b = 0.0;

    /**
     * SPOOK parameter
     * @property {number} eps
     */
    this.eps = 0.0;

    /**
     * @property {JacobianElement} jacobianElementA
     */
    this.jacobianElementA = new JacobianElement();

    /**
     * @property {JacobianElement} jacobianElementB
     */
    this.jacobianElementB = new JacobianElement();

    /**
     * @property {boolean} enabled
     * @default true
     */
    this.enabled = true;

    /**
     * A number, proportional to the force added to the bodies.
     * @property {number} multiplier
     * @readonly
     */
    this.multiplier = 0;

    // Set typical spook params
    this.setSpookParams(1e7,4,1/60);
}
Equation.prototype.constructor = Equation;

Equation.id = 0;

/**
 * Recalculates a,b,eps.
 * @method setSpookParams
 */
Equation.prototype.setSpookParams = function(stiffness,relaxation,timeStep){
    var d = relaxation,
        k = stiffness,
        h = timeStep;
    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = (4.0 * d) / (1 + 4 * d);
    this.eps = 4.0 / (h * h * k * (1 + 4 * d));
};

/**
 * Computes the RHS of the SPOOK equation
 * @method computeB
 * @return {Number}
 */
Equation.prototype.computeB = function(a,b,h){
    var GW = this.computeGW(),
        Gq = this.computeGq(),
        GiMf = this.computeGiMf();
    return - Gq * a - GW * b - GiMf*h;
};

/**
 * Computes G*q, where q are the generalized body coordinates
 * @method computeGq
 * @return {Number}
 */
Equation.prototype.computeGq = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        xi = bi.position,
        xj = bj.position;
    return GA.spatial.dot(xi) + GB.spatial.dot(xj);
};

var zero = new Vec3();

/**
 * Computes G*W, where W are the body velocities
 * @method computeGW
 * @return {Number}
 */
Equation.prototype.computeGW = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        vi = bi.velocity,
        vj = bj.velocity,
        wi = bi.angularVelocity,
        wj = bj.angularVelocity;
    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);
};


/**
 * Computes G*Wlambda, where W are the body velocities
 * @method computeGWlambda
 * @return {Number}
 */
Equation.prototype.computeGWlambda = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        vi = bi.vlambda,
        vj = bj.vlambda,
        wi = bi.wlambda,
        wj = bj.wlambda;
    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);
};

/**
 * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
 * @method computeGiMf
 * @return {Number}
 */
var iMfi = new Vec3(),
    iMfj = new Vec3(),
    invIi_vmult_taui = new Vec3(),
    invIj_vmult_tauj = new Vec3();
Equation.prototype.computeGiMf = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        fi = bi.force,
        ti = bi.torque,
        fj = bj.force,
        tj = bj.torque,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve;

    fi.scale(invMassi,iMfi);
    fj.scale(invMassj,iMfj);

    bi.invInertiaWorldSolve.vmult(ti,invIi_vmult_taui);
    bj.invInertiaWorldSolve.vmult(tj,invIj_vmult_tauj);

    return GA.multiplyVectors(iMfi,invIi_vmult_taui) + GB.multiplyVectors(iMfj,invIj_vmult_tauj);
};

/**
 * Computes G*inv(M)*G'
 * @method computeGiMGt
 * @return {Number}
 */
var tmp = new Vec3();
Equation.prototype.computeGiMGt = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaWorldSolve,
        invIj = bj.invInertiaWorldSolve,
        result = invMassi + invMassj;

    invIi.vmult(GA.rotational,tmp);
    result += tmp.dot(GA.rotational);

    invIj.vmult(GB.rotational,tmp);
    result += tmp.dot(GB.rotational);

    return  result;
};

var addToWlambda_temp = new Vec3(),
    addToWlambda_Gi = new Vec3(),
    addToWlambda_Gj = new Vec3(),
    addToWlambda_ri = new Vec3(),
    addToWlambda_rj = new Vec3(),
    addToWlambda_Mdiag = new Vec3();

/**
 * Add constraint velocity to the bodies.
 * @method addToWlambda
 * @param {Number} deltalambda
 */
Equation.prototype.addToWlambda = function(deltalambda){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        temp = addToWlambda_temp;

    // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G
    bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);
    bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda);

    // Add to angular velocity
    bi.invInertiaWorldSolve.vmult(GA.rotational,temp);
    bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);

    bj.invInertiaWorldSolve.vmult(GB.rotational,temp);
    bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);
};

/**
 * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
 * @method computeInvC
 * @param  {Number} eps
 * @return {Number}
 */
Equation.prototype.computeC = function(){
    return this.computeGiMGt() + this.eps;
};

},{"../math/JacobianElement":27,"../math/Vec3":31}],22:[function(require,module,exports){
module.exports = FrictionEquation;

var Equation = require('./Equation');
var Vec3 = require('../math/Vec3');
var Mat3 = require('../math/Mat3');

/**
 * Constrains the slipping in a contact along a tangent
 * @class FrictionEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
 * @extends Equation
 */
function FrictionEquation(bodyA, bodyB, slipForce){
    Equation.call(this,bodyA, bodyB, -slipForce, slipForce);
    this.ri = new Vec3();
    this.rj = new Vec3();
    this.t = new Vec3(); // tangent
}

FrictionEquation.prototype = new Equation();
FrictionEquation.prototype.constructor = FrictionEquation;

var FrictionEquation_computeB_temp1 = new Vec3();
var FrictionEquation_computeB_temp2 = new Vec3();
FrictionEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,
        bi = this.bi,
        bj = this.bj,
        ri = this.ri,
        rj = this.rj,
        rixt = FrictionEquation_computeB_temp1,
        rjxt = FrictionEquation_computeB_temp2,
        t = this.t;

    // Caluclate cross products
    ri.cross(t,rixt);
    rj.cross(t,rjxt);

    // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB;
    t.negate(GA.spatial);
    rixt.negate(GA.rotational);
    GB.spatial.copy(t);
    GB.rotational.copy(rjxt);

    var GW = this.computeGW();
    var GiMf = this.computeGiMf();

    var B = - GW * b - h * GiMf;

    return B;
};

},{"../math/Mat3":28,"../math/Vec3":31,"./Equation":21}],23:[function(require,module,exports){
module.exports = RotationalEquation;

var Vec3 = require('../math/Vec3');
var Mat3 = require('../math/Mat3');
var Equation = require('./Equation');

/**
 * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
 * @class RotationalEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec3} [options.axisA]
 * @param {Vec3} [options.axisB]
 * @param {number} [options.maxForce]
 * @extends Equation
 */
function RotationalEquation(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);

    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);

    this.maxAngle = Math.PI / 2;
}

RotationalEquation.prototype = new Equation();
RotationalEquation.prototype.constructor = RotationalEquation;

var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();

RotationalEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,

        ni = this.axisA,
        nj = this.axisB,

        nixnj = tmpVec1,
        njxni = tmpVec2,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB;

    // Caluclate cross products
    ni.cross(nj, nixnj);
    nj.cross(ni, njxni);

    // g = ni * nj
    // gdot = (nj x ni) * wi + (ni x nj) * wj
    // G = [0 njxni 0 nixnj]
    // W = [vi wi vj wj]
    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);

    var g = Math.cos(this.maxAngle) - ni.dot(nj),
        GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = - g * a - GW * b - h * GiMf;

    return B;
};


},{"../math/Mat3":28,"../math/Vec3":31,"./Equation":21}],24:[function(require,module,exports){
module.exports = RotationalMotorEquation;

var Vec3 = require('../math/Vec3');
var Mat3 = require('../math/Mat3');
var Equation = require('./Equation');

/**
 * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
 * @class RotationalMotorEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} maxForce
 * @extends Equation
 */
function RotationalMotorEquation(bodyA, bodyB, maxForce){
    maxForce = typeof(maxForce)!=='undefined' ? maxForce : 1e6;
    Equation.call(this,bodyA,bodyB,-maxForce,maxForce);

    /**
     * World oriented rotational axis
     * @property {Vec3} axisA
     */
    this.axisA = new Vec3();

    /**
     * World oriented rotational axis
     * @property {Vec3} axisB
     */
    this.axisB = new Vec3(); // World oriented rotational axis

    /**
     * Motor velocity
     * @property {Number} targetVelocity
     */
    this.targetVelocity = 0;
}

RotationalMotorEquation.prototype = new Equation();
RotationalMotorEquation.prototype.constructor = RotationalMotorEquation;

RotationalMotorEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,
        bi = this.bi,
        bj = this.bj,

        axisA = this.axisA,
        axisB = this.axisB,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB;

    // g = 0
    // gdot = axisA * wi - axisB * wj
    // gdot = G * W = G * [vi wi vj wj]
    // =>
    // G = [0 axisA 0 -axisB]

    GA.rotational.copy(axisA);
    axisB.negate(GB.rotational);

    var GW = this.computeGW() - this.targetVelocity,
        GiMf = this.computeGiMf();

    var B = - GW * b - h * GiMf;

    return B;
};

},{"../math/Mat3":28,"../math/Vec3":31,"./Equation":21}],25:[function(require,module,exports){
var Utils = require('../utils/Utils');

module.exports = ContactMaterial;

/**
 * Defines what happens when two materials meet.
 * @class ContactMaterial
 * @constructor
 * @param {Material} m1
 * @param {Material} m2
 * @param {object} [options]
 * @param {Number} [options.friction=0.3]
 * @param {Number} [options.restitution=0.3]
 * @param {number} [options.contactEquationStiffness=1e7]
 * @param {number} [options.contactEquationRelaxation=3]
 * @param {number} [options.frictionEquationStiffness=1e7]
 * @param {Number} [options.frictionEquationRelaxation=3]
 */
function ContactMaterial(m1, m2, options){
    options = Utils.defaults(options, {
        friction: 0.3,
        restitution: 0.3,
        contactEquationStiffness: 1e7,
        contactEquationRelaxation: 3,
        frictionEquationStiffness: 1e7,
        frictionEquationRelaxation: 3
    });

    /**
     * Identifier of this material
     * @property {Number} id
     */
    this.id = ContactMaterial.idCounter++;

    /**
     * Participating materials
     * @property {Array} materials
     * @todo  Should be .materialA and .materialB instead
     */
    this.materials = [m1, m2];

    /**
     * Friction coefficient
     * @property {Number} friction
     */
    this.friction = options.friction;

    /**
     * Restitution coefficient
     * @property {Number} restitution
     */
    this.restitution = options.restitution;

    /**
     * Stiffness of the produced contact equations
     * @property {Number} contactEquationStiffness
     */
    this.contactEquationStiffness = options.contactEquationStiffness;

    /**
     * Relaxation time of the produced contact equations
     * @property {Number} contactEquationRelaxation
     */
    this.contactEquationRelaxation = options.contactEquationRelaxation;

    /**
     * Stiffness of the produced friction equations
     * @property {Number} frictionEquationStiffness
     */
    this.frictionEquationStiffness = options.frictionEquationStiffness;

    /**
     * Relaxation time of the produced friction equations
     * @property {Number} frictionEquationRelaxation
     */
    this.frictionEquationRelaxation = options.frictionEquationRelaxation;
}

ContactMaterial.idCounter = 0;

},{"../utils/Utils":54}],26:[function(require,module,exports){
module.exports = Material;

/**
 * Defines a physics material.
 * @class Material
 * @constructor
 * @param {object} [options]
 * @author schteppe
 */
function Material(options){
    var name = '';
    options = options || {};

    // Backwards compatibility fix
    if(typeof(options) === 'string'){
        name = options;
        options = {};
    } else if(typeof(options) === 'object') {
        name = '';
    }

    /**
     * @property name
     * @type {String}
     */
    this.name = name;

    /**
     * material id.
     * @property id
     * @type {number}
     */
    this.id = Material.idCounter++;

    /**
     * Friction for this material. If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
     * @property {number} friction
     */
    this.friction = typeof(options.friction) !== 'undefined' ? options.friction : -1;

    /**
     * Restitution for this material. If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
     * @property {number} restitution
     */
    this.restitution = typeof(options.restitution) !== 'undefined' ? options.restitution : -1;
}

Material.idCounter = 0;

},{}],27:[function(require,module,exports){
module.exports = JacobianElement;

var Vec3 = require('./Vec3');

/**
 * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
 * @class JacobianElement
 * @constructor
 */
function JacobianElement(){

    /**
     * @property {Vec3} spatial
     */
    this.spatial = new Vec3();

    /**
     * @property {Vec3} rotational
     */
    this.rotational = new Vec3();
}

/**
 * Multiply with other JacobianElement
 * @method multiplyElement
 * @param  {JacobianElement} element
 * @return {Number}
 */
JacobianElement.prototype.multiplyElement = function(element){
    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
};

/**
 * Multiply with two vectors
 * @method multiplyVectors
 * @param  {Vec3} spatial
 * @param  {Vec3} rotational
 * @return {Number}
 */
JacobianElement.prototype.multiplyVectors = function(spatial,rotational){
    return spatial.dot(this.spatial) + rotational.dot(this.rotational);
};

},{"./Vec3":31}],28:[function(require,module,exports){
module.exports = Mat3;

var Vec3 = require('./Vec3');

/**
 * A 3x3 matrix.
 * @class Mat3
 * @constructor
 * @param array elements Array of nine elements. Optional.
 * @author schteppe / http://github.com/schteppe
 */
function Mat3(elements){
    /**
     * A vector of length 9, containing all matrix elements
     * @property {Array} elements
     */
    if(elements){
        this.elements = elements;
    } else {
        this.elements = [0,0,0,0,0,0,0,0,0];
    }
}

/**
 * Sets the matrix to identity
 * @method identity
 * @todo Should perhaps be renamed to setIdentity() to be more clear.
 * @todo Create another function that immediately creates an identity matrix eg. eye()
 */
Mat3.prototype.identity = function(){
    var e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;

    e[3] = 0;
    e[4] = 1;
    e[5] = 0;

    e[6] = 0;
    e[7] = 0;
    e[8] = 1;
};

/**
 * Set all elements to zero
 * @method setZero
 */
Mat3.prototype.setZero = function(){
    var e = this.elements;
    e[0] = 0;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 0;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 0;
};

/**
 * Sets the matrix diagonal elements from a Vec3
 * @method setTrace
 * @param {Vec3} vec3
 */
Mat3.prototype.setTrace = function(vec3){
    var e = this.elements;
    e[0] = vec3.x;
    e[4] = vec3.y;
    e[8] = vec3.z;
};

/**
 * Gets the matrix diagonal elements
 * @method getTrace
 * @return {Vec3}
 */
Mat3.prototype.getTrace = function(target){
    var target = target || new Vec3();
    var e = this.elements;
    target.x = e[0];
    target.y = e[4];
    target.z = e[8];
};

/**
 * Matrix-Vector multiplication
 * @method vmult
 * @param {Vec3} v The vector to multiply with
 * @param {Vec3} target Optional, target to save the result in.
 */
Mat3.prototype.vmult = function(v,target){
    target = target || new Vec3();

    var e = this.elements,
        x = v.x,
        y = v.y,
        z = v.z;
    target.x = e[0]*x + e[1]*y + e[2]*z;
    target.y = e[3]*x + e[4]*y + e[5]*z;
    target.z = e[6]*x + e[7]*y + e[8]*z;

    return target;
};

/**
 * Matrix-scalar multiplication
 * @method smult
 * @param {Number} s
 */
Mat3.prototype.smult = function(s){
    for(var i=0; i<this.elements.length; i++){
        this.elements[i] *= s;
    }
};

/**
 * Matrix multiplication
 * @method mmult
 * @param {Mat3} m Matrix to multiply with from left side.
 * @return {Mat3} The result.
 */
Mat3.prototype.mmult = function(m,target){
    var r = target || new Mat3();
    for(var i=0; i<3; i++){
        for(var j=0; j<3; j++){
            var sum = 0.0;
            for(var k=0; k<3; k++){
                sum += m.elements[i+k*3] * this.elements[k+j*3];
            }
            r.elements[i+j*3] = sum;
        }
    }
    return r;
};

/**
 * Scale each column of the matrix
 * @method scale
 * @param {Vec3} v
 * @return {Mat3} The result.
 */
Mat3.prototype.scale = function(v,target){
    target = target || new Mat3();
    var e = this.elements,
        t = target.elements;
    for(var i=0; i!==3; i++){
        t[3*i + 0] = v.x * e[3*i + 0];
        t[3*i + 1] = v.y * e[3*i + 1];
        t[3*i + 2] = v.z * e[3*i + 2];
    }
    return target;
};

/**
 * Solve Ax=b
 * @method solve
 * @param {Vec3} b The right hand side
 * @param {Vec3} target Optional. Target vector to save in.
 * @return {Vec3} The solution x
 * @todo should reuse arrays
 */
Mat3.prototype.solve = function(b,target){
    target = target || new Vec3();

    // Construct equations
    var nr = 3; // num rows
    var nc = 4; // num cols
    var eqns = [];
    for(var i=0; i<nr*nc; i++){
        eqns.push(0);
    }
    var i,j;
    for(i=0; i<3; i++){
        for(j=0; j<3; j++){
            eqns[i+nc*j] = this.elements[i+3*j];
        }
    }
    eqns[3+4*0] = b.x;
    eqns[3+4*1] = b.y;
    eqns[3+4*2] = b.z;

    // Compute right upper triangular version of the matrix - Gauss elimination
    var n = 3, k = n, np;
    var kp = 4; // num rows
    var p, els;
    do {
        i = k - n;
        if (eqns[i+nc*i] === 0) {
            // the pivot is null, swap lines
            for (j = i + 1; j < k; j++) {
                if (eqns[i+nc*j] !== 0) {
                    np = kp;
                    do {  // do ligne( i ) = ligne( i ) + ligne( k )
                        p = kp - np;
                        eqns[p+nc*i] += eqns[p+nc*j];
                    } while (--np);
                    break;
                }
            }
        }
        if (eqns[i+nc*i] !== 0) {
            for (j = i + 1; j < k; j++) {
                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
                np = kp;
                do {  // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
                    p = kp - np;
                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
                } while (--np);
            }
        }
    } while (--n);

    // Get the solution
    target.z = eqns[2*nc+3] / eqns[2*nc+2];
    target.y = (eqns[1*nc+3] - eqns[1*nc+2]*target.z) / eqns[1*nc+1];
    target.x = (eqns[0*nc+3] - eqns[0*nc+2]*target.z - eqns[0*nc+1]*target.y) / eqns[0*nc+0];

    if(isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x===Infinity || target.y===Infinity || target.z===Infinity){
        throw "Could not solve equation! Got x=["+target.toString()+"], b=["+b.toString()+"], A=["+this.toString()+"]";
    }

    return target;
};

/**
 * Get an element in the matrix by index. Index starts at 0, not 1!!!
 * @method e
 * @param {Number} row
 * @param {Number} column
 * @param {Number} value Optional. If provided, the matrix element will be set to this value.
 * @return {Number}
 */
Mat3.prototype.e = function( row , column ,value){
    if(value===undefined){
        return this.elements[column+3*row];
    } else {
        // Set value
        this.elements[column+3*row] = value;
    }
};

/**
 * Copy another matrix into this matrix object.
 * @method copy
 * @param {Mat3} source
 * @return {Mat3} this
 */
Mat3.prototype.copy = function(source){
    for(var i=0; i < source.elements.length; i++){
        this.elements[i] = source.elements[i];
    }
    return this;
};

/**
 * Returns a string representation of the matrix.
 * @method toString
 * @return string
 */
Mat3.prototype.toString = function(){
    var r = "";
    var sep = ",";
    for(var i=0; i<9; i++){
        r += this.elements[i] + sep;
    }
    return r;
};

/**
 * reverse the matrix
 * @method reverse
 * @param {Mat3} target Optional. Target matrix to save in.
 * @return {Mat3} The solution x
 */
Mat3.prototype.reverse = function(target){

    target = target || new Mat3();

    // Construct equations
    var nr = 3; // num rows
    var nc = 6; // num cols
    var eqns = [];
    for(var i=0; i<nr*nc; i++){
        eqns.push(0);
    }
    var i,j;
    for(i=0; i<3; i++){
        for(j=0; j<3; j++){
            eqns[i+nc*j] = this.elements[i+3*j];
        }
    }
    eqns[3+6*0] = 1;
    eqns[3+6*1] = 0;
    eqns[3+6*2] = 0;
    eqns[4+6*0] = 0;
    eqns[4+6*1] = 1;
    eqns[4+6*2] = 0;
    eqns[5+6*0] = 0;
    eqns[5+6*1] = 0;
    eqns[5+6*2] = 1;

    // Compute right upper triangular version of the matrix - Gauss elimination
    var n = 3, k = n, np;
    var kp = nc; // num rows
    var p;
    do {
        i = k - n;
        if (eqns[i+nc*i] === 0) {
            // the pivot is null, swap lines
            for (j = i + 1; j < k; j++) {
                if (eqns[i+nc*j] !== 0) {
                    np = kp;
                    do { // do line( i ) = line( i ) + line( k )
                        p = kp - np;
                        eqns[p+nc*i] += eqns[p+nc*j];
                    } while (--np);
                    break;
                }
            }
        }
        if (eqns[i+nc*i] !== 0) {
            for (j = i + 1; j < k; j++) {
                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
                np = kp;
                do { // do line( k ) = line( k ) - multiplier * line( i )
                    p = kp - np;
                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
                } while (--np);
            }
        }
    } while (--n);

    // eliminate the upper left triangle of the matrix
    i = 2;
    do {
        j = i-1;
        do {
            var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
            np = nc;
            do {
                p = nc - np;
                eqns[p+nc*j] =  eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
            } while (--np);
        } while (j--);
    } while (--i);

    // operations on the diagonal
    i = 2;
    do {
        var multiplier = 1 / eqns[i+nc*i];
        np = nc;
        do {
            p = nc - np;
            eqns[p+nc*i] = eqns[p+nc*i] * multiplier ;
        } while (--np);
    } while (i--);

    i = 2;
    do {
        j = 2;
        do {
            p = eqns[nr+j+nc*i];
            if( isNaN( p ) || p ===Infinity ){
                throw "Could not reverse! A=["+this.toString()+"]";
            }
            target.e( i , j , p );
        } while (j--);
    } while (i--);

    return target;
};

/**
 * Set the matrix from a quaterion
 * @method setRotationFromQuaternion
 * @param {Quaternion} q
 */
Mat3.prototype.setRotationFromQuaternion = function( q ) {
    var x = q.x, y = q.y, z = q.z, w = q.w,
        x2 = x + x, y2 = y + y, z2 = z + z,
        xx = x * x2, xy = x * y2, xz = x * z2,
        yy = y * y2, yz = y * z2, zz = z * z2,
        wx = w * x2, wy = w * y2, wz = w * z2,
        e = this.elements;

    e[3*0 + 0] = 1 - ( yy + zz );
    e[3*0 + 1] = xy - wz;
    e[3*0 + 2] = xz + wy;

    e[3*1 + 0] = xy + wz;
    e[3*1 + 1] = 1 - ( xx + zz );
    e[3*1 + 2] = yz - wx;

    e[3*2 + 0] = xz - wy;
    e[3*2 + 1] = yz + wx;
    e[3*2 + 2] = 1 - ( xx + yy );

    return this;
};

/**
 * Transpose the matrix
 * @method transpose
 * @param  {Mat3} target Where to store the result.
 * @return {Mat3} The target Mat3, or a new Mat3 if target was omitted.
 */
Mat3.prototype.transpose = function( target ) {
    target = target || new Mat3();

    var Mt = target.elements,
        M = this.elements;

    for(var i=0; i!==3; i++){
        for(var j=0; j!==3; j++){
            Mt[3*i + j] = M[3*j + i];
        }
    }

    return target;
};

},{"./Vec3":31}],29:[function(require,module,exports){
module.exports = Quaternion;

var Vec3 = require('./Vec3');

/**
 * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
 * @class Quaternion
 * @constructor
 * @param {Number} x Multiplier of the imaginary basis vector i.
 * @param {Number} y Multiplier of the imaginary basis vector j.
 * @param {Number} z Multiplier of the imaginary basis vector k.
 * @param {Number} w Multiplier of the real part.
 * @see http://en.wikipedia.org/wiki/Quaternion
 */
function Quaternion(x,y,z,w){
    /**
     * @property {Number} x
     */
    this.x = x!==undefined ? x : 0;

    /**
     * @property {Number} y
     */
    this.y = y!==undefined ? y : 0;

    /**
     * @property {Number} z
     */
    this.z = z!==undefined ? z : 0;

    /**
     * The multiplier of the real quaternion basis vector.
     * @property {Number} w
     */
    this.w = w!==undefined ? w : 1;
}

/**
 * Set the value of the quaternion.
 * @method set
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @param {Number} w
 */
Quaternion.prototype.set = function(x,y,z,w){
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
};

/**
 * Convert to a readable format
 * @method toString
 * @return string
 */
Quaternion.prototype.toString = function(){
    return this.x+","+this.y+","+this.z+","+this.w;
};

/**
 * Convert to an Array
 * @method toArray
 * @return Array
 */
Quaternion.prototype.toArray = function(){
    return [this.x, this.y, this.z, this.w];
};

/**
 * Set the quaternion components given an axis and an angle.
 * @method setFromAxisAngle
 * @param {Vec3} axis
 * @param {Number} angle in radians
 */
Quaternion.prototype.setFromAxisAngle = function(axis,angle){
    var s = Math.sin(angle*0.5);
    this.x = axis.x * s;
    this.y = axis.y * s;
    this.z = axis.z * s;
    this.w = Math.cos(angle*0.5);
    return this;
};

/**
 * Converts the quaternion to axis/angle representation.
 * @method toAxisAngle
 * @param {Vec3} [targetAxis] A vector object to reuse for storing the axis.
 * @return {Array} An array, first elemnt is the axis and the second is the angle in radians.
 */
Quaternion.prototype.toAxisAngle = function(targetAxis){
    targetAxis = targetAxis || new Vec3();
    this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
    var angle = 2 * Math.acos(this.w);
    var s = Math.sqrt(1-this.w*this.w); // assuming quaternion normalised then w is less than 1, so term always positive.
    if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
        // if s close to zero then direction of axis not important
        targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
        targetAxis.y = this.y;
        targetAxis.z = this.z;
    } else {
        targetAxis.x = this.x / s; // normalise axis
        targetAxis.y = this.y / s;
        targetAxis.z = this.z / s;
    }
    return [targetAxis,angle];
};

var sfv_t1 = new Vec3(),
    sfv_t2 = new Vec3();

/**
 * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
 * @method setFromVectors
 * @param {Vec3} u
 * @param {Vec3} v
 */
Quaternion.prototype.setFromVectors = function(u,v){
    if(u.isAntiparallelTo(v)){
        var t1 = sfv_t1;
        var t2 = sfv_t2;

        u.tangents(t1,t2);
        this.setFromAxisAngle(t1,Math.PI);
    } else {
        var a = u.cross(v);
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = Math.sqrt(Math.pow(u.norm(),2) * Math.pow(v.norm(),2)) + u.dot(v);
        this.normalize();
    }
    return this;
};

/**
 * Quaternion multiplication
 * @method mult
 * @param {Quaternion} q
 * @param {Quaternion} target Optional.
 * @return {Quaternion}
 */
var Quaternion_mult_va = new Vec3();
var Quaternion_mult_vb = new Vec3();
var Quaternion_mult_vaxvb = new Vec3();
Quaternion.prototype.mult = function(q,target){
    target = target || new Quaternion();

    var ax = this.x, ay = this.y, az = this.z, aw = this.w,
        bx = q.x, by = q.y, bz = q.z, bw = q.w;

    target.x = ax * bw + aw * bx + ay * bz - az * by;
    target.y = ay * bw + aw * by + az * bx - ax * bz;
    target.z = az * bw + aw * bz + ax * by - ay * bx;
    target.w = aw * bw - ax * bx - ay * by - az * bz;

    return target;
};

/**
 * Get the inverse quaternion rotation.
 * @method inverse
 * @param {Quaternion} target
 * @return {Quaternion}
 */
Quaternion.prototype.inverse = function(target){
    var x = this.x, y = this.y, z = this.z, w = this.w;
    target = target || new Quaternion();

    this.conjugate(target);
    var inorm2 = 1/(x*x + y*y + z*z + w*w);
    target.x *= inorm2;
    target.y *= inorm2;
    target.z *= inorm2;
    target.w *= inorm2;

    return target;
};

/**
 * Get the quaternion conjugate
 * @method conjugate
 * @param {Quaternion} target
 * @return {Quaternion}
 */
Quaternion.prototype.conjugate = function(target){
    target = target || new Quaternion();

    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    target.w = this.w;

    return target;
};

/**
 * Normalize the quaternion. Note that this changes the values of the quaternion.
 * @method normalize
 */
Quaternion.prototype.normalize = function(){
    var l = Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);
    if ( l === 0 ) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
    } else {
        l = 1 / l;
        this.x *= l;
        this.y *= l;
        this.z *= l;
        this.w *= l;
    }
    return this;
};

/**
 * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
 * @method normalizeFast
 * @see http://jsperf.com/fast-quaternion-normalization
 * @author unphased, https://github.com/unphased
 */
Quaternion.prototype.normalizeFast = function () {
    var f = (3.0-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2.0;
    if ( f === 0 ) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
    } else {
        this.x *= f;
        this.y *= f;
        this.z *= f;
        this.w *= f;
    }
    return this;
};

/**
 * Multiply the quaternion by a vector
 * @method vmult
 * @param {Vec3} v
 * @param {Vec3} target Optional
 * @return {Vec3}
 */
Quaternion.prototype.vmult = function(v,target){
    target = target || new Vec3();

    var x = v.x,
        y = v.y,
        z = v.z;

    var qx = this.x,
        qy = this.y,
        qz = this.z,
        qw = this.w;

    // q*v
    var ix =  qw * x + qy * z - qz * y,
    iy =  qw * y + qz * x - qx * z,
    iz =  qw * z + qx * y - qy * x,
    iw = -qx * x - qy * y - qz * z;

    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

    return target;
};

/**
 * Copies value of source to this quaternion.
 * @method copy
 * @param {Quaternion} source
 * @return {Quaternion} this
 */
Quaternion.prototype.copy = function(source){
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    this.w = source.w;
    return this;
};

/**
 * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
 * @method toEuler
 * @param {Vec3} target
 * @param string order Three-character string e.g. "YZX", which also is default.
 */
Quaternion.prototype.toEuler = function(target,order){
    order = order || "YZX";

    var heading, attitude, bank;
    var x = this.x, y = this.y, z = this.z, w = this.w;

    switch(order){
    case "YZX":
        var test = x*y + z*w;
        if (test > 0.499) { // singularity at north pole
            heading = 2 * Math.atan2(x,w);
            attitude = Math.PI/2;
            bank = 0;
        }
        if (test < -0.499) { // singularity at south pole
            heading = -2 * Math.atan2(x,w);
            attitude = - Math.PI/2;
            bank = 0;
        }
        if(isNaN(heading)){
            var sqx = x*x;
            var sqy = y*y;
            var sqz = z*z;
            heading = Math.atan2(2*y*w - 2*x*z , 1 - 2*sqy - 2*sqz); // Heading
            attitude = Math.asin(2*test); // attitude
            bank = Math.atan2(2*x*w - 2*y*z , 1 - 2*sqx - 2*sqz); // bank
        }
        break;
    default:
        throw new Error("Euler order "+order+" not supported yet.");
    }

    target.y = heading;
    target.z = attitude;
    target.x = bank;
};

/**
 * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
 * @method setFromEuler
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @param {String} order The order to apply angles: 'XYZ' or 'YXZ' or any other combination
 */
Quaternion.prototype.setFromEuler = function ( x, y, z, order ) {
    order = order || "XYZ";

    var c1 = Math.cos( x / 2 );
    var c2 = Math.cos( y / 2 );
    var c3 = Math.cos( z / 2 );
    var s1 = Math.sin( x / 2 );
    var s2 = Math.sin( y / 2 );
    var s3 = Math.sin( z / 2 );

    if ( order === 'XYZ' ) {

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'YXZ' ) {

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( order === 'ZXY' ) {

        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'ZYX' ) {

        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( order === 'YZX' ) {

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'XZY' ) {

        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;

    }

    return this;
};

/**
 * @method clone
 * @return {Quaternion}
 */
Quaternion.prototype.clone = function(){
    return new Quaternion(this.x, this.y, this.z, this.w);
};

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @method slerp
 * @param {Quaternion} toQuat second operand
 * @param {Number} t interpolation amount between the self quaternion and toQuat
 * @param {Quaternion} [target] A quaternion to store the result in. If not provided, a new one will be created.
 * @returns {Quaternion} The "target" object
 */
Quaternion.prototype.slerp = function (toQuat, t, target) {
    target = target || new Quaternion();

    var ax = this.x,
        ay = this.y,
        az = this.z,
        aw = this.w,
        bx = toQuat.x,
        by = toQuat.y,
        bz = toQuat.z,
        bw = toQuat.w;

    var omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;

    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }

    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }

    // calculate final values
    target.x = scale0 * ax + scale1 * bx;
    target.y = scale0 * ay + scale1 * by;
    target.z = scale0 * az + scale1 * bz;
    target.w = scale0 * aw + scale1 * bw;

    return target;
};

/**
 * Rotate an absolute orientation quaternion given an angular velocity and a time step.
 * @param  {Vec3} angularVelocity
 * @param  {number} dt
 * @param  {Vec3} angularFactor
 * @param  {Quaternion} target
 * @return {Quaternion} The "target" object
 */
Quaternion.prototype.integrate = function(angularVelocity, dt, angularFactor, target){
    target = target || new Quaternion();

    var ax = angularVelocity.x * angularFactor.x,
        ay = angularVelocity.y * angularFactor.y,
        az = angularVelocity.z * angularFactor.z,
        bx = this.x,
        by = this.y,
        bz = this.z,
        bw = this.w;

    var half_dt = dt * 0.5;

    target.x += half_dt * (ax * bw + ay * bz - az * by);
    target.y += half_dt * (ay * bw + az * bx - ax * bz);
    target.z += half_dt * (az * bw + ax * by - ay * bx);
    target.w += half_dt * (- ax * bx - ay * by - az * bz);

    return target;
};
},{"./Vec3":31}],30:[function(require,module,exports){
var Vec3 = require('./Vec3');
var Quaternion = require('./Quaternion');

module.exports = Transform;

/**
 * @class Transform
 * @constructor
 */
function Transform(options) {
    options = options || {};

	/**
	 * @property {Vec3} position
	 */
	this.position = new Vec3();
    if(options.position){
        this.position.copy(options.position);
    }

	/**
	 * @property {Quaternion} quaternion
	 */
	this.quaternion = new Quaternion();
    if(options.quaternion){
        this.quaternion.copy(options.quaternion);
    }
}

var tmpQuat = new Quaternion();

/**
 * @static
 * @method pointToLocaFrame
 * @param {Vec3} position
 * @param {Quaternion} quaternion
 * @param {Vec3} worldPoint
 * @param {Vec3} result
 */
Transform.pointToLocalFrame = function(position, quaternion, worldPoint, result){
    var result = result || new Vec3();
    worldPoint.vsub(position, result);
    quaternion.conjugate(tmpQuat);
    tmpQuat.vmult(result, result);
    return result;
};

/**
 * Get a global point in local transform coordinates.
 * @method pointToLocal
 * @param  {Vec3} point
 * @param  {Vec3} result
 * @return {Vec3} The "result" vector object
 */
Transform.prototype.pointToLocal = function(worldPoint, result){
    return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
};

/**
 * @static
 * @method pointToWorldFrame
 * @param {Vec3} position
 * @param {Vec3} quaternion
 * @param {Vec3} localPoint
 * @param {Vec3} result
 */
Transform.pointToWorldFrame = function(position, quaternion, localPoint, result){
    var result = result || new Vec3();
    quaternion.vmult(localPoint, result);
    result.vadd(position, result);
    return result;
};

/**
 * Get a local point in global transform coordinates.
 * @method pointToWorld
 * @param  {Vec3} point
 * @param  {Vec3} result
 * @return {Vec3} The "result" vector object
 */
Transform.prototype.pointToWorld = function(localPoint, result){
    return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
};


Transform.prototype.vectorToWorldFrame = function(localVector, result){
    var result = result || new Vec3();
    this.quaternion.vmult(localVector, result);
    return result;
};

Transform.vectorToWorldFrame = function(quaternion, localVector, result){
    quaternion.vmult(localVector, result);
    return result;
};

Transform.vectorToLocalFrame = function(position, quaternion, worldVector, result){
    var result = result || new Vec3();
    quaternion.w *= -1;
    quaternion.vmult(worldVector, result);
    quaternion.w *= -1;
    return result;
};

},{"./Quaternion":29,"./Vec3":31}],31:[function(require,module,exports){
module.exports = Vec3;

var Mat3 = require('./Mat3');

/**
 * 3-dimensional vector
 * @class Vec3
 * @constructor
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @author schteppe
 * @example
 *     var v = new Vec3(1, 2, 3);
 *     console.log('x=' + v.x); // x=1
 */
function Vec3(x,y,z){
    /**
     * @property x
     * @type {Number}
     */
    this.x = x||0.0;

    /**
     * @property y
     * @type {Number}
     */
    this.y = y||0.0;

    /**
     * @property z
     * @type {Number}
     */
    this.z = z||0.0;
}

/**
 * @static
 * @property {Vec3} ZERO
 */
Vec3.ZERO = new Vec3(0, 0, 0);

/**
 * @static
 * @property {Vec3} UNIT_X
 */
Vec3.UNIT_X = new Vec3(1, 0, 0);

/**
 * @static
 * @property {Vec3} UNIT_Y
 */
Vec3.UNIT_Y = new Vec3(0, 1, 0);

/**
 * @static
 * @property {Vec3} UNIT_Z
 */
Vec3.UNIT_Z = new Vec3(0, 0, 1);

/**
 * Vector cross product
 * @method cross
 * @param {Vec3} v
 * @param {Vec3} target Optional. Target to save in.
 * @return {Vec3}
 */
Vec3.prototype.cross = function(v,target){
    var vx=v.x, vy=v.y, vz=v.z, x=this.x, y=this.y, z=this.z;
    target = target || new Vec3();

    target.x = (y * vz) - (z * vy);
    target.y = (z * vx) - (x * vz);
    target.z = (x * vy) - (y * vx);

    return target;
};

/**
 * Set the vectors' 3 elements
 * @method set
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @return Vec3
 */
Vec3.prototype.set = function(x,y,z){
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
};

/**
 * Set all components of the vector to zero.
 * @method setZero
 */
Vec3.prototype.setZero = function(){
    this.x = this.y = this.z = 0;
};

/**
 * Vector addition
 * @method vadd
 * @param {Vec3} v
 * @param {Vec3} target Optional.
 * @return {Vec3}
 */
Vec3.prototype.vadd = function(v,target){
    if(target){
        target.x = v.x + this.x;
        target.y = v.y + this.y;
        target.z = v.z + this.z;
    } else {
        return new Vec3(this.x + v.x,
                               this.y + v.y,
                               this.z + v.z);
    }
};

/**
 * Vector subtraction
 * @method vsub
 * @param {Vec3} v
 * @param {Vec3} target Optional. Target to save in.
 * @return {Vec3}
 */
Vec3.prototype.vsub = function(v,target){
    if(target){
        target.x = this.x - v.x;
        target.y = this.y - v.y;
        target.z = this.z - v.z;
    } else {
        return new Vec3(this.x-v.x,
                               this.y-v.y,
                               this.z-v.z);
    }
};

/**
 * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
 * @method crossmat
 * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
 * @return {Mat3}
 */
Vec3.prototype.crossmat = function(){
    return new Mat3([     0,  -this.z,   this.y,
                            this.z,        0,  -this.x,
                           -this.y,   this.x,        0]);
};

/**
 * Normalize the vector. Note that this changes the values in the vector.
 * @method normalize
 * @return {Number} Returns the norm of the vector
 */
Vec3.prototype.normalize = function(){
    var x=this.x, y=this.y, z=this.z;
    var n = Math.sqrt(x*x + y*y + z*z);
    if(n>0.0){
        var invN = 1/n;
        this.x *= invN;
        this.y *= invN;
        this.z *= invN;
    } else {
        // Make something up
        this.x = 0;
        this.y = 0;
        this.z = 0;
    }
    return n;
};

/**
 * Get the version of this vector that is of length 1.
 * @method unit
 * @param {Vec3} target Optional target to save in
 * @return {Vec3} Returns the unit vector
 */
Vec3.prototype.unit = function(target){
    target = target || new Vec3();
    var x=this.x, y=this.y, z=this.z;
    var ninv = Math.sqrt(x*x + y*y + z*z);
    if(ninv>0.0){
        ninv = 1.0/ninv;
        target.x = x * ninv;
        target.y = y * ninv;
        target.z = z * ninv;
    } else {
        target.x = 1;
        target.y = 0;
        target.z = 0;
    }
    return target;
};

/**
 * Get the length of the vector
 * @method norm
 * @return {Number}
 * @deprecated Use .length() instead
 */
Vec3.prototype.norm = function(){
    var x=this.x, y=this.y, z=this.z;
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Get the length of the vector
 * @method length
 * @return {Number}
 */
Vec3.prototype.length = Vec3.prototype.norm;

/**
 * Get the squared length of the vector
 * @method norm2
 * @return {Number}
 * @deprecated Use .lengthSquared() instead.
 */
Vec3.prototype.norm2 = function(){
    return this.dot(this);
};

/**
 * Get the squared length of the vector.
 * @method lengthSquared
 * @return {Number}
 */
Vec3.prototype.lengthSquared = Vec3.prototype.norm2;

/**
 * Get distance from this point to another point
 * @method distanceTo
 * @param  {Vec3} p
 * @return {Number}
 */
Vec3.prototype.distanceTo = function(p){
    var x=this.x, y=this.y, z=this.z;
    var px=p.x, py=p.y, pz=p.z;
    return Math.sqrt((px-x)*(px-x)+
                     (py-y)*(py-y)+
                     (pz-z)*(pz-z));
};

/**
 * Get squared distance from this point to another point
 * @method distanceSquared
 * @param  {Vec3} p
 * @return {Number}
 */
Vec3.prototype.distanceSquared = function(p){
    var x=this.x, y=this.y, z=this.z;
    var px=p.x, py=p.y, pz=p.z;
    return (px-x)*(px-x) + (py-y)*(py-y) + (pz-z)*(pz-z);
};

/**
 * Multiply all the components of the vector with a scalar.
 * @deprecated Use .scale instead
 * @method mult
 * @param {Number} scalar
 * @param {Vec3} target The vector to save the result in.
 * @return {Vec3}
 * @deprecated Use .scale() instead
 */
Vec3.prototype.mult = function(scalar,target){
    target = target || new Vec3();
    var x = this.x,
        y = this.y,
        z = this.z;
    target.x = scalar * x;
    target.y = scalar * y;
    target.z = scalar * z;
    return target;
};

/**
 * Multiply the vector with an other vector, component-wise.
 * @method mult
 * @param {Number} vector
 * @param {Vec3} target The vector to save the result in.
 * @return {Vec3}
 */
Vec3.prototype.vmul = function(vector, target){
    target = target || new Vec3();
    target.x = vector.x * this.x;
    target.y = vector.y * this.y;
    target.z = vector.z * this.z;
    return target;
};

/**
 * Multiply the vector with a scalar.
 * @method scale
 * @param {Number} scalar
 * @param {Vec3} target
 * @return {Vec3}
 */
Vec3.prototype.scale = Vec3.prototype.mult;

/**
 * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
 * @method addScaledVector
 * @param {Number} scalar
 * @param {Vec3} vector
 * @param {Vec3} target The vector to save the result in.
 * @return {Vec3}
 */
Vec3.prototype.addScaledVector = function(scalar, vector, target){
    target = target || new Vec3();
    target.x = this.x + scalar * vector.x;
    target.y = this.y + scalar * vector.y;
    target.z = this.z + scalar * vector.z;
    return target;
};

/**
 * Calculate dot product
 * @method dot
 * @param {Vec3} v
 * @return {Number}
 */
Vec3.prototype.dot = function(v){
    return this.x * v.x + this.y * v.y + this.z * v.z;
};

/**
 * @method isZero
 * @return bool
 */
Vec3.prototype.isZero = function(){
    return this.x===0 && this.y===0 && this.z===0;
};

/**
 * Make the vector point in the opposite direction.
 * @method negate
 * @param {Vec3} target Optional target to save in
 * @return {Vec3}
 */
Vec3.prototype.negate = function(target){
    target = target || new Vec3();
    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    return target;
};

/**
 * Compute two artificial tangents to the vector
 * @method tangents
 * @param {Vec3} t1 Vector object to save the first tangent in
 * @param {Vec3} t2 Vector object to save the second tangent in
 */
var Vec3_tangents_n = new Vec3();
var Vec3_tangents_randVec = new Vec3();
Vec3.prototype.tangents = function(t1,t2){
    var norm = this.norm();
    if(norm>0.0){
        var n = Vec3_tangents_n;
        var inorm = 1/norm;
        n.set(this.x*inorm,this.y*inorm,this.z*inorm);
        var randVec = Vec3_tangents_randVec;
        if(Math.abs(n.x) < 0.9){
            randVec.set(1,0,0);
            n.cross(randVec,t1);
        } else {
            randVec.set(0,1,0);
            n.cross(randVec,t1);
        }
        n.cross(t1,t2);
    } else {
        // The normal length is zero, make something up
        t1.set(1, 0, 0);
        t2.set(0, 1, 0);
    }
};

/**
 * Converts to a more readable format
 * @method toString
 * @return string
 */
Vec3.prototype.toString = function(){
    return this.x+","+this.y+","+this.z;
};

/**
 * Converts to an array
 * @method toArray
 * @return Array
 */
Vec3.prototype.toArray = function(){
    return [this.x, this.y, this.z];
};

/**
 * Copies value of source to this vector.
 * @method copy
 * @param {Vec3} source
 * @return {Vec3} this
 */
Vec3.prototype.copy = function(source){
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    return this;
};


/**
 * Do a linear interpolation between two vectors
 * @method lerp
 * @param {Vec3} v
 * @param {Number} t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
 * @param {Vec3} target
 */
Vec3.prototype.lerp = function(v,t,target){
    var x=this.x, y=this.y, z=this.z;
    target.x = x + (v.x-x)*t;
    target.y = y + (v.y-y)*t;
    target.z = z + (v.z-z)*t;
};

/**
 * Check if a vector equals is almost equal to another one.
 * @method almostEquals
 * @param {Vec3} v
 * @param {Number} precision
 * @return bool
 */
Vec3.prototype.almostEquals = function(v,precision){
    if(precision===undefined){
        precision = 1e-6;
    }
    if( Math.abs(this.x-v.x)>precision ||
        Math.abs(this.y-v.y)>precision ||
        Math.abs(this.z-v.z)>precision){
        return false;
    }
    return true;
};

/**
 * Check if a vector is almost zero
 * @method almostZero
 * @param {Number} precision
 */
Vec3.prototype.almostZero = function(precision){
    if(precision===undefined){
        precision = 1e-6;
    }
    if( Math.abs(this.x)>precision ||
        Math.abs(this.y)>precision ||
        Math.abs(this.z)>precision){
        return false;
    }
    return true;
};

var antip_neg = new Vec3();

/**
 * Check if the vector is anti-parallel to another vector.
 * @method isAntiparallelTo
 * @param  {Vec3}  v
 * @param  {Number}  precision Set to zero for exact comparisons
 * @return {Boolean}
 */
Vec3.prototype.isAntiparallelTo = function(v,precision){
    this.negate(antip_neg);
    return antip_neg.almostEquals(v,precision);
};

/**
 * Clone the vector
 * @method clone
 * @return {Vec3}
 */
Vec3.prototype.clone = function(){
    return new Vec3(this.x, this.y, this.z);
};
},{"./Mat3":28}],32:[function(require,module,exports){
module.exports = Body;

var EventTarget = require('../utils/EventTarget');
var Shape = require('../shapes/Shape');
var Vec3 = require('../math/Vec3');
var Mat3 = require('../math/Mat3');
var Quaternion = require('../math/Quaternion');
var Material = require('../material/Material');
var AABB = require('../collision/AABB');
var Box = require('../shapes/Box');

/**
 * Base class for all body types.
 * @class Body
 * @constructor
 * @extends EventTarget
 * @param {object} [options]
 * @param {Vec3} [options.position]
 * @param {Vec3} [options.velocity]
 * @param {Vec3} [options.angularVelocity]
 * @param {Quaternion} [options.quaternion]
 * @param {number} [options.mass]
 * @param {Material} [options.material]
 * @param {number} [options.type]
 * @param {number} [options.linearDamping=0.01]
 * @param {number} [options.angularDamping=0.01]
 * @param {boolean} [options.allowSleep=true]
 * @param {number} [options.sleepSpeedLimit=0.1]
 * @param {number} [options.sleepTimeLimit=1]
 * @param {number} [options.collisionFilterGroup=1]
 * @param {number} [options.collisionFilterMask=-1]
 * @param {boolean} [options.fixedRotation=false]
 * @param {Vec3} [options.linearFactor]
 * @param {Vec3} [options.angularFactor]
 * @param {Shape} [options.shape]
 * @example
 *     var body = new Body({
 *         mass: 1
 *     });
 *     var shape = new Sphere(1);
 *     body.addShape(shape);
 *     world.addBody(body);
 */
function Body(options){
    options = options || {};

    EventTarget.apply(this);

    this.id = Body.idCounter++;

    /**
     * Reference to the world the body is living in
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this Body object.
     * @property preStep
     * @type {Function}
     * @deprecated Use World events instead
     */
    this.preStep = null;

    /**
     * Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this Body object.
     * @property postStep
     * @type {Function}
     * @deprecated Use World events instead
     */
    this.postStep = null;

    this.vlambda = new Vec3();

    /**
     * @property {Number} collisionFilterGroup
     */
    this.collisionFilterGroup = typeof(options.collisionFilterGroup) === 'number' ? options.collisionFilterGroup : 1;

    /**
     * @property {Number} collisionFilterMask
     */
    this.collisionFilterMask = typeof(options.collisionFilterMask) === 'number' ? options.collisionFilterMask : -1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
     * @property {Number} collisionResponse
     */
	this.collisionResponse = true;

    /**
     * World space position of the body.
     * @property position
     * @type {Vec3}
     */
    this.position = new Vec3();

    /**
     * @property {Vec3} previousPosition
     */
    this.previousPosition = new Vec3();

    /**
     * Interpolated position of the body.
     * @property {Vec3} interpolatedPosition
     */
    this.interpolatedPosition = new Vec3();

    /**
     * Initial position of the body
     * @property initPosition
     * @type {Vec3}
     */
    this.initPosition = new Vec3();

    if(options.position){
        this.position.copy(options.position);
        this.previousPosition.copy(options.position);
        this.interpolatedPosition.copy(options.position);
        this.initPosition.copy(options.position);
    }

    /**
     * World space velocity of the body.
     * @property velocity
     * @type {Vec3}
     */
    this.velocity = new Vec3();

    if(options.velocity){
        this.velocity.copy(options.velocity);
    }

    /**
     * @property initVelocity
     * @type {Vec3}
     */
    this.initVelocity = new Vec3();

    /**
     * Linear force on the body in world space.
     * @property force
     * @type {Vec3}
     */
    this.force = new Vec3();

    var mass = typeof(options.mass) === 'number' ? options.mass : 0;

    /**
     * @property mass
     * @type {Number}
     * @default 0
     */
    this.mass = mass;

    /**
     * @property invMass
     * @type {Number}
     */
    this.invMass = mass > 0 ? 1.0 / mass : 0;

    /**
     * @property material
     * @type {Material}
     */
    this.material = options.material || null;

    /**
     * @property linearDamping
     * @type {Number}
     */
    this.linearDamping = typeof(options.linearDamping) === 'number' ? options.linearDamping : 0.01;

    /**
     * One of: Body.DYNAMIC, Body.STATIC and Body.KINEMATIC.
     * @property type
     * @type {Number}
     */
    this.type = (mass <= 0.0 ? Body.STATIC : Body.DYNAMIC);
    if(typeof(options.type) === typeof(Body.STATIC)){
        this.type = options.type;
    }

    /**
     * If true, the body will automatically fall to sleep.
     * @property allowSleep
     * @type {Boolean}
     * @default true
     */
    this.allowSleep = typeof(options.allowSleep) !== 'undefined' ? options.allowSleep : true;

    /**
     * Current sleep state.
     * @property sleepState
     * @type {Number}
     */
    this.sleepState = 0;

    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @property sleepSpeedLimit
     * @type {Number}
     * @default 0.1
     */
    this.sleepSpeedLimit = typeof(options.sleepSpeedLimit) !== 'undefined' ? options.sleepSpeedLimit : 0.1;

    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @property sleepTimeLimit
     * @type {Number}
     * @default 1
     */
    this.sleepTimeLimit = typeof(options.sleepTimeLimit) !== 'undefined' ? options.sleepTimeLimit : 1;

    this.timeLastSleepy = 0;

    this._wakeUpAfterNarrowphase = false;

    /**
     * World space rotational force on the body, around center of mass.
     * @property {Vec3} torque
     */
    this.torque = new Vec3();

    /**
     * World space orientation of the body.
     * @property quaternion
     * @type {Quaternion}
     */
    this.quaternion = new Quaternion();

    /**
     * @property initQuaternion
     * @type {Quaternion}
     */
    this.initQuaternion = new Quaternion();

    /**
     * @property {Quaternion} previousQuaternion
     */
    this.previousQuaternion = new Quaternion();

    /**
     * Interpolated orientation of the body.
     * @property {Quaternion} interpolatedQuaternion
     */
    this.interpolatedQuaternion = new Quaternion();

    if(options.quaternion){
        this.quaternion.copy(options.quaternion);
        this.initQuaternion.copy(options.quaternion);
        this.previousQuaternion.copy(options.quaternion);
        this.interpolatedQuaternion.copy(options.quaternion);
    }

    /**
     * Angular velocity of the body, in world space. Think of the angular velocity as a vector, which the body rotates around. The length of this vector determines how fast (in radians per second) the body rotates.
     * @property angularVelocity
     * @type {Vec3}
     */
    this.angularVelocity = new Vec3();

    if(options.angularVelocity){
        this.angularVelocity.copy(options.angularVelocity);
    }

    /**
     * @property initAngularVelocity
     * @type {Vec3}
     */
    this.initAngularVelocity = new Vec3();

    /**
     * @property shapes
     * @type {array}
     */
    this.shapes = [];

    /**
     * Position of each Shape in the body, given in local Body space.
     * @property shapeOffsets
     * @type {array}
     */
    this.shapeOffsets = [];

    /**
     * Orientation of each Shape, given in local Body space.
     * @property shapeOrientations
     * @type {array}
     */
    this.shapeOrientations = [];

    /**
     * @property inertia
     * @type {Vec3}
     */
    this.inertia = new Vec3();

    /**
     * @property {Vec3} invInertia
     */
    this.invInertia = new Vec3();

    /**
     * @property {Mat3} invInertiaWorld
     */
    this.invInertiaWorld = new Mat3();

    this.invMassSolve = 0;

    /**
     * @property {Vec3} invInertiaSolve
     */
    this.invInertiaSolve = new Vec3();

    /**
     * @property {Mat3} invInertiaWorldSolve
     */
    this.invInertiaWorldSolve = new Mat3();

    /**
     * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() after changing this.
     * @property {Boolean} fixedRotation
     * @default false
     */
    this.fixedRotation = typeof(options.fixedRotation) !== "undefined" ? options.fixedRotation : false;

    /**
     * @property {Number} angularDamping
     */
    this.angularDamping = typeof(options.angularDamping) !== 'undefined' ? options.angularDamping : 0.01;

    /**
     * Use this property to limit the motion along any world axis. (1,1,1) will allow motion along all axes while (0,0,0) allows none.
     * @property {Vec3} linearFactor
     */
    this.linearFactor = new Vec3(1,1,1);
    if(options.linearFactor){
        this.linearFactor.copy(options.linearFactor);
    }

    /**
     * Use this property to limit the rotational motion along any world axis. (1,1,1) will allow rotation along all axes while (0,0,0) allows none.
     * @property {Vec3} angularFactor
     */
    this.angularFactor = new Vec3(1,1,1);
    if(options.angularFactor){
        this.angularFactor.copy(options.angularFactor);
    }

    /**
     * World space bounding box of the body and its shapes.
     * @property aabb
     * @type {AABB}
     */
    this.aabb = new AABB();

    /**
     * Indicates if the AABB needs to be updated before use.
     * @property aabbNeedsUpdate
     * @type {Boolean}
     */
    this.aabbNeedsUpdate = true;

    /**
     * Total bounding radius of the Body including its shapes, relative to body.position.
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    this.wlambda = new Vec3();

    if(options.shape){
        this.addShape(options.shape);
    }

    this.updateMassProperties();
}
Body.prototype = new EventTarget();
Body.prototype.constructor = Body;

/**
 * Dispatched after two bodies collide. This event is dispatched on each
 * of the two bodies involved in the collision.
 * @event collide
 * @param {Body} body The body that was involved in the collision.
 * @param {ContactEquation} contact The details of the collision.
 */
Body.COLLIDE_EVENT_NAME = "collide";

/**
 * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
 * @static
 * @property DYNAMIC
 * @type {Number}
 */
Body.DYNAMIC = 1;

/**
 * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
 * @static
 * @property STATIC
 * @type {Number}
 */
Body.STATIC = 2;

/**
 * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
 * @static
 * @property KINEMATIC
 * @type {Number}
 */
Body.KINEMATIC = 4;



/**
 * @static
 * @property AWAKE
 * @type {number}
 */
Body.AWAKE = 0;

/**
 * @static
 * @property SLEEPY
 * @type {number}
 */
Body.SLEEPY = 1;

/**
 * @static
 * @property SLEEPING
 * @type {number}
 */
Body.SLEEPING = 2;

Body.idCounter = 0;

/**
 * Dispatched after a sleeping body has woken up.
 * @event wakeup
 */
Body.wakeupEvent = {
    type: "wakeup"
};

/**
 * Wake the body up.
 * @method wakeUp
 */
Body.prototype.wakeUp = function(){
    var s = this.sleepState;
    this.sleepState = 0;
    this._wakeUpAfterNarrowphase = false;
    if(s === Body.SLEEPING){
        this.dispatchEvent(Body.wakeupEvent);
    }
};

/**
 * Force body sleep
 * @method sleep
 */
Body.prototype.sleep = function(){
    this.sleepState = Body.SLEEPING;
    this.velocity.set(0,0,0);
    this.angularVelocity.set(0,0,0);
    this._wakeUpAfterNarrowphase = false;
};

/**
 * Dispatched after a body has gone in to the sleepy state.
 * @event sleepy
 */
Body.sleepyEvent = {
    type: "sleepy"
};

/**
 * Dispatched after a body has fallen asleep.
 * @event sleep
 */
Body.sleepEvent = {
    type: "sleep"
};

/**
 * Called every timestep to update internal sleep timer and change sleep state if needed.
 * @method sleepTick
 * @param {Number} time The world time in seconds
 */
Body.prototype.sleepTick = function(time){
    if(this.allowSleep){
        var sleepState = this.sleepState;
        var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();
        var speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);
        if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){
            this.sleepState = Body.SLEEPY; // Sleepy
            this.timeLastSleepy = time;
            this.dispatchEvent(Body.sleepyEvent);
        } else if(sleepState===Body.SLEEPY && speedSquared > speedLimitSquared){
            this.wakeUp(); // Wake up
        } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){
            this.sleep(); // Sleeping
            this.dispatchEvent(Body.sleepEvent);
        }
    }
};

/**
 * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
 * @method updateSolveMassProperties
 */
Body.prototype.updateSolveMassProperties = function(){
    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
        this.invMassSolve = 0;
        this.invInertiaSolve.setZero();
        this.invInertiaWorldSolve.setZero();
    } else {
        this.invMassSolve = this.invMass;
        this.invInertiaSolve.copy(this.invInertia);
        this.invInertiaWorldSolve.copy(this.invInertiaWorld);
    }
};

/**
 * Convert a world point to local body frame.
 * @method pointToLocalFrame
 * @param  {Vec3} worldPoint
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.pointToLocalFrame = function(worldPoint,result){
    var result = result || new Vec3();
    worldPoint.vsub(this.position,result);
    this.quaternion.conjugate().vmult(result,result);
    return result;
};

/**
 * Convert a world vector to local body frame.
 * @method vectorToLocalFrame
 * @param  {Vec3} worldPoint
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.vectorToLocalFrame = function(worldVector, result){
    var result = result || new Vec3();
    this.quaternion.conjugate().vmult(worldVector,result);
    return result;
};

/**
 * Convert a local body point to world frame.
 * @method pointToWorldFrame
 * @param  {Vec3} localPoint
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.pointToWorldFrame = function(localPoint,result){
    var result = result || new Vec3();
    this.quaternion.vmult(localPoint,result);
    result.vadd(this.position,result);
    return result;
};

/**
 * Convert a local body point to world frame.
 * @method vectorToWorldFrame
 * @param  {Vec3} localVector
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.vectorToWorldFrame = function(localVector, result){
    var result = result || new Vec3();
    this.quaternion.vmult(localVector, result);
    return result;
};

var tmpVec = new Vec3();
var tmpQuat = new Quaternion();

/**
 * Add a shape to the body with a local offset and orientation.
 * @method addShape
 * @param {Shape} shape
 * @param {Vec3} [_offset]
 * @param {Quaternion} [_orientation]
 * @return {Body} The body object, for chainability.
 */
Body.prototype.addShape = function(shape, _offset, _orientation){
    var offset = new Vec3();
    var orientation = new Quaternion();

    if(_offset){
        offset.copy(_offset);
    }
    if(_orientation){
        orientation.copy(_orientation);
    }

    this.shapes.push(shape);
    this.shapeOffsets.push(offset);
    this.shapeOrientations.push(orientation);
    this.updateMassProperties();
    this.updateBoundingRadius();

    this.aabbNeedsUpdate = true;

    shape.body = this;

    return this;
};

/**
 * Update the bounding radius of the body. Should be done if any of the shapes are changed.
 * @method updateBoundingRadius
 */
Body.prototype.updateBoundingRadius = function(){
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        N = shapes.length,
        radius = 0;

    for(var i=0; i!==N; i++){
        var shape = shapes[i];
        shape.updateBoundingSphereRadius();
        var offset = shapeOffsets[i].norm(),
            r = shape.boundingSphereRadius;
        if(offset + r > radius){
            radius = offset + r;
        }
    }

    this.boundingRadius = radius;
};

var computeAABB_shapeAABB = new AABB();

/**
 * Updates the .aabb
 * @method computeAABB
 * @todo rename to updateAABB()
 */
Body.prototype.computeAABB = function(){
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        shapeOrientations = this.shapeOrientations,
        N = shapes.length,
        offset = tmpVec,
        orientation = tmpQuat,
        bodyQuat = this.quaternion,
        aabb = this.aabb,
        shapeAABB = computeAABB_shapeAABB;

    for(var i=0; i!==N; i++){
        var shape = shapes[i];

        // Get shape world position
        bodyQuat.vmult(shapeOffsets[i], offset);
        offset.vadd(this.position, offset);

        // Get shape world quaternion
        shapeOrientations[i].mult(bodyQuat, orientation);

        // Get shape AABB
        shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);

        if(i === 0){
            aabb.copy(shapeAABB);
        } else {
            aabb.extend(shapeAABB);
        }
    }

    this.aabbNeedsUpdate = false;
};

var uiw_m1 = new Mat3(),
    uiw_m2 = new Mat3(),
    uiw_m3 = new Mat3();

/**
 * Update .inertiaWorld and .invInertiaWorld
 * @method updateInertiaWorld
 */
Body.prototype.updateInertiaWorld = function(force){
    var I = this.invInertia;
    if (I.x === I.y && I.y === I.z && !force) {
        // If inertia M = s*I, where I is identity and s a scalar, then
        //    R*M*R' = R*(s*I)*R' = s*R*I*R' = s*R*R' = s*I = M
        // where R is the rotation matrix.
        // In other words, we don't have to transform the inertia if all
        // inertia diagonal entries are equal.
    } else {
        var m1 = uiw_m1,
            m2 = uiw_m2,
            m3 = uiw_m3;
        m1.setRotationFromQuaternion(this.quaternion);
        m1.transpose(m2);
        m1.scale(I,m1);
        m1.mmult(m2,this.invInertiaWorld);
    }
};

/**
 * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.torque.
 * @method applyForce
 * @param  {Vec3} force The amount of force to add.
 * @param  {Vec3} relativePoint A point relative to the center of mass to apply the force on.
 */
var Body_applyForce_r = new Vec3();
var Body_applyForce_rotForce = new Vec3();
Body.prototype.applyForce = function(force,relativePoint){
    if(this.type !== Body.DYNAMIC){ // Needed?
        return;
    }

    // Compute produced rotational force
    var rotForce = Body_applyForce_rotForce;
    relativePoint.cross(force,rotForce);

    // Add linear force
    this.force.vadd(force,this.force);

    // Add rotational force
    this.torque.vadd(rotForce,this.torque);
};

/**
 * Apply force to a local point in the body.
 * @method applyLocalForce
 * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
 * @param  {Vec3} localPoint A local point in the body to apply the force on.
 */
var Body_applyLocalForce_worldForce = new Vec3();
var Body_applyLocalForce_relativePointWorld = new Vec3();
Body.prototype.applyLocalForce = function(localForce, localPoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    var worldForce = Body_applyLocalForce_worldForce;
    var relativePointWorld = Body_applyLocalForce_relativePointWorld;

    // Transform the force vector to world space
    this.vectorToWorldFrame(localForce, worldForce);
    this.vectorToWorldFrame(localPoint, relativePointWorld);

    this.applyForce(worldForce, relativePointWorld);
};

/**
 * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
 * @method applyImpulse
 * @param  {Vec3} impulse The amount of impulse to add.
 * @param  {Vec3} relativePoint A point relative to the center of mass to apply the force on.
 */
var Body_applyImpulse_r = new Vec3();
var Body_applyImpulse_velo = new Vec3();
var Body_applyImpulse_rotVelo = new Vec3();
Body.prototype.applyImpulse = function(impulse, relativePoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    // Compute point position relative to the body center
    var r = relativePoint;

    // Compute produced central impulse velocity
    var velo = Body_applyImpulse_velo;
    velo.copy(impulse);
    velo.mult(this.invMass,velo);

    // Add linear impulse
    this.velocity.vadd(velo, this.velocity);

    // Compute produced rotational impulse velocity
    var rotVelo = Body_applyImpulse_rotVelo;
    r.cross(impulse,rotVelo);

    /*
    rotVelo.x *= this.invInertia.x;
    rotVelo.y *= this.invInertia.y;
    rotVelo.z *= this.invInertia.z;
    */
    this.invInertiaWorld.vmult(rotVelo,rotVelo);

    // Add rotational Impulse
    this.angularVelocity.vadd(rotVelo, this.angularVelocity);
};

/**
 * Apply locally-defined impulse to a local point in the body.
 * @method applyLocalImpulse
 * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
 * @param  {Vec3} localPoint A local point in the body to apply the force on.
 */
var Body_applyLocalImpulse_worldImpulse = new Vec3();
var Body_applyLocalImpulse_relativePoint = new Vec3();
Body.prototype.applyLocalImpulse = function(localImpulse, localPoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    var worldImpulse = Body_applyLocalImpulse_worldImpulse;
    var relativePointWorld = Body_applyLocalImpulse_relativePoint;

    // Transform the force vector to world space
    this.vectorToWorldFrame(localImpulse, worldImpulse);
    this.vectorToWorldFrame(localPoint, relativePointWorld);

    this.applyImpulse(worldImpulse, relativePointWorld);
};

var Body_updateMassProperties_halfExtents = new Vec3();

/**
 * Should be called whenever you change the body shape or mass.
 * @method updateMassProperties
 */
Body.prototype.updateMassProperties = function(){
    var halfExtents = Body_updateMassProperties_halfExtents;

    this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
    var I = this.inertia;
    var fixed = this.fixedRotation;

    // Approximate with AABB box
    this.computeAABB();
    halfExtents.set(
        (this.aabb.upperBound.x-this.aabb.lowerBound.x) / 2,
        (this.aabb.upperBound.y-this.aabb.lowerBound.y) / 2,
        (this.aabb.upperBound.z-this.aabb.lowerBound.z) / 2
    );
    Box.calculateInertia(halfExtents, this.mass, I);

    this.invInertia.set(
        I.x > 0 && !fixed ? 1.0 / I.x : 0,
        I.y > 0 && !fixed ? 1.0 / I.y : 0,
        I.z > 0 && !fixed ? 1.0 / I.z : 0
    );
    this.updateInertiaWorld(true);
};

/**
 * Get world velocity of a point in the body.
 * @method getVelocityAtWorldPoint
 * @param  {Vec3} worldPoint
 * @param  {Vec3} result
 * @return {Vec3} The result vector.
 */
Body.prototype.getVelocityAtWorldPoint = function(worldPoint, result){
    var r = new Vec3();
    worldPoint.vsub(this.position, r);
    this.angularVelocity.cross(r, result);
    this.velocity.vadd(result, result);
    return result;
};

var torque = new Vec3();
var invI_tau_dt = new Vec3();
var w = new Quaternion();
var wq = new Quaternion();

/**
 * Move the body forward in time.
 * @param {number} dt Time step
 * @param {boolean} quatNormalize Set to true to normalize the body quaternion
 * @param {boolean} quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
 */
Body.prototype.integrate = function(dt, quatNormalize, quatNormalizeFast){

    // Save previous position
    this.previousPosition.copy(this.position);
    this.previousQuaternion.copy(this.quaternion);

    if(!(this.type === Body.DYNAMIC || this.type === Body.KINEMATIC) || this.sleepState === Body.SLEEPING){ // Only for dynamic
        return;
    }

    var velo = this.velocity,
        angularVelo = this.angularVelocity,
        pos = this.position,
        force = this.force,
        torque = this.torque,
        quat = this.quaternion,
        invMass = this.invMass,
        invInertia = this.invInertiaWorld,
        linearFactor = this.linearFactor;

    var iMdt = invMass * dt;
    velo.x += force.x * iMdt * linearFactor.x;
    velo.y += force.y * iMdt * linearFactor.y;
    velo.z += force.z * iMdt * linearFactor.z;

    var e = invInertia.elements;
    var angularFactor = this.angularFactor;
    var tx = torque.x * angularFactor.x;
    var ty = torque.y * angularFactor.y;
    var tz = torque.z * angularFactor.z;
    angularVelo.x += dt * (e[0] * tx + e[1] * ty + e[2] * tz);
    angularVelo.y += dt * (e[3] * tx + e[4] * ty + e[5] * tz);
    angularVelo.z += dt * (e[6] * tx + e[7] * ty + e[8] * tz);

    // Use new velocity  - leap frog
    pos.x += velo.x * dt;
    pos.y += velo.y * dt;
    pos.z += velo.z * dt;

    quat.integrate(this.angularVelocity, dt, this.angularFactor, quat);

    if(quatNormalize){
        if(quatNormalizeFast){
            quat.normalizeFast();
        } else {
            quat.normalize();
        }
    }

    this.aabbNeedsUpdate = true;

    // Update world inertia
    this.updateInertiaWorld();
};

},{"../collision/AABB":3,"../material/Material":26,"../math/Mat3":28,"../math/Quaternion":29,"../math/Vec3":31,"../shapes/Box":38,"../shapes/Shape":44,"../utils/EventTarget":50}],33:[function(require,module,exports){
var Body = require('./Body');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var RaycastResult = require('../collision/RaycastResult');
var Ray = require('../collision/Ray');
var WheelInfo = require('../objects/WheelInfo');

module.exports = RaycastVehicle;

/**
 * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
 * @class RaycastVehicle
 * @constructor
 * @param {object} [options]
 * @param {Body} [options.chassisBody] The car chassis body.
 * @param {integer} [options.indexRightAxis] Axis to use for right. x=0, y=1, z=2
 * @param {integer} [options.indexLeftAxis]
 * @param {integer} [options.indexUpAxis]
 */
function RaycastVehicle(options){

    /**
     * @property {Body} chassisBody
     */
    this.chassisBody = options.chassisBody;

    /**
     * An array of WheelInfo objects.
     * @property {array} wheelInfos
     */
    this.wheelInfos = [];

    /**
     * Will be set to true if the car is sliding.
     * @property {boolean} sliding
     */
    this.sliding = false;

    /**
     * @property {World} world
     */
    this.world = null;

    /**
     * Index of the right axis, 0=x, 1=y, 2=z
     * @property {integer} indexRightAxis
     * @default 1
     */
    this.indexRightAxis = typeof(options.indexRightAxis) !== 'undefined' ? options.indexRightAxis : 1;

    /**
     * Index of the forward axis, 0=x, 1=y, 2=z
     * @property {integer} indexForwardAxis
     * @default 0
     */
    this.indexForwardAxis = typeof(options.indexForwardAxis) !== 'undefined' ? options.indexForwardAxis : 0;

    /**
     * Index of the up axis, 0=x, 1=y, 2=z
     * @property {integer} indexUpAxis
     * @default 2
     */
    this.indexUpAxis = typeof(options.indexUpAxis) !== 'undefined' ? options.indexUpAxis : 2;
}

var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();
var tmpVec3 = new Vec3();
var tmpVec4 = new Vec3();
var tmpVec5 = new Vec3();
var tmpVec6 = new Vec3();
var tmpRay = new Ray();

/**
 * Add a wheel. For information about the options, see WheelInfo.
 * @method addWheel
 * @param {object} [options]
 */
RaycastVehicle.prototype.addWheel = function(options){
    options = options || {};

    var info = new WheelInfo(options);
    var index = this.wheelInfos.length;
    this.wheelInfos.push(info);

    return index;
};

/**
 * Set the steering value of a wheel.
 * @method setSteeringValue
 * @param {number} value
 * @param {integer} wheelIndex
 */
RaycastVehicle.prototype.setSteeringValue = function(value, wheelIndex){
    var wheel = this.wheelInfos[wheelIndex];
    wheel.steering = value;
};

var torque = new Vec3();

/**
 * Set the wheel force to apply on one of the wheels each time step
 * @method applyEngineForce
 * @param  {number} value
 * @param  {integer} wheelIndex
 */
RaycastVehicle.prototype.applyEngineForce = function(value, wheelIndex){
    this.wheelInfos[wheelIndex].engineForce = value;
};

/**
 * Set the braking force of a wheel
 * @method setBrake
 * @param {number} brake
 * @param {integer} wheelIndex
 */
RaycastVehicle.prototype.setBrake = function(brake, wheelIndex){
    this.wheelInfos[wheelIndex].brake = brake;
};

/**
 * Add the vehicle including its constraints to the world.
 * @method addToWorld
 * @param {World} world
 */
RaycastVehicle.prototype.addToWorld = function(world){
    var constraints = this.constraints;
    world.addBody(this.chassisBody);
    var that = this;
    this.preStepCallback = function(){
        that.updateVehicle(world.dt);
    };
    world.addEventListener('preStep', this.preStepCallback);
    this.world = world;
};

/**
 * Get one of the wheel axles, world-oriented.
 * @private
 * @method getVehicleAxisWorld
 * @param  {integer} axisIndex
 * @param  {Vec3} result
 */
RaycastVehicle.prototype.getVehicleAxisWorld = function(axisIndex, result){
    result.set(
        axisIndex === 0 ? 1 : 0,
        axisIndex === 1 ? 1 : 0,
        axisIndex === 2 ? 1 : 0
    );
    this.chassisBody.vectorToWorldFrame(result, result);
};

RaycastVehicle.prototype.updateVehicle = function(timeStep){
    var wheelInfos = this.wheelInfos;
    var numWheels = wheelInfos.length;
    var chassisBody = this.chassisBody;

    for (var i = 0; i < numWheels; i++) {
        this.updateWheelTransform(i);
    }

    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();

    var forwardWorld = new Vec3();
    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

    if (forwardWorld.dot(chassisBody.velocity) < 0){
        this.currentVehicleSpeedKmHour *= -1;
    }

    // simulate suspension
    for (var i = 0; i < numWheels; i++) {
        this.castRay(wheelInfos[i]);
    }

    this.updateSuspension(timeStep);

    var impulse = new Vec3();
    var relpos = new Vec3();
    for (var i = 0; i < numWheels; i++) {
        //apply suspension force
        var wheel = wheelInfos[i];
        var suspensionForce = wheel.suspensionForce;
        if (suspensionForce > wheel.maxSuspensionForce) {
            suspensionForce = wheel.maxSuspensionForce;
        }
        wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);

        wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
        chassisBody.applyImpulse(impulse, relpos);
    }

    this.updateFriction(timeStep);

    var hitNormalWorldScaledWithProj = new Vec3();
    var fwd  = new Vec3();
    var vel = new Vec3();
    for (i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];
        //var relpos = new Vec3();
        //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);
        chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);

        // Hack to get the rotation in the correct direction
        var m = 1;
        switch(this.indexUpAxis){
        case 1:
            m = -1;
            break;
        }

        if (wheel.isInContact) {

            this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
            var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
            wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);

            fwd.vsub(hitNormalWorldScaledWithProj, fwd);

            var proj2 = fwd.dot(vel);
            wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
        }

        if((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed){
            // Apply custom rotation when accelerating and sliding
            wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
        }

        // Lock wheels
        if(Math.abs(wheel.brake) > Math.abs(wheel.engineForce)){
            wheel.deltaRotation = 0;
        }

        wheel.rotation += wheel.deltaRotation; // Use the old value
        wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
    }
};

RaycastVehicle.prototype.updateSuspension = function(deltaTime) {
    var chassisBody = this.chassisBody;
    var chassisMass = chassisBody.mass;
    var wheelInfos = this.wheelInfos;
    var numWheels = wheelInfos.length;

    for (var w_it = 0; w_it < numWheels; w_it++){
        var wheel = wheelInfos[w_it];

        if (wheel.isInContact){
            var force;

            // Spring
            var susp_length = wheel.suspensionRestLength;
            var current_length = wheel.suspensionLength;
            var length_diff = (susp_length - current_length);

            force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;

            // Damper
            var projected_rel_vel = wheel.suspensionRelativeVelocity;
            var susp_damping;
            if (projected_rel_vel < 0) {
                susp_damping = wheel.dampingCompression;
            } else {
                susp_damping = wheel.dampingRelaxation;
            }
            force -= susp_damping * projected_rel_vel;

            wheel.suspensionForce = force * chassisMass;
            if (wheel.suspensionForce < 0) {
                wheel.suspensionForce = 0;
            }
        } else {
            wheel.suspensionForce = 0;
        }
    }
};

/**
 * Remove the vehicle including its constraints from the world.
 * @method removeFromWorld
 * @param {World} world
 */
RaycastVehicle.prototype.removeFromWorld = function(world){
    var constraints = this.constraints;
    world.remove(this.chassisBody);
    world.removeEventListener('preStep', this.preStepCallback);
    this.world = null;
};

var castRay_rayvector = new Vec3();
var castRay_target = new Vec3();
RaycastVehicle.prototype.castRay = function(wheel) {
    var rayvector = castRay_rayvector;
    var target = castRay_target;

    this.updateWheelTransformWorld(wheel);
    var chassisBody = this.chassisBody;

    var depth = -1;

    var raylen = wheel.suspensionRestLength + wheel.radius;

    wheel.directionWorld.scale(raylen, rayvector);
    var source = wheel.chassisConnectionPointWorld;
    source.vadd(rayvector, target);
    var raycastResult = wheel.raycastResult;

    var param = 0;

    raycastResult.reset();
    // Turn off ray collision with the chassis temporarily
    var oldState = chassisBody.collisionResponse;
    chassisBody.collisionResponse = false;

    // Cast ray against world
    this.world.rayTest(source, target, raycastResult);
    chassisBody.collisionResponse = oldState;

    var object = raycastResult.body;

    wheel.raycastResult.groundObject = 0;

    if (object) {
        depth = raycastResult.distance;
        wheel.raycastResult.hitNormalWorld  = raycastResult.hitNormalWorld;
        wheel.isInContact = true;

        var hitDistance = raycastResult.distance;
        wheel.suspensionLength = hitDistance - wheel.radius;

        // clamp on max suspension travel
        var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
        var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;
        if (wheel.suspensionLength < minSuspensionLength) {
            wheel.suspensionLength = minSuspensionLength;
        }
        if (wheel.suspensionLength > maxSuspensionLength) {
            wheel.suspensionLength = maxSuspensionLength;
            wheel.raycastResult.reset();
        }

        var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);

        var chassis_velocity_at_contactPoint = new Vec3();
        chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);

        var projVel = wheel.raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );

        if (denominator >= -0.1) {
            wheel.suspensionRelativeVelocity = 0;
            wheel.clippedInvContactDotSuspension = 1 / 0.1;
        } else {
            var inv = -1 / denominator;
            wheel.suspensionRelativeVelocity = projVel * inv;
            wheel.clippedInvContactDotSuspension = inv;
        }

    } else {

        //put wheel info as in rest position
        wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
        wheel.suspensionRelativeVelocity = 0.0;
        wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
        wheel.clippedInvContactDotSuspension = 1.0;
    }

    return depth;
};

RaycastVehicle.prototype.updateWheelTransformWorld = function(wheel){
    wheel.isInContact = false;
    var chassisBody = this.chassisBody;
    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
    chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
};


/**
 * Update one of the wheel transform.
 * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
 * @method updateWheelTransform
 * @param {integer} wheelIndex The wheel index to update.
 */
RaycastVehicle.prototype.updateWheelTransform = function(wheelIndex){
    var up = tmpVec4;
    var right = tmpVec5;
    var fwd = tmpVec6;

    var wheel = this.wheelInfos[wheelIndex];
    this.updateWheelTransformWorld(wheel);

    wheel.directionLocal.scale(-1, up);
    right.copy(wheel.axleLocal);
    up.cross(right, fwd);
    fwd.normalize();
    right.normalize();

    // Rotate around steering over the wheelAxle
    var steering = wheel.steering;
    var steeringOrn = new Quaternion();
    steeringOrn.setFromAxisAngle(up, steering);

    var rotatingOrn = new Quaternion();
    rotatingOrn.setFromAxisAngle(right, wheel.rotation);

    // World rotation of the wheel
    var q = wheel.worldTransform.quaternion;
    this.chassisBody.quaternion.mult(steeringOrn, q);
    q.mult(rotatingOrn, q);

    q.normalize();

    // world position of the wheel
    var p = wheel.worldTransform.position;
    p.copy(wheel.directionWorld);
    p.scale(wheel.suspensionLength, p);
    p.vadd(wheel.chassisConnectionPointWorld, p);
};

var directions = [
    new Vec3(1, 0, 0),
    new Vec3(0, 1, 0),
    new Vec3(0, 0, 1)
];

/**
 * Get the world transform of one of the wheels
 * @method getWheelTransformWorld
 * @param  {integer} wheelIndex
 * @return {Transform}
 */
RaycastVehicle.prototype.getWheelTransformWorld = function(wheelIndex) {
    return this.wheelInfos[wheelIndex].worldTransform;
};


var updateFriction_surfNormalWS_scaled_proj = new Vec3();
var updateFriction_axle = [];
var updateFriction_forwardWS = [];
var sideFrictionStiffness2 = 1;
RaycastVehicle.prototype.updateFriction = function(timeStep) {
    var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;

    //calculate the impulse, so that the wheels don't move sidewards
    var wheelInfos = this.wheelInfos;
    var numWheels = wheelInfos.length;
    var chassisBody = this.chassisBody;
    var forwardWS = updateFriction_forwardWS;
    var axle = updateFriction_axle;

    var numWheelsOnGround = 0;

    for (var i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];

        var groundObject = wheel.raycastResult.body;
        if (groundObject){
            numWheelsOnGround++;
        }

        wheel.sideImpulse = 0;
        wheel.forwardImpulse = 0;
        if(!forwardWS[i]){
            forwardWS[i] = new Vec3();
        }
        if(!axle[i]){
            axle[i] = new Vec3();
        }
    }

    for (var i = 0; i < numWheels; i++){
        var wheel = wheelInfos[i];

        var groundObject = wheel.raycastResult.body;

        if (groundObject) {
            var axlei = axle[i];
            var wheelTrans = this.getWheelTransformWorld(i);

            // Get world axle
            wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);

            var surfNormalWS = wheel.raycastResult.hitNormalWorld;
            var proj = axlei.dot(surfNormalWS);
            surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
            axlei.vsub(surfNormalWS_scaled_proj, axlei);
            axlei.normalize();

            surfNormalWS.cross(axlei, forwardWS[i]);
            forwardWS[i].normalize();

            wheel.sideImpulse = resolveSingleBilateral(
                chassisBody,
                wheel.raycastResult.hitPointWorld,
                groundObject,
                wheel.raycastResult.hitPointWorld,
                axlei
            );

            wheel.sideImpulse *= sideFrictionStiffness2;
        }
    }

    var sideFactor = 1;
    var fwdFactor = 0.5;

    this.sliding = false;
    for (var i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];
        var groundObject = wheel.raycastResult.body;

        var rollingFriction = 0;

        wheel.slipInfo = 1;
        if (groundObject) {
            var defaultRollingFrictionImpulse = 0;
            var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;

            // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
            // rollingFriction = calcRollingFriction(contactPt);
            rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);

            rollingFriction += wheel.engineForce * timeStep;

            // rollingFriction = 0;
            var factor = maxImpulse / rollingFriction;
            wheel.slipInfo *= factor;
        }

        //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)

        wheel.forwardImpulse = 0;
        wheel.skidInfo = 1;

        if (groundObject) {
            wheel.skidInfo = 1;

            var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
            var maximpSide = maximp;

            var maximpSquared = maximp * maximpSide;

            wheel.forwardImpulse = rollingFriction;//wheelInfo.engineForce* timeStep;

            var x = wheel.forwardImpulse * fwdFactor;
            var y = wheel.sideImpulse * sideFactor;

            var impulseSquared = x * x + y * y;

            wheel.sliding = false;
            if (impulseSquared > maximpSquared) {
                this.sliding = true;
                wheel.sliding = true;

                var factor = maximp / Math.sqrt(impulseSquared);

                wheel.skidInfo *= factor;
            }
        }
    }

    if (this.sliding) {
        for (var i = 0; i < numWheels; i++) {
            var wheel = wheelInfos[i];
            if (wheel.sideImpulse !== 0) {
                if (wheel.skidInfo < 1){
                    wheel.forwardImpulse *= wheel.skidInfo;
                    wheel.sideImpulse *= wheel.skidInfo;
                }
            }
        }
    }

    // apply the impulses
    for (var i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];

        var rel_pos = new Vec3();
        wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos);
        // cannons applyimpulse is using world coord for the position
        //rel_pos.copy(wheel.raycastResult.hitPointWorld);

        if (wheel.forwardImpulse !== 0) {
            var impulse = new Vec3();
            forwardWS[i].scale(wheel.forwardImpulse, impulse);
            chassisBody.applyImpulse(impulse, rel_pos);
        }

        if (wheel.sideImpulse !== 0){
            var groundObject = wheel.raycastResult.body;

            var rel_pos2 = new Vec3();
            wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2);
            //rel_pos2.copy(wheel.raycastResult.hitPointWorld);
            var sideImp = new Vec3();
            axle[i].scale(wheel.sideImpulse, sideImp);

            // Scale the relative position in the up direction with rollInfluence.
            // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).
            chassisBody.vectorToLocalFrame(rel_pos, rel_pos);
            rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
            chassisBody.vectorToWorldFrame(rel_pos, rel_pos);
            chassisBody.applyImpulse(sideImp, rel_pos);

            //apply friction impulse on the ground
            sideImp.scale(-1, sideImp);
            groundObject.applyImpulse(sideImp, rel_pos2);
        }
    }
};

var calcRollingFriction_vel1 = new Vec3();
var calcRollingFriction_vel2 = new Vec3();
var calcRollingFriction_vel = new Vec3();

function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
    var j1 = 0;
    var contactPosWorld = frictionPosWorld;

    // var rel_pos1 = new Vec3();
    // var rel_pos2 = new Vec3();
    var vel1 = calcRollingFriction_vel1;
    var vel2 = calcRollingFriction_vel2;
    var vel = calcRollingFriction_vel;
    // contactPosWorld.vsub(body0.position, rel_pos1);
    // contactPosWorld.vsub(body1.position, rel_pos2);

    body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
    body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
    vel1.vsub(vel2, vel);

    var vrel = frictionDirectionWorld.dot(vel);

    var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
    var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
    var relaxation = 1;
    var jacDiagABInv = relaxation / (denom0 + denom1);

    // calculate j that moves us to zero relative velocity
    j1 = -vrel * jacDiagABInv;

    if (maxImpulse < j1) {
        j1 = maxImpulse;
    }
    if (j1 < -maxImpulse) {
        j1 = -maxImpulse;
    }

    return j1;
}

var computeImpulseDenominator_r0 = new Vec3();
var computeImpulseDenominator_c0 = new Vec3();
var computeImpulseDenominator_vec = new Vec3();
var computeImpulseDenominator_m = new Vec3();
function computeImpulseDenominator(body, pos, normal) {
    var r0 = computeImpulseDenominator_r0;
    var c0 = computeImpulseDenominator_c0;
    var vec = computeImpulseDenominator_vec;
    var m = computeImpulseDenominator_m;

    pos.vsub(body.position, r0);
    r0.cross(normal, c0);
    body.invInertiaWorld.vmult(c0, m);
    m.cross(r0, vec);

    return body.invMass + normal.dot(vec);
}


var resolveSingleBilateral_vel1 = new Vec3();
var resolveSingleBilateral_vel2 = new Vec3();
var resolveSingleBilateral_vel = new Vec3();

//bilateral constraint between two dynamic objects
function resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse){
    var normalLenSqr = normal.norm2();
    if (normalLenSqr > 1.1){
        return 0; // no impulse
    }
    // var rel_pos1 = new Vec3();
    // var rel_pos2 = new Vec3();
    // pos1.vsub(body1.position, rel_pos1);
    // pos2.vsub(body2.position, rel_pos2);

    var vel1 = resolveSingleBilateral_vel1;
    var vel2 = resolveSingleBilateral_vel2;
    var vel = resolveSingleBilateral_vel;
    body1.getVelocityAtWorldPoint(pos1, vel1);
    body2.getVelocityAtWorldPoint(pos2, vel2);

    vel1.vsub(vel2, vel);

    var rel_vel = normal.dot(vel);

    var contactDamping = 0.2;
    var massTerm = 1 / (body1.invMass + body2.invMass);
    var impulse = - contactDamping * rel_vel * massTerm;

    return impulse;
}
},{"../collision/Ray":10,"../collision/RaycastResult":11,"../math/Quaternion":29,"../math/Vec3":31,"../objects/WheelInfo":37,"./Body":32}],34:[function(require,module,exports){
var Body = require('./Body');
var Sphere = require('../shapes/Sphere');
var Box = require('../shapes/Box');
var Vec3 = require('../math/Vec3');
var HingeConstraint = require('../constraints/HingeConstraint');

module.exports = RigidVehicle;

/**
 * Simple vehicle helper class with spherical rigid body wheels.
 * @class RigidVehicle
 * @constructor
 * @param {Body} [options.chassisBody]
 */
function RigidVehicle(options){
    this.wheelBodies = [];

    /**
     * @property coordinateSystem
     * @type {Vec3}
     */
    this.coordinateSystem = typeof(options.coordinateSystem)==='undefined' ? new Vec3(1, 2, 3) : options.coordinateSystem.clone();

    /**
     * @property {Body} chassisBody
     */
    this.chassisBody = options.chassisBody;

    if(!this.chassisBody){
        // No chassis body given. Create it!
        var chassisShape = new Box(new Vec3(5, 2, 0.5));
        this.chassisBody = new Body(1, chassisShape);
    }

    /**
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    this.wheelAxes = [];
    this.wheelForces = [];
}

/**
 * Add a wheel
 * @method addWheel
 * @param {object} options
 * @param {boolean} [options.isFrontWheel]
 * @param {Vec3} [options.position] Position of the wheel, locally in the chassis body.
 * @param {Vec3} [options.direction] Slide direction of the wheel along the suspension.
 * @param {Vec3} [options.axis] Axis of rotation of the wheel, locally defined in the chassis.
 * @param {Body} [options.body] The wheel body.
 */
RigidVehicle.prototype.addWheel = function(options){
    options = options || {};
    var wheelBody = options.body;
    if(!wheelBody){
        wheelBody =  new Body(1, new Sphere(1.2));
    }
    this.wheelBodies.push(wheelBody);
    this.wheelForces.push(0);

    // Position constrain wheels
    var zero = new Vec3();
    var position = typeof(options.position) !== 'undefined' ? options.position.clone() : new Vec3();

    // Set position locally to the chassis
    var worldPosition = new Vec3();
    this.chassisBody.pointToWorldFrame(position, worldPosition);
    wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z);

    // Constrain wheel
    var axis = typeof(options.axis) !== 'undefined' ? options.axis.clone() : new Vec3(0, 1, 0);
    this.wheelAxes.push(axis);

    var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
        pivotA: position,
        axisA: axis,
        pivotB: Vec3.ZERO,
        axisB: axis,
        collideConnected: false
    });
    this.constraints.push(hingeConstraint);

    return this.wheelBodies.length - 1;
};

/**
 * Set the steering value of a wheel.
 * @method setSteeringValue
 * @param {number} value
 * @param {integer} wheelIndex
 * @todo check coordinateSystem
 */
RigidVehicle.prototype.setSteeringValue = function(value, wheelIndex){
    // Set angle of the hinge axis
    var axis = this.wheelAxes[wheelIndex];

    var c = Math.cos(value),
        s = Math.sin(value),
        x = axis.x,
        y = axis.y;
    this.constraints[wheelIndex].axisA.set(
        c*x -s*y,
        s*x +c*y,
        0
    );
};

/**
 * Set the target rotational speed of the hinge constraint.
 * @method setMotorSpeed
 * @param {number} value
 * @param {integer} wheelIndex
 */
RigidVehicle.prototype.setMotorSpeed = function(value, wheelIndex){
    var hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.enableMotor();
    hingeConstraint.motorTargetVelocity = value;
};

/**
 * Set the target rotational speed of the hinge constraint.
 * @method disableMotor
 * @param {number} value
 * @param {integer} wheelIndex
 */
RigidVehicle.prototype.disableMotor = function(wheelIndex){
    var hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.disableMotor();
};

var torque = new Vec3();

/**
 * Set the wheel force to apply on one of the wheels each time step
 * @method setWheelForce
 * @param  {number} value
 * @param  {integer} wheelIndex
 */
RigidVehicle.prototype.setWheelForce = function(value, wheelIndex){
    this.wheelForces[wheelIndex] = value;
};

/**
 * Apply a torque on one of the wheels.
 * @method applyWheelForce
 * @param  {number} value
 * @param  {integer} wheelIndex
 */
RigidVehicle.prototype.applyWheelForce = function(value, wheelIndex){
    var axis = this.wheelAxes[wheelIndex];
    var wheelBody = this.wheelBodies[wheelIndex];
    var bodyTorque = wheelBody.torque;

    axis.scale(value, torque);
    wheelBody.vectorToWorldFrame(torque, torque);
    bodyTorque.vadd(torque, bodyTorque);
};

/**
 * Add the vehicle including its constraints to the world.
 * @method addToWorld
 * @param {World} world
 */
RigidVehicle.prototype.addToWorld = function(world){
    var constraints = this.constraints;
    var bodies = this.wheelBodies.concat([this.chassisBody]);

    for (var i = 0; i < bodies.length; i++) {
        world.addBody(bodies[i]);
    }

    for (var i = 0; i < constraints.length; i++) {
        world.addConstraint(constraints[i]);
    }

    world.addEventListener('preStep', this._update.bind(this));
};

RigidVehicle.prototype._update = function(){
    var wheelForces = this.wheelForces;
    for (var i = 0; i < wheelForces.length; i++) {
        this.applyWheelForce(wheelForces[i], i);
    }
};

/**
 * Remove the vehicle including its constraints from the world.
 * @method removeFromWorld
 * @param {World} world
 */
RigidVehicle.prototype.removeFromWorld = function(world){
    var constraints = this.constraints;
    var bodies = this.wheelBodies.concat([this.chassisBody]);

    for (var i = 0; i < bodies.length; i++) {
        world.remove(bodies[i]);
    }

    for (var i = 0; i < constraints.length; i++) {
        world.removeConstraint(constraints[i]);
    }
};

var worldAxis = new Vec3();

/**
 * Get current rotational velocity of a wheel
 * @method getWheelSpeed
 * @param {integer} wheelIndex
 */
RigidVehicle.prototype.getWheelSpeed = function(wheelIndex){
    var axis = this.wheelAxes[wheelIndex];
    var wheelBody = this.wheelBodies[wheelIndex];
    var w = wheelBody.angularVelocity;
    this.chassisBody.vectorToWorldFrame(axis, worldAxis);
    return w.dot(worldAxis);
};

},{"../constraints/HingeConstraint":16,"../math/Vec3":31,"../shapes/Box":38,"../shapes/Sphere":45,"./Body":32}],35:[function(require,module,exports){
module.exports = SPHSystem;

var Shape = require('../shapes/Shape');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Particle = require('../shapes/Particle');
var Body = require('../objects/Body');
var Material = require('../material/Material');

/**
 * Smoothed-particle hydrodynamics system
 * @class SPHSystem
 * @constructor
 */
function SPHSystem(){
    this.particles = [];
	
    /**
     * Density of the system (kg/m3).
     * @property {number} density
     */
    this.density = 1;
	
    /**
     * Distance below which two particles are considered to be neighbors.
     * It should be adjusted so there are about 15-20 neighbor particles within this radius.
     * @property {number} smoothingRadius
     */
    this.smoothingRadius = 1;
    this.speedOfSound = 1;
	
    /**
     * Viscosity of the system.
     * @property {number} viscosity
     */
    this.viscosity = 0.01;
    this.eps = 0.000001;

    // Stuff Computed per particle
    this.pressures = [];
    this.densities = [];
    this.neighbors = [];
}

/**
 * Add a particle to the system.
 * @method add
 * @param {Body} particle
 */
SPHSystem.prototype.add = function(particle){
    this.particles.push(particle);
    if(this.neighbors.length < this.particles.length){
        this.neighbors.push([]);
    }
};

/**
 * Remove a particle from the system.
 * @method remove
 * @param {Body} particle
 */
SPHSystem.prototype.remove = function(particle){
    var idx = this.particles.indexOf(particle);
    if(idx !== -1){
        this.particles.splice(idx,1);
        if(this.neighbors.length > this.particles.length){
            this.neighbors.pop();
        }
    }
};

/**
 * Get neighbors within smoothing volume, save in the array neighbors
 * @method getNeighbors
 * @param {Body} particle
 * @param {Array} neighbors
 */
var SPHSystem_getNeighbors_dist = new Vec3();
SPHSystem.prototype.getNeighbors = function(particle,neighbors){
    var N = this.particles.length,
        id = particle.id,
        R2 = this.smoothingRadius * this.smoothingRadius,
        dist = SPHSystem_getNeighbors_dist;
    for(var i=0; i!==N; i++){
        var p = this.particles[i];
        p.position.vsub(particle.position,dist);
        if(id!==p.id && dist.norm2() < R2){
            neighbors.push(p);
        }
    }
};

// Temp vectors for calculation
var SPHSystem_update_dist = new Vec3(),
    SPHSystem_update_a_pressure = new Vec3(),
    SPHSystem_update_a_visc = new Vec3(),
    SPHSystem_update_gradW = new Vec3(),
    SPHSystem_update_r_vec = new Vec3(),
    SPHSystem_update_u = new Vec3(); // Relative velocity
SPHSystem.prototype.update = function(){
    var N = this.particles.length,
        dist = SPHSystem_update_dist,
        cs = this.speedOfSound,
        eps = this.eps;

    for(var i=0; i!==N; i++){
        var p = this.particles[i]; // Current particle
        var neighbors = this.neighbors[i];

        // Get neighbors
        neighbors.length = 0;
        this.getNeighbors(p,neighbors);
        neighbors.push(this.particles[i]); // Add current too
        var numNeighbors = neighbors.length;

        // Accumulate density for the particle
        var sum = 0.0;
        for(var j=0; j!==numNeighbors; j++){

            //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
            p.position.vsub(neighbors[j].position, dist);
            var len = dist.norm();

            var weight = this.w(len);
            sum += neighbors[j].mass * weight;
        }

        // Save
        this.densities[i] = sum;
        this.pressures[i] = cs * cs * (this.densities[i] - this.density);
    }

    // Add forces

    // Sum to these accelerations
    var a_pressure= SPHSystem_update_a_pressure;
    var a_visc =    SPHSystem_update_a_visc;
    var gradW =     SPHSystem_update_gradW;
    var r_vec =     SPHSystem_update_r_vec;
    var u =         SPHSystem_update_u;

    for(var i=0; i!==N; i++){

        var particle = this.particles[i];

        a_pressure.set(0,0,0);
        a_visc.set(0,0,0);

        // Init vars
        var Pij;
        var nabla;
        var Vij;

        // Sum up for all other neighbors
        var neighbors = this.neighbors[i];
        var numNeighbors = neighbors.length;

        //printf("Neighbors: ");
        for(var j=0; j!==numNeighbors; j++){

            var neighbor = neighbors[j];
            //printf("%d ",nj);

            // Get r once for all..
            particle.position.vsub(neighbor.position,r_vec);
            var r = r_vec.norm();

            // Pressure contribution
            Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i]*this.densities[i] + eps) + this.pressures[j] / (this.densities[j]*this.densities[j] + eps));
            this.gradw(r_vec, gradW);
            // Add to pressure acceleration
            gradW.mult(Pij , gradW);
            a_pressure.vadd(gradW, a_pressure);

            // Viscosity contribution
            neighbor.velocity.vsub(particle.velocity, u);
            u.mult( 1.0 / (0.0001+this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass , u );
            nabla = this.nablaw(r);
            u.mult(nabla,u);
            // Add to viscosity acceleration
            a_visc.vadd( u, a_visc );
        }

        // Calculate force
        a_visc.mult(particle.mass, a_visc);
        a_pressure.mult(particle.mass, a_pressure);

        // Add force to particles
        particle.force.vadd(a_visc, particle.force);
        particle.force.vadd(a_pressure, particle.force);
    }
};

// Calculate the weight using the W(r) weightfunction
SPHSystem.prototype.w = function(r){
    // 315
    var h = this.smoothingRadius;
    return 315.0/(64.0*Math.PI*Math.pow(h,9)) * Math.pow(h*h-r*r,3);
};

// calculate gradient of the weight function
SPHSystem.prototype.gradw = function(rVec,resultVec){
    var r = rVec.norm(),
        h = this.smoothingRadius;
    rVec.mult(945.0/(32.0*Math.PI*Math.pow(h,9)) * Math.pow((h*h-r*r),2) , resultVec);
};

// Calculate nabla(W)
SPHSystem.prototype.nablaw = function(r){
    var h = this.smoothingRadius;
    var nabla = 945.0/(32.0*Math.PI*Math.pow(h,9)) * (h*h-r*r)*(7*r*r - 3*h*h);
    return nabla;
};

},{"../material/Material":26,"../math/Quaternion":29,"../math/Vec3":31,"../objects/Body":32,"../shapes/Particle":42,"../shapes/Shape":44}],36:[function(require,module,exports){
var Vec3 = require('../math/Vec3');

module.exports = Spring;

/**
 * A spring, connecting two bodies.
 *
 * @class Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restLength]   A number > 0. Default: 1
 * @param {number} [options.stiffness]    A number >= 0. Default: 100
 * @param {number} [options.damping]      A number >= 0. Default: 1
 * @param {Vec3}  [options.worldAnchorA] Where to hook the spring to body A, in world coordinates.
 * @param {Vec3}  [options.worldAnchorB]
 * @param {Vec3}  [options.localAnchorA] Where to hook the spring to body A, in local body coordinates.
 * @param {Vec3}  [options.localAnchorB]
 */
function Spring(bodyA,bodyB,options){
    options = options || {};

    /**
     * Rest length of the spring.
     * @property restLength
     * @type {number}
     */
    this.restLength = typeof(options.restLength) === "number" ? options.restLength : 1;

    /**
     * Stiffness of the spring.
     * @property stiffness
     * @type {number}
     */
    this.stiffness = options.stiffness || 100;

    /**
     * Damping of the spring.
     * @property damping
     * @type {number}
     */
    this.damping = options.damping || 1;

    /**
     * First connected body.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second connected body.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * Anchor for bodyA in local bodyA coordinates.
     * @property localAnchorA
     * @type {Vec3}
     */
    this.localAnchorA = new Vec3();

    /**
     * Anchor for bodyB in local bodyB coordinates.
     * @property localAnchorB
     * @type {Vec3}
     */
    this.localAnchorB = new Vec3();

    if(options.localAnchorA){
        this.localAnchorA.copy(options.localAnchorA);
    }
    if(options.localAnchorB){
        this.localAnchorB.copy(options.localAnchorB);
    }
    if(options.worldAnchorA){
        this.setWorldAnchorA(options.worldAnchorA);
    }
    if(options.worldAnchorB){
        this.setWorldAnchorB(options.worldAnchorB);
    }
}

/**
 * Set the anchor point on body A, using world coordinates.
 * @method setWorldAnchorA
 * @param {Vec3} worldAnchorA
 */
Spring.prototype.setWorldAnchorA = function(worldAnchorA){
    this.bodyA.pointToLocalFrame(worldAnchorA,this.localAnchorA);
};

/**
 * Set the anchor point on body B, using world coordinates.
 * @method setWorldAnchorB
 * @param {Vec3} worldAnchorB
 */
Spring.prototype.setWorldAnchorB = function(worldAnchorB){
    this.bodyB.pointToLocalFrame(worldAnchorB,this.localAnchorB);
};

/**
 * Get the anchor point on body A, in world coordinates.
 * @method getWorldAnchorA
 * @param {Vec3} result The vector to store the result in.
 */
Spring.prototype.getWorldAnchorA = function(result){
    this.bodyA.pointToWorldFrame(this.localAnchorA,result);
};

/**
 * Get the anchor point on body B, in world coordinates.
 * @method getWorldAnchorB
 * @param {Vec3} result The vector to store the result in.
 */
Spring.prototype.getWorldAnchorB = function(result){
    this.bodyB.pointToWorldFrame(this.localAnchorB,result);
};

var applyForce_r =              new Vec3(),
    applyForce_r_unit =         new Vec3(),
    applyForce_u =              new Vec3(),
    applyForce_f =              new Vec3(),
    applyForce_worldAnchorA =   new Vec3(),
    applyForce_worldAnchorB =   new Vec3(),
    applyForce_ri =             new Vec3(),
    applyForce_rj =             new Vec3(),
    applyForce_ri_x_f =         new Vec3(),
    applyForce_rj_x_f =         new Vec3(),
    applyForce_tmp =            new Vec3();

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
Spring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restLength,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        r = applyForce_r,
        r_unit = applyForce_r_unit,
        u = applyForce_u,
        f = applyForce_f,
        tmp = applyForce_tmp;

    var worldAnchorA = applyForce_worldAnchorA,
        worldAnchorB = applyForce_worldAnchorB,
        ri = applyForce_ri,
        rj = applyForce_rj,
        ri_x_f = applyForce_ri_x_f,
        rj_x_f = applyForce_rj_x_f;

    // Get world anchors
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);

    // Get offset points
    worldAnchorA.vsub(bodyA.position,ri);
    worldAnchorB.vsub(bodyB.position,rj);

    // Compute distance vector between world anchor points
    worldAnchorB.vsub(worldAnchorA,r);
    var rlen = r.norm();
    r_unit.copy(r);
    r_unit.normalize();

    // Compute relative velocity of the anchor points, u
    bodyB.velocity.vsub(bodyA.velocity,u);
    // Add rotational velocity

    bodyB.angularVelocity.cross(rj,tmp);
    u.vadd(tmp,u);
    bodyA.angularVelocity.cross(ri,tmp);
    u.vsub(tmp,u);

    // F = - k * ( x - L ) - D * ( u )
    r_unit.mult(-k*(rlen-l) - d*u.dot(r_unit), f);

    // Add forces to bodies
    bodyA.force.vsub(f,bodyA.force);
    bodyB.force.vadd(f,bodyB.force);

    // Angular force
    ri.cross(f,ri_x_f);
    rj.cross(f,rj_x_f);
    bodyA.torque.vsub(ri_x_f,bodyA.torque);
    bodyB.torque.vadd(rj_x_f,bodyB.torque);
};

},{"../math/Vec3":31}],37:[function(require,module,exports){
var Vec3 = require('../math/Vec3');
var Transform = require('../math/Transform');
var RaycastResult = require('../collision/RaycastResult');
var Utils = require('../utils/Utils');

module.exports = WheelInfo;

/**
 * @class WheelInfo
 * @constructor
 * @param {Object} [options]
 *
 * @param {Vec3} [options.chassisConnectionPointLocal]
 * @param {Vec3} [options.chassisConnectionPointWorld]
 * @param {Vec3} [options.directionLocal]
 * @param {Vec3} [options.directionWorld]
 * @param {Vec3} [options.axleLocal]
 * @param {Vec3} [options.axleWorld]
 * @param {number} [options.suspensionRestLength=1]
 * @param {number} [options.suspensionMaxLength=2]
 * @param {number} [options.radius=1]
 * @param {number} [options.suspensionStiffness=100]
 * @param {number} [options.dampingCompression=10]
 * @param {number} [options.dampingRelaxation=10]
 * @param {number} [options.frictionSlip=10000]
 * @param {number} [options.steering=0]
 * @param {number} [options.rotation=0]
 * @param {number} [options.deltaRotation=0]
 * @param {number} [options.rollInfluence=0.01]
 * @param {number} [options.maxSuspensionForce]
 * @param {boolean} [options.isFrontWheel=true]
 * @param {number} [options.clippedInvContactDotSuspension=1]
 * @param {number} [options.suspensionRelativeVelocity=0]
 * @param {number} [options.suspensionForce=0]
 * @param {number} [options.skidInfo=0]
 * @param {number} [options.suspensionLength=0]
 * @param {number} [options.maxSuspensionTravel=1]
 * @param {boolean} [options.useCustomSlidingRotationalSpeed=false]
 * @param {number} [options.customSlidingRotationalSpeed=-0.1]
 */
function WheelInfo(options){
    options = Utils.defaults(options, {
        chassisConnectionPointLocal: new Vec3(),
        chassisConnectionPointWorld: new Vec3(),
        directionLocal: new Vec3(),
        directionWorld: new Vec3(),
        axleLocal: new Vec3(),
        axleWorld: new Vec3(),
        suspensionRestLength: 1,
        suspensionMaxLength: 2,
        radius: 1,
        suspensionStiffness: 100,
        dampingCompression: 10,
        dampingRelaxation: 10,
        frictionSlip: 10000,
        steering: 0,
        rotation: 0,
        deltaRotation: 0,
        rollInfluence: 0.01,
        maxSuspensionForce: Number.MAX_VALUE,
        isFrontWheel: true,
        clippedInvContactDotSuspension: 1,
        suspensionRelativeVelocity: 0,
        suspensionForce: 0,
        skidInfo: 0,
        suspensionLength: 0,
        maxSuspensionTravel: 1,
        useCustomSlidingRotationalSpeed: false,
        customSlidingRotationalSpeed: -0.1
    });

    /**
     * Max travel distance of the suspension, in meters.
     * @property {number} maxSuspensionTravel
     */
    this.maxSuspensionTravel = options.maxSuspensionTravel;

    /**
     * Speed to apply to the wheel rotation when the wheel is sliding.
     * @property {number} customSlidingRotationalSpeed
     */
    this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;

    /**
     * If the customSlidingRotationalSpeed should be used.
     * @property {Boolean} useCustomSlidingRotationalSpeed
     */
    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;

    /**
     * @property {Boolean} sliding
     */
    this.sliding = false;

    /**
     * Connection point, defined locally in the chassis body frame.
     * @property {Vec3} chassisConnectionPointLocal
     */
    this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();

    /**
     * @property {Vec3} chassisConnectionPointWorld
     */
    this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();

    /**
     * @property {Vec3} directionLocal
     */
    this.directionLocal = options.directionLocal.clone();

    /**
     * @property {Vec3} directionWorld
     */
    this.directionWorld = options.directionWorld.clone();

    /**
     * @property {Vec3} axleLocal
     */
    this.axleLocal = options.axleLocal.clone();

    /**
     * @property {Vec3} axleWorld
     */
    this.axleWorld = options.axleWorld.clone();

    /**
     * @property {number} suspensionRestLength
     */
    this.suspensionRestLength = options.suspensionRestLength;

    /**
     * @property {number} suspensionMaxLength
     */
    this.suspensionMaxLength = options.suspensionMaxLength;

    /**
     * @property {number} radius
     */
    this.radius = options.radius;

    /**
     * @property {number} suspensionStiffness
     */
    this.suspensionStiffness = options.suspensionStiffness;

    /**
     * @property {number} dampingCompression
     */
    this.dampingCompression = options.dampingCompression;

    /**
     * @property {number} dampingRelaxation
     */
    this.dampingRelaxation = options.dampingRelaxation;

    /**
     * @property {number} frictionSlip
     */
    this.frictionSlip = options.frictionSlip;

    /**
     * @property {number} steering
     */
    this.steering = 0;

    /**
     * Rotation value, in radians.
     * @property {number} rotation
     */
    this.rotation = 0;

    /**
     * @property {number} deltaRotation
     */
    this.deltaRotation = 0;

    /**
     * @property {number} rollInfluence
     */
    this.rollInfluence = options.rollInfluence;

    /**
     * @property {number} maxSuspensionForce
     */
    this.maxSuspensionForce = options.maxSuspensionForce;

    /**
     * @property {number} engineForce
     */
    this.engineForce = 0;

    /**
     * @property {number} brake
     */
    this.brake = 0;

    /**
     * @property {number} isFrontWheel
     */
    this.isFrontWheel = options.isFrontWheel;

    /**
     * @property {number} clippedInvContactDotSuspension
     */
    this.clippedInvContactDotSuspension = 1;

    /**
     * @property {number} suspensionRelativeVelocity
     */
    this.suspensionRelativeVelocity = 0;

    /**
     * @property {number} suspensionForce
     */
    this.suspensionForce = 0;

    /**
     * @property {number} skidInfo
     */
    this.skidInfo = 0;

    /**
     * @property {number} suspensionLength
     */
    this.suspensionLength = 0;

    /**
     * @property {number} sideImpulse
     */
    this.sideImpulse = 0;

    /**
     * @property {number} forwardImpulse
     */
    this.forwardImpulse = 0;

    /**
     * The result from raycasting
     * @property {RaycastResult} raycastResult
     */
    this.raycastResult = new RaycastResult();

    /**
     * Wheel world transform
     * @property {Transform} worldTransform
     */
    this.worldTransform = new Transform();

    /**
     * @property {boolean} isInContact
     */
    this.isInContact = false;
}

var chassis_velocity_at_contactPoint = new Vec3();
var relpos = new Vec3();
var chassis_velocity_at_contactPoint = new Vec3();
WheelInfo.prototype.updateWheel = function(chassis){
    var raycastResult = this.raycastResult;

    if (this.isInContact){
        var project= raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
        raycastResult.hitPointWorld.vsub(chassis.position, relpos);
        chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
        var projVel = raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );
        if (project >= -0.1) {
            this.suspensionRelativeVelocity = 0.0;
            this.clippedInvContactDotSuspension = 1.0 / 0.1;
        } else {
            var inv = -1 / project;
            this.suspensionRelativeVelocity = projVel * inv;
            this.clippedInvContactDotSuspension = inv;
        }

    } else {
        // Not in contact : position wheel in a nice (rest length) position
        raycastResult.suspensionLength = this.suspensionRestLength;
        this.suspensionRelativeVelocity = 0.0;
        raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
        this.clippedInvContactDotSuspension = 1.0;
    }
};
},{"../collision/RaycastResult":11,"../math/Transform":30,"../math/Vec3":31,"../utils/Utils":54}],38:[function(require,module,exports){
module.exports = Box;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');
var ConvexPolyhedron = require('./ConvexPolyhedron');

/**
 * A 3d box shape.
 * @class Box
 * @constructor
 * @param {Vec3} halfExtents
 * @author schteppe
 * @extends Shape
 */
function Box(halfExtents){
    Shape.call(this, {
        type: Shape.types.BOX
    });

    /**
     * @property halfExtents
     * @type {Vec3}
     */
    this.halfExtents = halfExtents;

    /**
     * Used by the contact generator to make contacts with other convex polyhedra for example
     * @property convexPolyhedronRepresentation
     * @type {ConvexPolyhedron}
     */
    this.convexPolyhedronRepresentation = null;

    this.updateConvexPolyhedronRepresentation();
    this.updateBoundingSphereRadius();
}
Box.prototype = new Shape();
Box.prototype.constructor = Box;

/**
 * Updates the local convex polyhedron representation used for some collisions.
 * @method updateConvexPolyhedronRepresentation
 */
Box.prototype.updateConvexPolyhedronRepresentation = function(){
    var sx = this.halfExtents.x;
    var sy = this.halfExtents.y;
    var sz = this.halfExtents.z;
    var V = Vec3;

    var vertices = [
        new V(-sx,-sy,-sz),
        new V( sx,-sy,-sz),
        new V( sx, sy,-sz),
        new V(-sx, sy,-sz),
        new V(-sx,-sy, sz),
        new V( sx,-sy, sz),
        new V( sx, sy, sz),
        new V(-sx, sy, sz)
    ];

    var indices = [
        [3,2,1,0], // -z
        [4,5,6,7], // +z
        [5,4,0,1], // -y
        [2,3,7,6], // +y
        [0,4,7,3], // -x
        [1,2,6,5], // +x
    ];

    var axes = [
        new V(0, 0, 1),
        new V(0, 1, 0),
        new V(1, 0, 0)
    ];

    var h = new ConvexPolyhedron(vertices, indices);
    this.convexPolyhedronRepresentation = h;
    h.material = this.material;
};

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 * @return {Vec3}
 */
Box.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    Box.calculateInertia(this.halfExtents, mass, target);
    return target;
};

Box.calculateInertia = function(halfExtents,mass,target){
    var e = halfExtents;
    target.x = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.z*2*e.z );
    target.y = 1.0 / 12.0 * mass * (   2*e.x*2*e.x + 2*e.z*2*e.z );
    target.z = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.x*2*e.x );
};

/**
 * Get the box 6 side normals
 * @method getSideNormals
 * @param {array}      sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
 * @param {Quaternion} quat             Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
 * @return {array}
 */
Box.prototype.getSideNormals = function(sixTargetVectors,quat){
    var sides = sixTargetVectors;
    var ex = this.halfExtents;
    sides[0].set(  ex.x,     0,     0);
    sides[1].set(     0,  ex.y,     0);
    sides[2].set(     0,     0,  ex.z);
    sides[3].set( -ex.x,     0,     0);
    sides[4].set(     0, -ex.y,     0);
    sides[5].set(     0,     0, -ex.z);

    if(quat!==undefined){
        for(var i=0; i!==sides.length; i++){
            quat.vmult(sides[i],sides[i]);
        }
    }

    return sides;
};

Box.prototype.volume = function(){
    return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
};

Box.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = this.halfExtents.norm();
};

var worldCornerTempPos = new Vec3();
var worldCornerTempNeg = new Vec3();
Box.prototype.forEachWorldCorner = function(pos,quat,callback){

    var e = this.halfExtents;
    var corners = [[  e.x,  e.y,  e.z],
                   [ -e.x,  e.y,  e.z],
                   [ -e.x, -e.y,  e.z],
                   [ -e.x, -e.y, -e.z],
                   [  e.x, -e.y, -e.z],
                   [  e.x,  e.y, -e.z],
                   [ -e.x,  e.y, -e.z],
                   [  e.x, -e.y,  e.z]];
    for(var i=0; i<corners.length; i++){
        worldCornerTempPos.set(corners[i][0],corners[i][1],corners[i][2]);
        quat.vmult(worldCornerTempPos,worldCornerTempPos);
        pos.vadd(worldCornerTempPos,worldCornerTempPos);
        callback(worldCornerTempPos.x,
                 worldCornerTempPos.y,
                 worldCornerTempPos.z);
    }
};

var worldCornersTemp = [
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3()
];
Box.prototype.calculateWorldAABB = function(pos,quat,min,max){

    var e = this.halfExtents;
    worldCornersTemp[0].set(e.x, e.y, e.z);
    worldCornersTemp[1].set(-e.x,  e.y, e.z);
    worldCornersTemp[2].set(-e.x, -e.y, e.z);
    worldCornersTemp[3].set(-e.x, -e.y, -e.z);
    worldCornersTemp[4].set(e.x, -e.y, -e.z);
    worldCornersTemp[5].set(e.x,  e.y, -e.z);
    worldCornersTemp[6].set(-e.x,  e.y, -e.z);
    worldCornersTemp[7].set(e.x, -e.y,  e.z);

    var wc = worldCornersTemp[0];
    quat.vmult(wc, wc);
    pos.vadd(wc, wc);
    max.copy(wc);
    min.copy(wc);
    for(var i=1; i<8; i++){
        var wc = worldCornersTemp[i];
        quat.vmult(wc, wc);
        pos.vadd(wc, wc);
        var x = wc.x;
        var y = wc.y;
        var z = wc.z;
        if(x > max.x){
            max.x = x;
        }
        if(y > max.y){
            max.y = y;
        }
        if(z > max.z){
            max.z = z;
        }

        if(x < min.x){
            min.x = x;
        }
        if(y < min.y){
            min.y = y;
        }
        if(z < min.z){
            min.z = z;
        }
    }

    // Get each axis max
    // min.set(Infinity,Infinity,Infinity);
    // max.set(-Infinity,-Infinity,-Infinity);
    // this.forEachWorldCorner(pos,quat,function(x,y,z){
    //     if(x > max.x){
    //         max.x = x;
    //     }
    //     if(y > max.y){
    //         max.y = y;
    //     }
    //     if(z > max.z){
    //         max.z = z;
    //     }

    //     if(x < min.x){
    //         min.x = x;
    //     }
    //     if(y < min.y){
    //         min.y = y;
    //     }
    //     if(z < min.z){
    //         min.z = z;
    //     }
    // });
};

},{"../math/Vec3":31,"./ConvexPolyhedron":39,"./Shape":44}],39:[function(require,module,exports){
module.exports = ConvexPolyhedron;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Transform = require('../math/Transform');

/**
 * A set of polygons describing a convex shape.
 * @class ConvexPolyhedron
 * @constructor
 * @extends Shape
 * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
 * in the same 3D plane), instead these should be merged into one polygon.
 *
 * @param {array} points An array of Vec3's
 * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.
 *
 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
 * @author schteppe / https://github.com/schteppe
 * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
 *
 * @todo Move the clipping functions to ContactGenerator?
 * @todo Automatically merge coplanar polygons in constructor.
 */
function ConvexPolyhedron(points, faces, uniqueAxes) {
    Shape.call(this, {
        type: Shape.types.CONVEXPOLYHEDRON
    });

    /**
     * Array of Vec3
     * @property vertices
     * @type {Array}
     */
    this.vertices = points||[];

    this.worldVertices = []; // World transformed version of .vertices
    this.worldVerticesNeedsUpdate = true;

    /**
     * Array of integer arrays, indicating which vertices each face consists of
     * @property faces
     * @type {Array}
     */
    this.faces = faces||[];

    /**
     * Array of Vec3
     * @property faceNormals
     * @type {Array}
     */
    this.faceNormals = [];
    this.computeNormals();

    this.worldFaceNormalsNeedsUpdate = true;
    this.worldFaceNormals = []; // World transformed version of .faceNormals

    /**
     * Array of Vec3
     * @property uniqueEdges
     * @type {Array}
     */
    this.uniqueEdges = [];

    /**
     * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
     * @property {Array} uniqueAxes
     */
    this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;

    this.computeEdges();
    this.updateBoundingSphereRadius();
}
ConvexPolyhedron.prototype = new Shape();
ConvexPolyhedron.prototype.constructor = ConvexPolyhedron;

var computeEdges_tmpEdge = new Vec3();
/**
 * Computes uniqueEdges
 * @method computeEdges
 */
ConvexPolyhedron.prototype.computeEdges = function(){
    var faces = this.faces;
    var vertices = this.vertices;
    var nv = vertices.length;
    var edges = this.uniqueEdges;

    edges.length = 0;

    var edge = computeEdges_tmpEdge;

    for(var i=0; i !== faces.length; i++){
        var face = faces[i];
        var numVertices = face.length;
        for(var j = 0; j !== numVertices; j++){
            var k = ( j+1 ) % numVertices;
            vertices[face[j]].vsub(vertices[face[k]], edge);
            edge.normalize();
            var found = false;
            for(var p=0; p !== edges.length; p++){
                if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)){
                    found = true;
                    break;
                }
            }

            if (!found){
                edges.push(edge.clone());
            }
        }
    }
};

/**
 * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.
 * @method computeNormals
 */
ConvexPolyhedron.prototype.computeNormals = function(){
    this.faceNormals.length = this.faces.length;

    // Generate normals
    for(var i=0; i<this.faces.length; i++){

        // Check so all vertices exists for this face
        for(var j=0; j<this.faces[i].length; j++){
            if(!this.vertices[this.faces[i][j]]){
                throw new Error("Vertex "+this.faces[i][j]+" not found!");
            }
        }

        var n = this.faceNormals[i] || new Vec3();
        this.getFaceNormal(i,n);
        n.negate(n);
        this.faceNormals[i] = n;
        var vertex = this.vertices[this.faces[i][0]];
        if(n.dot(vertex) < 0){
            console.error(".faceNormals[" + i + "] = Vec3("+n.toString()+") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");
            for(var j=0; j<this.faces[i].length; j++){
                console.warn(".vertices["+this.faces[i][j]+"] = Vec3("+this.vertices[this.faces[i][j]].toString()+")");
            }
        }
    }
};

/**
 * Get face normal given 3 vertices
 * @static
 * @method getFaceNormal
 * @param {Vec3} va
 * @param {Vec3} vb
 * @param {Vec3} vc
 * @param {Vec3} target
 */
var cb = new Vec3();
var ab = new Vec3();
ConvexPolyhedron.computeNormal = function ( va, vb, vc, target ) {
    vb.vsub(va,ab);
    vc.vsub(vb,cb);
    cb.cross(ab,target);
    if ( !target.isZero() ) {
        target.normalize();
    }
};

/**
 * Compute the normal of a face from its vertices
 * @method getFaceNormal
 * @param  {Number} i
 * @param  {Vec3} target
 */
ConvexPolyhedron.prototype.getFaceNormal = function(i,target){
    var f = this.faces[i];
    var va = this.vertices[f[0]];
    var vb = this.vertices[f[1]];
    var vc = this.vertices[f[2]];
    return ConvexPolyhedron.computeNormal(va,vb,vc,target);
};

/**
 * @method clipAgainstHull
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {ConvexPolyhedron} hullB
 * @param {Vec3} posB
 * @param {Quaternion} quatB
 * @param {Vec3} separatingNormal
 * @param {Number} minDist Clamp distance
 * @param {Number} maxDist
 * @param {array} result The an array of contact point objects, see clipFaceAgainstHull
 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
 */
var cah_WorldNormal = new Vec3();
ConvexPolyhedron.prototype.clipAgainstHull = function(posA,quatA,hullB,posB,quatB,separatingNormal,minDist,maxDist,result){
    var WorldNormal = cah_WorldNormal;
    var hullA = this;
    var curMaxDist = maxDist;
    var closestFaceB = -1;
    var dmax = -Number.MAX_VALUE;
    for(var face=0; face < hullB.faces.length; face++){
        WorldNormal.copy(hullB.faceNormals[face]);
        quatB.vmult(WorldNormal,WorldNormal);
        //posB.vadd(WorldNormal,WorldNormal);
        var d = WorldNormal.dot(separatingNormal);
        if (d > dmax){
            dmax = d;
            closestFaceB = face;
        }
    }
    var worldVertsB1 = [];
    var polyB = hullB.faces[closestFaceB];
    var numVertices = polyB.length;
    for(var e0=0; e0<numVertices; e0++){
        var b = hullB.vertices[polyB[e0]];
        var worldb = new Vec3();
        worldb.copy(b);
        quatB.vmult(worldb,worldb);
        posB.vadd(worldb,worldb);
        worldVertsB1.push(worldb);
    }

    if (closestFaceB>=0){
        this.clipFaceAgainstHull(separatingNormal,
                                 posA,
                                 quatA,
                                 worldVertsB1,
                                 minDist,
                                 maxDist,
                                 result);
    }
};

/**
 * Find the separating axis between this hull and another
 * @method findSeparatingAxis
 * @param {ConvexPolyhedron} hullB
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {Vec3} posB
 * @param {Quaternion} quatB
 * @param {Vec3} target The target vector to save the axis in
 * @return {bool} Returns false if a separation is found, else true
 */
var fsa_faceANormalWS3 = new Vec3(),
    fsa_Worldnormal1 = new Vec3(),
    fsa_deltaC = new Vec3(),
    fsa_worldEdge0 = new Vec3(),
    fsa_worldEdge1 = new Vec3(),
    fsa_Cross = new Vec3();
ConvexPolyhedron.prototype.findSeparatingAxis = function(hullB,posA,quatA,posB,quatB,target, faceListA, faceListB){
    var faceANormalWS3 = fsa_faceANormalWS3,
        Worldnormal1 = fsa_Worldnormal1,
        deltaC = fsa_deltaC,
        worldEdge0 = fsa_worldEdge0,
        worldEdge1 = fsa_worldEdge1,
        Cross = fsa_Cross;

    var dmin = Number.MAX_VALUE;
    var hullA = this;
    var curPlaneTests=0;

    if(!hullA.uniqueAxes){

        var numFacesA = faceListA ? faceListA.length : hullA.faces.length;

        // Test face normals from hullA
        for(var i=0; i<numFacesA; i++){
            var fi = faceListA ? faceListA[i] : i;

            // Get world face normal
            faceANormalWS3.copy(hullA.faceNormals[fi]);
            quatA.vmult(faceANormalWS3,faceANormalWS3);

            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(faceANormalWS3);
            }
        }

    } else {

        // Test unique axes
        for(var i = 0; i !== hullA.uniqueAxes.length; i++){

            // Get world axis
            quatA.vmult(hullA.uniqueAxes[i],faceANormalWS3);

            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(faceANormalWS3);
            }
        }
    }

    if(!hullB.uniqueAxes){

        // Test face normals from hullB
        var numFacesB = faceListB ? faceListB.length : hullB.faces.length;
        for(var i=0;i<numFacesB;i++){

            var fi = faceListB ? faceListB[i] : i;

            Worldnormal1.copy(hullB.faceNormals[fi]);
            quatB.vmult(Worldnormal1,Worldnormal1);
            curPlaneTests++;
            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(Worldnormal1);
            }
        }
    } else {

        // Test unique axes in B
        for(var i = 0; i !== hullB.uniqueAxes.length; i++){
            quatB.vmult(hullB.uniqueAxes[i],Worldnormal1);

            curPlaneTests++;
            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(Worldnormal1);
            }
        }
    }

    // Test edges
    for(var e0=0; e0 !== hullA.uniqueEdges.length; e0++){

        // Get world edge
        quatA.vmult(hullA.uniqueEdges[e0],worldEdge0);

        for(var e1=0; e1 !== hullB.uniqueEdges.length; e1++){

            // Get world edge 2
            quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
            worldEdge0.cross(worldEdge1,Cross);

            if(!Cross.almostZero()){
                Cross.normalize();
                var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);
                if(dist === false){
                    return false;
                }
                if(dist < dmin){
                    dmin = dist;
                    target.copy(Cross);
                }
            }
        }
    }

    posB.vsub(posA,deltaC);
    if((deltaC.dot(target))>0.0){
        target.negate(target);
    }

    return true;
};

var maxminA=[], maxminB=[];

/**
 * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
 * @method testSepAxis
 * @param {Vec3} axis
 * @param {ConvexPolyhedron} hullB
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {Vec3} posB
 * @param {Quaternion} quatB
 * @return {number} The overlap depth, or FALSE if no penetration.
 */
ConvexPolyhedron.prototype.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB){
    var hullA=this;
    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
    var maxA = maxminA[0];
    var minA = maxminA[1];
    var maxB = maxminB[0];
    var minB = maxminB[1];
    if(maxA<minB || maxB<minA){
        return false; // Separated
    }
    var d0 = maxA - minB;
    var d1 = maxB - minA;
    var depth = d0<d1 ? d0:d1;
    return depth;
};

var cli_aabbmin = new Vec3(),
    cli_aabbmax = new Vec3();

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 */
ConvexPolyhedron.prototype.calculateLocalInertia = function(mass,target){
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    this.computeLocalAABB(cli_aabbmin,cli_aabbmax);
    var x = cli_aabbmax.x - cli_aabbmin.x,
        y = cli_aabbmax.y - cli_aabbmin.y,
        z = cli_aabbmax.z - cli_aabbmin.z;
    target.x = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z );
    target.y = 1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z );
    target.z = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x );
};

/**
 * @method getPlaneConstantOfFace
 * @param  {Number} face_i Index of the face
 * @return {Number}
 */
ConvexPolyhedron.prototype.getPlaneConstantOfFace = function(face_i){
    var f = this.faces[face_i];
    var n = this.faceNormals[face_i];
    var v = this.vertices[f[0]];
    var c = -n.dot(v);
    return c;
};

/**
 * Clip a face against a hull.
 * @method clipFaceAgainstHull
 * @param {Vec3} separatingNormal
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.
 * @param {Number} minDist Distance clamping
 * @param {Number} maxDist
 * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
 */
var cfah_faceANormalWS = new Vec3(),
    cfah_edge0 = new Vec3(),
    cfah_WorldEdge0 = new Vec3(),
    cfah_worldPlaneAnormal1 = new Vec3(),
    cfah_planeNormalWS1 = new Vec3(),
    cfah_worldA1 = new Vec3(),
    cfah_localPlaneNormal = new Vec3(),
    cfah_planeNormalWS = new Vec3();
ConvexPolyhedron.prototype.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist,result){
    var faceANormalWS = cfah_faceANormalWS,
        edge0 = cfah_edge0,
        WorldEdge0 = cfah_WorldEdge0,
        worldPlaneAnormal1 = cfah_worldPlaneAnormal1,
        planeNormalWS1 = cfah_planeNormalWS1,
        worldA1 = cfah_worldA1,
        localPlaneNormal = cfah_localPlaneNormal,
        planeNormalWS = cfah_planeNormalWS;

    var hullA = this;
    var worldVertsB2 = [];
    var pVtxIn = worldVertsB1;
    var pVtxOut = worldVertsB2;
    // Find the face with normal closest to the separating axis
    var closestFaceA = -1;
    var dmin = Number.MAX_VALUE;
    for(var face=0; face<hullA.faces.length; face++){
        faceANormalWS.copy(hullA.faceNormals[face]);
        quatA.vmult(faceANormalWS,faceANormalWS);
        //posA.vadd(faceANormalWS,faceANormalWS);
        var d = faceANormalWS.dot(separatingNormal);
        if (d < dmin){
            dmin = d;
            closestFaceA = face;
        }
    }
    if (closestFaceA < 0){
        // console.log("--- did not find any closest face... ---");
        return;
    }
    //console.log("closest A: ",closestFaceA);
    // Get the face and construct connected faces
    var polyA = hullA.faces[closestFaceA];
    polyA.connectedFaces = [];
    for(var i=0; i<hullA.faces.length; i++){
        for(var j=0; j<hullA.faces[i].length; j++){
            if(polyA.indexOf(hullA.faces[i][j])!==-1 /* Sharing a vertex*/ && i!==closestFaceA /* Not the one we are looking for connections from */ && polyA.connectedFaces.indexOf(i)===-1 /* Not already added */ ){
                polyA.connectedFaces.push(i);
            }
        }
    }
    // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face
    var numContacts = pVtxIn.length;
    var numVerticesA = polyA.length;
    var res = [];
    for(var e0=0; e0<numVerticesA; e0++){
        var a = hullA.vertices[polyA[e0]];
        var b = hullA.vertices[polyA[(e0+1)%numVerticesA]];
        a.vsub(b,edge0);
        WorldEdge0.copy(edge0);
        quatA.vmult(WorldEdge0,WorldEdge0);
        posA.vadd(WorldEdge0,WorldEdge0);
        worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);//transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);
        quatA.vmult(worldPlaneAnormal1,worldPlaneAnormal1);
        posA.vadd(worldPlaneAnormal1,worldPlaneAnormal1);
        WorldEdge0.cross(worldPlaneAnormal1,planeNormalWS1);
        planeNormalWS1.negate(planeNormalWS1);
        worldA1.copy(a);
        quatA.vmult(worldA1,worldA1);
        posA.vadd(worldA1,worldA1);
        var planeEqWS1 = -worldA1.dot(planeNormalWS1);
        var planeEqWS;
        if(true){
            var otherFace = polyA.connectedFaces[e0];
            localPlaneNormal.copy(this.faceNormals[otherFace]);
            var localPlaneEq = this.getPlaneConstantOfFace(otherFace);

            planeNormalWS.copy(localPlaneNormal);
            quatA.vmult(planeNormalWS,planeNormalWS);
            //posA.vadd(planeNormalWS,planeNormalWS);
            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
        } else  {
            planeNormalWS.copy(planeNormalWS1);
            planeEqWS = planeEqWS1;
        }

        // Clip face against our constructed plane
        this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);

        // Throw away all clipped points, but save the reamining until next clip
        while(pVtxIn.length){
            pVtxIn.shift();
        }
        while(pVtxOut.length){
            pVtxIn.push(pVtxOut.shift());
        }
    }

    //console.log("Resulting points after clip:",pVtxIn);

    // only keep contact points that are behind the witness face
    localPlaneNormal.copy(this.faceNormals[closestFaceA]);

    var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
    planeNormalWS.copy(localPlaneNormal);
    quatA.vmult(planeNormalWS,planeNormalWS);

    var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
    for (var i=0; i<pVtxIn.length; i++){
        var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???
        /*console.log("depth calc from normal=",planeNormalWS.toString()," and constant "+planeEqWS+" and vertex ",pVtxIn[i].toString()," gives "+depth);*/
        if (depth <=minDist){
            console.log("clamped: depth="+depth+" to minDist="+(minDist+""));
            depth = minDist;
        }

        if (depth <=maxDist){
            var point = pVtxIn[i];
            if(depth<=0){
                /*console.log("Got contact point ",point.toString(),
                  ", depth=",depth,
                  "contact normal=",separatingNormal.toString(),
                  "plane",planeNormalWS.toString(),
                  "planeConstant",planeEqWS);*/
                var p = {
                    point:point,
                    normal:planeNormalWS,
                    depth: depth,
                };
                result.push(p);
            }
        }
    }
};

/**
 * Clip a face in a hull against the back of a plane.
 * @method clipFaceAgainstPlane
 * @param {Array} inVertices
 * @param {Array} outVertices
 * @param {Vec3} planeNormal
 * @param {Number} planeConstant The constant in the mathematical plane equation
 */
ConvexPolyhedron.prototype.clipFaceAgainstPlane = function(inVertices,outVertices, planeNormal, planeConstant){
    var n_dot_first, n_dot_last;
    var numVerts = inVertices.length;

    if(numVerts < 2){
        return outVertices;
    }

    var firstVertex = inVertices[inVertices.length-1],
        lastVertex =   inVertices[0];

    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

    for(var vi = 0; vi < numVerts; vi++){
        lastVertex = inVertices[vi];
        n_dot_last = planeNormal.dot(lastVertex) + planeConstant;
        if(n_dot_first < 0){
            if(n_dot_last < 0){
                // Start < 0, end < 0, so output lastVertex
                var newv = new Vec3();
                newv.copy(lastVertex);
                outVertices.push(newv);
            } else {
                // Start < 0, end >= 0, so output intersection
                var newv = new Vec3();
                firstVertex.lerp(lastVertex,
                                 n_dot_first / (n_dot_first - n_dot_last),
                                 newv);
                outVertices.push(newv);
            }
        } else {
            if(n_dot_last<0){
                // Start >= 0, end < 0 so output intersection and end
                var newv = new Vec3();
                firstVertex.lerp(lastVertex,
                                 n_dot_first / (n_dot_first - n_dot_last),
                                 newv);
                outVertices.push(newv);
                outVertices.push(lastVertex);
            }
        }
        firstVertex = lastVertex;
        n_dot_first = n_dot_last;
    }
    return outVertices;
};

// Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
ConvexPolyhedron.prototype.computeWorldVertices = function(position,quat){
    var N = this.vertices.length;
    while(this.worldVertices.length < N){
        this.worldVertices.push( new Vec3() );
    }

    var verts = this.vertices,
        worldVerts = this.worldVertices;
    for(var i=0; i!==N; i++){
        quat.vmult( verts[i] , worldVerts[i] );
        position.vadd( worldVerts[i] , worldVerts[i] );
    }

    this.worldVerticesNeedsUpdate = false;
};

var computeLocalAABB_worldVert = new Vec3();
ConvexPolyhedron.prototype.computeLocalAABB = function(aabbmin,aabbmax){
    var n = this.vertices.length,
        vertices = this.vertices,
        worldVert = computeLocalAABB_worldVert;

    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

    for(var i=0; i<n; i++){
        var v = vertices[i];
        if     (v.x < aabbmin.x){
            aabbmin.x = v.x;
        } else if(v.x > aabbmax.x){
            aabbmax.x = v.x;
        }
        if     (v.y < aabbmin.y){
            aabbmin.y = v.y;
        } else if(v.y > aabbmax.y){
            aabbmax.y = v.y;
        }
        if     (v.z < aabbmin.z){
            aabbmin.z = v.z;
        } else if(v.z > aabbmax.z){
            aabbmax.z = v.z;
        }
    }
};

/**
 * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
 * @method computeWorldFaceNormals
 * @param  {Quaternion} quat
 */
ConvexPolyhedron.prototype.computeWorldFaceNormals = function(quat){
    var N = this.faceNormals.length;
    while(this.worldFaceNormals.length < N){
        this.worldFaceNormals.push( new Vec3() );
    }

    var normals = this.faceNormals,
        worldNormals = this.worldFaceNormals;
    for(var i=0; i!==N; i++){
        quat.vmult( normals[i] , worldNormals[i] );
    }

    this.worldFaceNormalsNeedsUpdate = false;
};

/**
 * @method updateBoundingSphereRadius
 */
ConvexPolyhedron.prototype.updateBoundingSphereRadius = function(){
    // Assume points are distributed with local (0,0,0) as center
    var max2 = 0;
    var verts = this.vertices;
    for(var i=0, N=verts.length; i!==N; i++) {
        var norm2 = verts[i].norm2();
        if(norm2 > max2){
            max2 = norm2;
        }
    }
    this.boundingSphereRadius = Math.sqrt(max2);
};

var tempWorldVertex = new Vec3();

/**
 * @method calculateWorldAABB
 * @param {Vec3}        pos
 * @param {Quaternion}  quat
 * @param {Vec3}        min
 * @param {Vec3}        max
 */
ConvexPolyhedron.prototype.calculateWorldAABB = function(pos,quat,min,max){
    var n = this.vertices.length, verts = this.vertices;
    var minx,miny,minz,maxx,maxy,maxz;
    for(var i=0; i<n; i++){
        tempWorldVertex.copy(verts[i]);
        quat.vmult(tempWorldVertex,tempWorldVertex);
        pos.vadd(tempWorldVertex,tempWorldVertex);
        var v = tempWorldVertex;
        if     (v.x < minx || minx===undefined){
            minx = v.x;
        } else if(v.x > maxx || maxx===undefined){
            maxx = v.x;
        }

        if     (v.y < miny || miny===undefined){
            miny = v.y;
        } else if(v.y > maxy || maxy===undefined){
            maxy = v.y;
        }

        if     (v.z < minz || minz===undefined){
            minz = v.z;
        } else if(v.z > maxz || maxz===undefined){
            maxz = v.z;
        }
    }
    min.set(minx,miny,minz);
    max.set(maxx,maxy,maxz);
};

/**
 * Get approximate convex volume
 * @method volume
 * @return {Number}
 */
ConvexPolyhedron.prototype.volume = function(){
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
};

/**
 * Get an average of all the vertices positions
 * @method getAveragePointLocal
 * @param  {Vec3} target
 * @return {Vec3}
 */
ConvexPolyhedron.prototype.getAveragePointLocal = function(target){
    target = target || new Vec3();
    var n = this.vertices.length,
        verts = this.vertices;
    for(var i=0; i<n; i++){
        target.vadd(verts[i],target);
    }
    target.mult(1/n,target);
    return target;
};

/**
 * Transform all local points. Will change the .vertices
 * @method transformAllPoints
 * @param  {Vec3} offset
 * @param  {Quaternion} quat
 */
ConvexPolyhedron.prototype.transformAllPoints = function(offset,quat){
    var n = this.vertices.length,
        verts = this.vertices;

    // Apply rotation
    if(quat){
        // Rotate vertices
        for(var i=0; i<n; i++){
            var v = verts[i];
            quat.vmult(v,v);
        }
        // Rotate face normals
        for(var i=0; i<this.faceNormals.length; i++){
            var v = this.faceNormals[i];
            quat.vmult(v,v);
        }
        /*
        // Rotate edges
        for(var i=0; i<this.uniqueEdges.length; i++){
            var v = this.uniqueEdges[i];
            quat.vmult(v,v);
        }*/
    }

    // Apply offset
    if(offset){
        for(var i=0; i<n; i++){
            var v = verts[i];
            v.vadd(offset,v);
        }
    }
};

/**
 * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.
 * @method pointIsInside
 * @param  {Vec3} p      A point given in local coordinates
 * @return {Boolean}
 */
var ConvexPolyhedron_pointIsInside = new Vec3();
var ConvexPolyhedron_vToP = new Vec3();
var ConvexPolyhedron_vToPointInside = new Vec3();
ConvexPolyhedron.prototype.pointIsInside = function(p){
    var n = this.vertices.length,
        verts = this.vertices,
        faces = this.faces,
        normals = this.faceNormals;
    var positiveResult = null;
    var N = this.faces.length;
    var pointInside = ConvexPolyhedron_pointIsInside;
    this.getAveragePointLocal(pointInside);
    for(var i=0; i<N; i++){
        var numVertices = this.faces[i].length;
        var n = normals[i];
        var v = verts[faces[i][0]]; // We only need one point in the face

        // This dot product determines which side of the edge the point is
        var vToP = ConvexPolyhedron_vToP;
        p.vsub(v,vToP);
        var r1 = n.dot(vToP);

        var vToPointInside = ConvexPolyhedron_vToPointInside;
        pointInside.vsub(v,vToPointInside);
        var r2 = n.dot(vToPointInside);

        if((r1<0 && r2>0) || (r1>0 && r2<0)){
            return false; // Encountered some other sign. Exit.
        } else {
        }
    }

    // If we got here, all dot products were of the same sign.
    return positiveResult ? 1 : -1;
};

/**
 * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.
 * @static
 * @method project
 * @param {ConvexPolyhedron} hull
 * @param {Vec3} axis
 * @param {Vec3} pos
 * @param {Quaternion} quat
 * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.
 */
var project_worldVertex = new Vec3();
var project_localAxis = new Vec3();
var project_localOrigin = new Vec3();
ConvexPolyhedron.project = function(hull, axis, pos, quat, result){
    var n = hull.vertices.length,
        worldVertex = project_worldVertex,
        localAxis = project_localAxis,
        max = 0,
        min = 0,
        localOrigin = project_localOrigin,
        vs = hull.vertices;

    localOrigin.setZero();

    // Transform the axis to local
    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
    var add = localOrigin.dot(localAxis);

    min = max = vs[0].dot(localAxis);

    for(var i = 1; i < n; i++){
        var val = vs[i].dot(localAxis);

        if(val > max){
            max = val;
        }

        if(val < min){
            min = val;
        }
    }

    min -= add;
    max -= add;

    if(min > max){
        // Inconsistent - swap
        var temp = min;
        min = max;
        max = temp;
    }
    // Output
    result[0] = max;
    result[1] = min;
};

},{"../math/Quaternion":29,"../math/Transform":30,"../math/Vec3":31,"./Shape":44}],40:[function(require,module,exports){
module.exports = Cylinder;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var ConvexPolyhedron = require('./ConvexPolyhedron');

/**
 * @class Cylinder
 * @constructor
 * @extends ConvexPolyhedron
 * @author schteppe / https://github.com/schteppe
 * @param {Number} radiusTop
 * @param {Number} radiusBottom
 * @param {Number} height
 * @param {Number} numSegments The number of segments to build the cylinder out of
 */
function Cylinder( radiusTop, radiusBottom, height , numSegments ) {
    var N = numSegments,
        verts = [],
        axes = [],
        faces = [],
        bottomface = [],
        topface = [],
        cos = Math.cos,
        sin = Math.sin;

    // First bottom point
    verts.push(new Vec3(radiusBottom*cos(0),
                               radiusBottom*sin(0),
                               -height*0.5));
    bottomface.push(0);

    // First top point
    verts.push(new Vec3(radiusTop*cos(0),
                               radiusTop*sin(0),
                               height*0.5));
    topface.push(1);

    for(var i=0; i<N; i++){
        var theta = 2*Math.PI/N * (i+1);
        var thetaN = 2*Math.PI/N * (i+0.5);
        if(i<N-1){
            // Bottom
            verts.push(new Vec3(radiusBottom*cos(theta),
                                       radiusBottom*sin(theta),
                                       -height*0.5));
            bottomface.push(2*i+2);
            // Top
            verts.push(new Vec3(radiusTop*cos(theta),
                                       radiusTop*sin(theta),
                                       height*0.5));
            topface.push(2*i+3);

            // Face
            faces.push([2*i+2, 2*i+3, 2*i+1,2*i]);
        } else {
            faces.push([0,1, 2*i+1, 2*i]); // Connect
        }

        // Axis: we can cut off half of them if we have even number of segments
        if(N % 2 === 1 || i < N / 2){
            axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));
        }
    }
    faces.push(topface);
    axes.push(new Vec3(0,0,1));

    // Reorder bottom face
    var temp = [];
    for(var i=0; i<bottomface.length; i++){
        temp.push(bottomface[bottomface.length - i - 1]);
    }
    faces.push(temp);

    ConvexPolyhedron.call( this, verts, faces, axes );
}

Cylinder.prototype = new ConvexPolyhedron();

},{"../math/Quaternion":29,"../math/Vec3":31,"./ConvexPolyhedron":39,"./Shape":44}],41:[function(require,module,exports){
var Shape = require('./Shape');
var ConvexPolyhedron = require('./ConvexPolyhedron');
var Vec3 = require('../math/Vec3');
var Utils = require('../utils/Utils');

module.exports = Heightfield;

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
 * @class Heightfield
 * @extends Shape
 * @constructor
 * @param {Array} data An array of Y values that will be used to construct the terrain.
 * @param {object} options
 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
 * @param {Number} [options.maxValue] Maximum value.
 * @param {Number} [options.elementSize=0.1] World spacing between the data points in X direction.
 * @todo Should be possible to use along all axes, not just y
 * @todo should be possible to scale along all axes
 *
 * @example
 *     // Generate some height data (y-values).
 *     var data = [];
 *     for(var i = 0; i < 1000; i++){
 *         var y = 0.5 * Math.cos(0.2 * i);
 *         data.push(y);
 *     }
 *
 *     // Create the heightfield shape
 *     var heightfieldShape = new Heightfield(data, {
 *         elementSize: 1 // Distance between the data points in X and Y directions
 *     });
 *     var heightfieldBody = new Body();
 *     heightfieldBody.addShape(heightfieldShape);
 *     world.addBody(heightfieldBody);
 */
function Heightfield(data, options){
    options = Utils.defaults(options, {
        maxValue : null,
        minValue : null,
        elementSize : 1
    });

    /**
     * An array of numbers, or height values, that are spread out along the x axis.
     * @property {array} data
     */
    this.data = data;

    /**
     * Max value of the data
     * @property {number} maxValue
     */
    this.maxValue = options.maxValue;

    /**
     * Max value of the data
     * @property {number} minValue
     */
    this.minValue = options.minValue;

    /**
     * The width of each element
     * @property {number} elementSize
     * @todo elementSizeX and Y
     */
    this.elementSize = options.elementSize;

    if(options.minValue === null){
        this.updateMinValue();
    }
    if(options.maxValue === null){
        this.updateMaxValue();
    }

    this.cacheEnabled = true;

    Shape.call(this, {
        type: Shape.types.HEIGHTFIELD
    });

    this.pillarConvex = new ConvexPolyhedron();
    this.pillarOffset = new Vec3();

    this.updateBoundingSphereRadius();

    // "i_j_isUpper" => { convex: ..., offset: ... }
    // for example:
    // _cachedPillars["0_2_1"]
    this._cachedPillars = {};
}
Heightfield.prototype = new Shape();

/**
 * Call whenever you change the data array.
 * @method update
 */
Heightfield.prototype.update = function(){
    this._cachedPillars = {};
};

/**
 * Update the .minValue property
 * @method updateMinValue
 */
Heightfield.prototype.updateMinValue = function(){
    var data = this.data;
    var minValue = data[0][0];
    for(var i=0; i !== data.length; i++){
        for(var j=0; j !== data[i].length; j++){
            var v = data[i][j];
            if(v < minValue){
                minValue = v;
            }
        }
    }
    this.minValue = minValue;
};

/**
 * Update the .maxValue property
 * @method updateMaxValue
 */
Heightfield.prototype.updateMaxValue = function(){
    var data = this.data;
    var maxValue = data[0][0];
    for(var i=0; i !== data.length; i++){
        for(var j=0; j !== data[i].length; j++){
            var v = data[i][j];
            if(v > maxValue){
                maxValue = v;
            }
        }
    }
    this.maxValue = maxValue;
};

/**
 * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
 * @method setHeightValueAtIndex
 * @param {integer} xi
 * @param {integer} yi
 * @param {number} value
 */
Heightfield.prototype.setHeightValueAtIndex = function(xi, yi, value){
    var data = this.data;
    data[xi][yi] = value;

    // Invalidate cache
    this.clearCachedConvexTrianglePillar(xi, yi, false);
    if(xi > 0){
        this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
        this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
    }
    if(yi > 0){
        this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
        this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
    }
    if(yi > 0 && xi > 0){
        this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
    }
};

/**
 * Get max/min in a rectangle in the matrix data
 * @method getRectMinMax
 * @param  {integer} iMinX
 * @param  {integer} iMinY
 * @param  {integer} iMaxX
 * @param  {integer} iMaxY
 * @param  {array} [result] An array to store the results in.
 * @return {array} The result array, if it was passed in. Minimum will be at position 0 and max at 1.
 */
Heightfield.prototype.getRectMinMax = function (iMinX, iMinY, iMaxX, iMaxY, result) {
    result = result || [];

    // Get max and min of the data
    var data = this.data,
        max = this.minValue; // Set first value
    for(var i = iMinX; i <= iMaxX; i++){
        for(var j = iMinY; j <= iMaxY; j++){
            var height = data[i][j];
            if(height > max){
                max = height;
            }
        }
    }

    result[0] = this.minValue;
    result[1] = max;
};



/**
 * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
 * @method getIndexOfPosition
 * @param  {number} x
 * @param  {number} y
 * @param  {array} result Two-element array
 * @param  {boolean} clamp If the position should be clamped to the heightfield edge.
 * @return {boolean}
 */
Heightfield.prototype.getIndexOfPosition = function (x, y, result, clamp) {

    // Get the index of the data points to test against
    var w = this.elementSize;
    var data = this.data;
    var xi = Math.floor(x / w);
    var yi = Math.floor(y / w);

    result[0] = xi;
    result[1] = yi;

    if(clamp){
        // Clamp index to edges
        if(xi < 0){ xi = 0; }
        if(yi < 0){ yi = 0; }
        if(xi >= data.length - 1){ xi = data.length - 1; }
        if(yi >= data[0].length - 1){ yi = data[0].length - 1; }
    }

    // Bail out if we are out of the terrain
    if(xi < 0 || yi < 0 || xi >= data.length-1 || yi >= data[0].length-1){
        return false;
    }

    return true;
};


var getHeightAt_idx = [];
var getHeightAt_weights = new Vec3();
var getHeightAt_a = new Vec3();
var getHeightAt_b = new Vec3();
var getHeightAt_c = new Vec3();

Heightfield.prototype.getTriangleAt = function(x, y, edgeClamp, a, b, c){
    var idx = getHeightAt_idx;
    this.getIndexOfPosition(x, y, idx, edgeClamp);
    var xi = idx[0];
    var yi = idx[1];

    var data = this.data;
    if(edgeClamp){
        xi = Math.min(data.length - 2, Math.max(0, xi));
        yi = Math.min(data[0].length - 2, Math.max(0, yi));
    }

    var elementSize = this.elementSize;
    var lowerDist2 = Math.pow(x / elementSize - xi, 2) + Math.pow(y / elementSize - yi, 2);
    var upperDist2 = Math.pow(x / elementSize - (xi + 1), 2) + Math.pow(y / elementSize - (yi + 1), 2);
    var upper = lowerDist2 > upperDist2;
    this.getTriangle(xi, yi, upper, a, b, c);
    return upper;
};

var getNormalAt_a = new Vec3();
var getNormalAt_b = new Vec3();
var getNormalAt_c = new Vec3();
var getNormalAt_e0 = new Vec3();
var getNormalAt_e1 = new Vec3();
Heightfield.prototype.getNormalAt = function(x, y, edgeClamp, result){
    var a = getNormalAt_a;
    var b = getNormalAt_b;
    var c = getNormalAt_c;
    var e0 = getNormalAt_e0;
    var e1 = getNormalAt_e1;
    this.getTriangleAt(x, y, edgeClamp, a, b, c);
    b.vsub(a, e0);
    c.vsub(a, e1);
    e0.cross(e1, result);
    result.normalize();
};


/**
 * Get an AABB of a square in the heightfield
 * @param  {number} xi
 * @param  {number} yi
 * @param  {AABB} result
 */
Heightfield.prototype.getAabbAtIndex = function(xi, yi, result){
    var data = this.data;
    var elementSize = this.elementSize;

    result.lowerBound.set(
        xi * elementSize,
        yi * elementSize,
        data[xi][yi]
    );
    result.upperBound.set(
        (xi + 1) * elementSize,
        (yi + 1) * elementSize,
        data[xi + 1][yi + 1]
    );
};


/**
 * Get the height in the heightfield at a given position
 * @param  {number} x
 * @param  {number} y
 * @param  {boolean} edgeClamp
 * @return {number}
 */
Heightfield.prototype.getHeightAt = function(x, y, edgeClamp){
    var data = this.data;
    var a = getHeightAt_a;
    var b = getHeightAt_b;
    var c = getHeightAt_c;
    var idx = getHeightAt_idx;

    this.getIndexOfPosition(x, y, idx, edgeClamp);
    var xi = idx[0];
    var yi = idx[1];
    if(edgeClamp){
        xi = Math.min(data.length - 2, Math.max(0, xi));
        yi = Math.min(data[0].length - 2, Math.max(0, yi));
    }
    var upper = this.getTriangleAt(x, y, edgeClamp, a, b, c);
    barycentricWeights(x, y, a.x, a.y, b.x, b.y, c.x, c.y, getHeightAt_weights);

    var w = getHeightAt_weights;

    if(upper){

        // Top triangle verts
        return data[xi + 1][yi + 1] * w.x + data[xi][yi + 1] * w.y + data[xi + 1][yi] * w.z;

    } else {

        // Top triangle verts
        return data[xi][yi] * w.x + data[xi + 1][yi] * w.y + data[xi][yi + 1] * w.z;
    }
};

// from https://en.wikipedia.org/wiki/Barycentric_coordinate_system
function barycentricWeights(x, y, ax, ay, bx, by, cx, cy, result){
    result.x = ((by - cy) * (x - cx) + (cx - bx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
    result.y = ((cy - ay) * (x - cx) + (ax - cx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
    result.z = 1 - result.x - result.y;
}

Heightfield.prototype.getCacheConvexTrianglePillarKey = function(xi, yi, getUpperTriangle){
    return xi + '_' + yi + '_' + (getUpperTriangle ? 1 : 0);
};

Heightfield.prototype.getCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){
    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
};

Heightfield.prototype.setCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle, convex, offset){
    this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
        convex: convex,
        offset: offset
    };
};

Heightfield.prototype.clearCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){
    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
};

/**
 * Get a triangle from the heightfield
 * @param  {number} xi
 * @param  {number} yi
 * @param  {boolean} upper
 * @param  {Vec3} a
 * @param  {Vec3} b
 * @param  {Vec3} c
 */
Heightfield.prototype.getTriangle = function(xi, yi, upper, a, b, c){
    var data = this.data;
    var elementSize = this.elementSize;

    if(upper){

        // Top triangle verts
        a.set(
            (xi + 1) * elementSize,
            (yi + 1) * elementSize,
            data[xi + 1][yi + 1]
        );
        b.set(
            xi * elementSize,
            (yi + 1) * elementSize,
            data[xi][yi + 1]
        );
        c.set(
            (xi + 1) * elementSize,
            yi * elementSize,
            data[xi + 1][yi]
        );

    } else {

        // Top triangle verts
        a.set(
            xi * elementSize,
            yi * elementSize,
            data[xi][yi]
        );
        b.set(
            (xi + 1) * elementSize,
            yi * elementSize,
            data[xi + 1][yi]
        );
        c.set(
            xi * elementSize,
            (yi + 1) * elementSize,
            data[xi][yi + 1]
        );
    }
};

/**
 * Get a triangle in the terrain in the form of a triangular convex shape.
 * @method getConvexTrianglePillar
 * @param  {integer} i
 * @param  {integer} j
 * @param  {boolean} getUpperTriangle
 */
Heightfield.prototype.getConvexTrianglePillar = function(xi, yi, getUpperTriangle){
    var result = this.pillarConvex;
    var offsetResult = this.pillarOffset;

    if(this.cacheEnabled){
        var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);
        if(data){
            this.pillarConvex = data.convex;
            this.pillarOffset = data.offset;
            return;
        }

        result = new ConvexPolyhedron();
        offsetResult = new Vec3();

        this.pillarConvex = result;
        this.pillarOffset = offsetResult;
    }

    var data = this.data;
    var elementSize = this.elementSize;
    var faces = result.faces;

    // Reuse verts if possible
    result.vertices.length = 6;
    for (var i = 0; i < 6; i++) {
        if(!result.vertices[i]){
            result.vertices[i] = new Vec3();
        }
    }

    // Reuse faces if possible
    faces.length = 5;
    for (var i = 0; i < 5; i++) {
        if(!faces[i]){
            faces[i] = [];
        }
    }

    var verts = result.vertices;

    var h = (Math.min(
        data[xi][yi],
        data[xi+1][yi],
        data[xi][yi+1],
        data[xi+1][yi+1]
    ) - this.minValue ) / 2 + this.minValue;

    if (!getUpperTriangle) {

        // Center of the triangle pillar - all polygons are given relative to this one
        offsetResult.set(
            (xi + 0.25) * elementSize, // sort of center of a triangle
            (yi + 0.25) * elementSize,
            h // vertical center
        );

        // Top triangle verts
        verts[0].set(
            -0.25 * elementSize,
            -0.25 * elementSize,
            data[xi][yi] - h
        );
        verts[1].set(
            0.75 * elementSize,
            -0.25 * elementSize,
            data[xi + 1][yi] - h
        );
        verts[2].set(
            -0.25 * elementSize,
            0.75 * elementSize,
            data[xi][yi + 1] - h
        );

        // bottom triangle verts
        verts[3].set(
            -0.25 * elementSize,
            -0.25 * elementSize,
            -h-1
        );
        verts[4].set(
            0.75 * elementSize,
            -0.25 * elementSize,
            -h-1
        );
        verts[5].set(
            -0.25 * elementSize,
            0.75  * elementSize,
            -h-1
        );

        // top triangle
        faces[0][0] = 0;
        faces[0][1] = 1;
        faces[0][2] = 2;

        // bottom triangle
        faces[1][0] = 5;
        faces[1][1] = 4;
        faces[1][2] = 3;

        // -x facing quad
        faces[2][0] = 0;
        faces[2][1] = 2;
        faces[2][2] = 5;
        faces[2][3] = 3;

        // -y facing quad
        faces[3][0] = 1;
        faces[3][1] = 0;
        faces[3][2] = 3;
        faces[3][3] = 4;

        // +xy facing quad
        faces[4][0] = 4;
        faces[4][1] = 5;
        faces[4][2] = 2;
        faces[4][3] = 1;


    } else {

        // Center of the triangle pillar - all polygons are given relative to this one
        offsetResult.set(
            (xi + 0.75) * elementSize, // sort of center of a triangle
            (yi + 0.75) * elementSize,
            h // vertical center
        );

        // Top triangle verts
        verts[0].set(
            0.25 * elementSize,
            0.25 * elementSize,
            data[xi + 1][yi + 1] - h
        );
        verts[1].set(
            -0.75 * elementSize,
            0.25 * elementSize,
            data[xi][yi + 1] - h
        );
        verts[2].set(
            0.25 * elementSize,
            -0.75 * elementSize,
            data[xi + 1][yi] - h
        );

        // bottom triangle verts
        verts[3].set(
            0.25 * elementSize,
            0.25 * elementSize,
            - h-1
        );
        verts[4].set(
            -0.75 * elementSize,
            0.25 * elementSize,
            - h-1
        );
        verts[5].set(
            0.25 * elementSize,
            -0.75 * elementSize,
            - h-1
        );

        // Top triangle
        faces[0][0] = 0;
        faces[0][1] = 1;
        faces[0][2] = 2;

        // bottom triangle
        faces[1][0] = 5;
        faces[1][1] = 4;
        faces[1][2] = 3;

        // +x facing quad
        faces[2][0] = 2;
        faces[2][1] = 5;
        faces[2][2] = 3;
        faces[2][3] = 0;

        // +y facing quad
        faces[3][0] = 3;
        faces[3][1] = 4;
        faces[3][2] = 1;
        faces[3][3] = 0;

        // -xy facing quad
        faces[4][0] = 1;
        faces[4][1] = 4;
        faces[4][2] = 5;
        faces[4][3] = 2;
    }

    result.computeNormals();
    result.computeEdges();
    result.updateBoundingSphereRadius();

    this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
};

Heightfield.prototype.calculateLocalInertia = function(mass, target){
    target = target || new Vec3();
    target.set(0, 0, 0);
    return target;
};

Heightfield.prototype.volume = function(){
    return Number.MAX_VALUE; // The terrain is infinite
};

Heightfield.prototype.calculateWorldAABB = function(pos, quat, min, max){
    // TODO: do it properly
    min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
};

Heightfield.prototype.updateBoundingSphereRadius = function(){
    // Use the bounding box of the min/max values
    var data = this.data,
        s = this.elementSize;
    this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
};

/**
 * Sets the height values from an image. Currently only supported in browser.
 * @method setHeightsFromImage
 * @param {Image} image
 * @param {Vec3} scale
 */
Heightfield.prototype.setHeightsFromImage = function(image, scale){
    var canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    var context = canvas.getContext('2d');
    context.drawImage(image, 0, 0);
    var imageData = context.getImageData(0, 0, image.width, image.height);

    var matrix = this.data;
    matrix.length = 0;
    this.elementSize = Math.abs(scale.x) / imageData.width;
    for(var i=0; i<imageData.height; i++){
        var row = [];
        for(var j=0; j<imageData.width; j++){
            var a = imageData.data[(i*imageData.height + j) * 4];
            var b = imageData.data[(i*imageData.height + j) * 4 + 1];
            var c = imageData.data[(i*imageData.height + j) * 4 + 2];
            var height = (a + b + c) / 4 / 255 * scale.z;
            if(scale.x < 0){
                row.push(height);
            } else {
                row.unshift(height);
            }
        }
        if(scale.y < 0){
            matrix.unshift(row);
        } else {
            matrix.push(row);
        }
    }
    this.updateMaxValue();
    this.updateMinValue();
    this.update();
};
},{"../math/Vec3":31,"../utils/Utils":54,"./ConvexPolyhedron":39,"./Shape":44}],42:[function(require,module,exports){
module.exports = Particle;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');

/**
 * Particle shape.
 * @class Particle
 * @constructor
 * @author schteppe
 * @extends Shape
 */
function Particle(){
    Shape.call(this, {
        type: Shape.types.PARTICLE
    });
}
Particle.prototype = new Shape();
Particle.prototype.constructor = Particle;

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 * @return {Vec3}
 */
Particle.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    target.set(0, 0, 0);
    return target;
};

Particle.prototype.volume = function(){
    return 0;
};

Particle.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = 0;
};

Particle.prototype.calculateWorldAABB = function(pos,quat,min,max){
    // Get each axis max
    min.copy(pos);
    max.copy(pos);
};

},{"../math/Vec3":31,"./Shape":44}],43:[function(require,module,exports){
module.exports = Plane;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');

/**
 * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.
 * @class Plane
 * @constructor
 * @extends Shape
 * @author schteppe
 */
function Plane(){
    Shape.call(this, {
        type: Shape.types.PLANE
    });

    // World oriented normal
    this.worldNormal = new Vec3();
    this.worldNormalNeedsUpdate = true;

    this.boundingSphereRadius = Number.MAX_VALUE;
}
Plane.prototype = new Shape();
Plane.prototype.constructor = Plane;

Plane.prototype.computeWorldNormal = function(quat){
    var n = this.worldNormal;
    n.set(0,0,1);
    quat.vmult(n,n);
    this.worldNormalNeedsUpdate = false;
};

Plane.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    return target;
};

Plane.prototype.volume = function(){
    return Number.MAX_VALUE; // The plane is infinite...
};

var tempNormal = new Vec3();
Plane.prototype.calculateWorldAABB = function(pos, quat, min, max){
    // The plane AABB is infinite, except if the normal is pointing along any axis
    tempNormal.set(0,0,1); // Default plane normal is z
    quat.vmult(tempNormal,tempNormal);
    var maxVal = Number.MAX_VALUE;
    min.set(-maxVal, -maxVal, -maxVal);
    max.set(maxVal, maxVal, maxVal);

    if(tempNormal.x === 1){ max.x = pos.x; }
    if(tempNormal.y === 1){ max.y = pos.y; }
    if(tempNormal.z === 1){ max.z = pos.z; }

    if(tempNormal.x === -1){ min.x = pos.x; }
    if(tempNormal.y === -1){ min.y = pos.y; }
    if(tempNormal.z === -1){ min.z = pos.z; }
};

Plane.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = Number.MAX_VALUE;
};
},{"../math/Vec3":31,"./Shape":44}],44:[function(require,module,exports){
module.exports = Shape;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Material = require('../material/Material');

/**
 * Base class for shapes
 * @class Shape
 * @constructor
 * @param {object} [options]
 * @param {number} [options.collisionFilterGroup=1]
 * @param {number} [options.collisionFilterMask=-1]
 * @param {number} [options.collisionResponse=true]
 * @param {number} [options.material=null]
 * @author schteppe
 */
function Shape(options){
    options = options || {};

    /**
     * Identifyer of the Shape.
     * @property {number} id
     */
    this.id = Shape.idCounter++;

    /**
     * The type of this shape. Must be set to an int > 0 by subclasses.
     * @property type
     * @type {Number}
     * @see Shape.types
     */
    this.type = options.type || 0;

    /**
     * The local bounding sphere radius of this shape.
     * @property {Number} boundingSphereRadius
     */
    this.boundingSphereRadius = 0;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
     * @property {boolean} collisionResponse
     */
    this.collisionResponse = options.collisionResponse ? options.collisionResponse : true;

    /**
     * @property {Number} collisionFilterGroup
     */
    this.collisionFilterGroup = options.collisionFilterGroup !== undefined ? options.collisionFilterGroup : 1;

    /**
     * @property {Number} collisionFilterMask
     */
    this.collisionFilterMask = options.collisionFilterMask !== undefined ? options.collisionFilterMask : -1;

    /**
     * @property {Material} material
     */
    this.material = options.material ? options.material : null;

    /**
     * @property {Body} body
     */
    this.body = null;
}
Shape.prototype.constructor = Shape;

/**
 * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius
 * @method updateBoundingSphereRadius
 */
Shape.prototype.updateBoundingSphereRadius = function(){
    throw "computeBoundingSphereRadius() not implemented for shape type "+this.type;
};

/**
 * Get the volume of this shape
 * @method volume
 * @return {Number}
 */
Shape.prototype.volume = function(){
    throw "volume() not implemented for shape type "+this.type;
};

/**
 * Calculates the inertia in the local frame for this shape.
 * @method calculateLocalInertia
 * @param {Number} mass
 * @param {Vec3} target
 * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
 */
Shape.prototype.calculateLocalInertia = function(mass,target){
    throw "calculateLocalInertia() not implemented for shape type "+this.type;
};

Shape.idCounter = 0;

/**
 * The available shape types.
 * @static
 * @property types
 * @type {Object}
 */
Shape.types = {
    SPHERE:1,
    PLANE:2,
    BOX:4,
    COMPOUND:8,
    CONVEXPOLYHEDRON:16,
    HEIGHTFIELD:32,
    PARTICLE:64,
    CYLINDER:128,
    TRIMESH:256
};


},{"../material/Material":26,"../math/Quaternion":29,"../math/Vec3":31,"./Shape":44}],45:[function(require,module,exports){
module.exports = Sphere;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');

/**
 * Spherical shape
 * @class Sphere
 * @constructor
 * @extends Shape
 * @param {Number} radius The radius of the sphere, a non-negative number.
 * @author schteppe / http://github.com/schteppe
 */
function Sphere(radius){
    Shape.call(this, {
        type: Shape.types.SPHERE
    });

    /**
     * @property {Number} radius
     */
    this.radius = radius !== undefined ? radius : 1.0;

    if(this.radius < 0){
        throw new Error('The sphere radius cannot be negative.');
    }

    this.updateBoundingSphereRadius();
}
Sphere.prototype = new Shape();
Sphere.prototype.constructor = Sphere;

Sphere.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    var I = 2.0*mass*this.radius*this.radius/5.0;
    target.x = I;
    target.y = I;
    target.z = I;
    return target;
};

Sphere.prototype.volume = function(){
    return 4.0 * Math.PI * this.radius / 3.0;
};

Sphere.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = this.radius;
};

Sphere.prototype.calculateWorldAABB = function(pos,quat,min,max){
    var r = this.radius;
    var axes = ['x','y','z'];
    for(var i=0; i<axes.length; i++){
        var ax = axes[i];
        min[ax] = pos[ax] - r;
        max[ax] = pos[ax] + r;
    }
};

},{"../math/Vec3":31,"./Shape":44}],46:[function(require,module,exports){
module.exports = Trimesh;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Transform = require('../math/Transform');
var AABB = require('../collision/AABB');
var Octree = require('../utils/Octree');

/**
 * @class Trimesh
 * @constructor
 * @param {array} vertices
 * @param {array} indices
 * @extends Shape
 * @example
 *     // How to make a mesh with a single triangle
 *     var vertices = [
 *         0, 0, 0, // vertex 0
 *         1, 0, 0, // vertex 1
 *         0, 1, 0  // vertex 2
 *     ];
 *     var indices = [
 *         0, 1, 2  // triangle 0
 *     ];
 *     var trimeshShape = new Trimesh(vertices, indices);
 */
function Trimesh(vertices, indices) {
    Shape.call(this, {
        type: Shape.types.TRIMESH
    });

    /**
     * @property vertices
     * @type {Array}
     */
    this.vertices = new Float32Array(vertices);

    /**
     * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
     * @property indices
     * @type {Array}
     */
    this.indices = new Int16Array(indices);

    /**
     * The normals data.
     * @property normals
     * @type {Array}
     */
    this.normals = new Float32Array(indices.length);

    /**
     * The local AABB of the mesh.
     * @property aabb
     * @type {Array}
     */
    this.aabb = new AABB();

    /**
     * References to vertex pairs, making up all unique edges in the trimesh.
     * @property {array} edges
     */
    this.edges = null;

    /**
     * Local scaling of the mesh. Use .setScale() to set it.
     * @property {Vec3} scale
     */
    this.scale = new Vec3(1, 1, 1);

    /**
     * The indexed triangles. Use .updateTree() to update it.
     * @property {Octree} tree
     */
    this.tree = new Octree();

    this.updateEdges();
    this.updateNormals();
    this.updateAABB();
    this.updateBoundingSphereRadius();
    this.updateTree();
}
Trimesh.prototype = new Shape();
Trimesh.prototype.constructor = Trimesh;

var computeNormals_n = new Vec3();

/**
 * @method updateTree
 */
Trimesh.prototype.updateTree = function(){
    var tree = this.tree;

    tree.reset();
    tree.aabb.copy(this.aabb);
    var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled
    tree.aabb.lowerBound.x *= 1 / scale.x;
    tree.aabb.lowerBound.y *= 1 / scale.y;
    tree.aabb.lowerBound.z *= 1 / scale.z;
    tree.aabb.upperBound.x *= 1 / scale.x;
    tree.aabb.upperBound.y *= 1 / scale.y;
    tree.aabb.upperBound.z *= 1 / scale.z;

    // Insert all triangles
    var triangleAABB = new AABB();
    var a = new Vec3();
    var b = new Vec3();
    var c = new Vec3();
    var points = [a, b, c];
    for (var i = 0; i < this.indices.length / 3; i++) {
        //this.getTriangleVertices(i, a, b, c);

        // Get unscaled triangle verts
        var i3 = i * 3;
        this._getUnscaledVertex(this.indices[i3], a);
        this._getUnscaledVertex(this.indices[i3 + 1], b);
        this._getUnscaledVertex(this.indices[i3 + 2], c);

        triangleAABB.setFromPoints(points);
        tree.insert(triangleAABB, i);
    }
    tree.removeEmptyNodes();
};

var unscaledAABB = new AABB();

/**
 * Get triangles in a local AABB from the trimesh.
 * @method getTrianglesInAABB
 * @param  {AABB} aabb
 * @param  {array} result An array of integers, referencing the queried triangles.
 */
Trimesh.prototype.getTrianglesInAABB = function(aabb, result){
    unscaledAABB.copy(aabb);

    // Scale it to local
    var scale = this.scale;
    var isx = scale.x;
    var isy = scale.y;
    var isz = scale.z;
    var l = unscaledAABB.lowerBound;
    var u = unscaledAABB.upperBound;
    l.x /= isx;
    l.y /= isy;
    l.z /= isz;
    u.x /= isx;
    u.y /= isy;
    u.z /= isz;

    return this.tree.aabbQuery(unscaledAABB, result);
};

/**
 * @method setScale
 * @param {Vec3} scale
 */
Trimesh.prototype.setScale = function(scale){
    var wasUniform = this.scale.x === this.scale.y === this.scale.z;
    var isUniform = scale.x === scale.y === scale.z;

    if(!(wasUniform && isUniform)){
        // Non-uniform scaling. Need to update normals.
        this.updateNormals();
    }
    this.scale.copy(scale);
    this.updateAABB();
    this.updateBoundingSphereRadius();
};

/**
 * Compute the normals of the faces. Will save in the .normals array.
 * @method updateNormals
 */
Trimesh.prototype.updateNormals = function(){
    var n = computeNormals_n;

    // Generate normals
    var normals = this.normals;
    for(var i=0; i < this.indices.length / 3; i++){
        var i3 = i * 3;

        var a = this.indices[i3],
            b = this.indices[i3 + 1],
            c = this.indices[i3 + 2];

        this.getVertex(a, va);
        this.getVertex(b, vb);
        this.getVertex(c, vc);

        Trimesh.computeNormal(vb, va, vc, n);

        normals[i3] = n.x;
        normals[i3 + 1] = n.y;
        normals[i3 + 2] = n.z;
    }
};

/**
 * Update the .edges property
 * @method updateEdges
 */
Trimesh.prototype.updateEdges = function(){
    var edges = {};
    var add = function(indexA, indexB){
        var key = a < b ? a + '_' + b : b + '_' + a;
        edges[key] = true;
    };
    for(var i=0; i < this.indices.length / 3; i++){
        var i3 = i * 3;
        var a = this.indices[i3],
            b = this.indices[i3 + 1],
            c = this.indices[i3 + 2];
        add(a,b);
        add(b,c);
        add(c,a);
    }
    var keys = Object.keys(edges);
    this.edges = new Int16Array(keys.length * 2);
    for (var i = 0; i < keys.length; i++) {
        var indices = keys[i].split('_');
        this.edges[2 * i] = parseInt(indices[0], 10);
        this.edges[2 * i + 1] = parseInt(indices[1], 10);
    }
};

/**
 * Get an edge vertex
 * @method getEdgeVertex
 * @param  {number} edgeIndex
 * @param  {number} firstOrSecond 0 or 1, depending on which one of the vertices you need.
 * @param  {Vec3} vertexStore Where to store the result
 */
Trimesh.prototype.getEdgeVertex = function(edgeIndex, firstOrSecond, vertexStore){
    var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
    this.getVertex(vertexIndex, vertexStore);
};

var getEdgeVector_va = new Vec3();
var getEdgeVector_vb = new Vec3();

/**
 * Get a vector along an edge.
 * @method getEdgeVector
 * @param  {number} edgeIndex
 * @param  {Vec3} vectorStore
 */
Trimesh.prototype.getEdgeVector = function(edgeIndex, vectorStore){
    var va = getEdgeVector_va;
    var vb = getEdgeVector_vb;
    this.getEdgeVertex(edgeIndex, 0, va);
    this.getEdgeVertex(edgeIndex, 1, vb);
    vb.vsub(va, vectorStore);
};

/**
 * Get face normal given 3 vertices
 * @static
 * @method computeNormal
 * @param {Vec3} va
 * @param {Vec3} vb
 * @param {Vec3} vc
 * @param {Vec3} target
 */
var cb = new Vec3();
var ab = new Vec3();
Trimesh.computeNormal = function ( va, vb, vc, target ) {
    vb.vsub(va,ab);
    vc.vsub(vb,cb);
    cb.cross(ab,target);
    if ( !target.isZero() ) {
        target.normalize();
    }
};

var va = new Vec3();
var vb = new Vec3();
var vc = new Vec3();

/**
 * Get vertex i.
 * @method getVertex
 * @param  {number} i
 * @param  {Vec3} out
 * @return {Vec3} The "out" vector object
 */
Trimesh.prototype.getVertex = function(i, out){
    var scale = this.scale;
    this._getUnscaledVertex(i, out);
    out.x *= scale.x;
    out.y *= scale.y;
    out.z *= scale.z;
    return out;
};

/**
 * Get raw vertex i
 * @private
 * @method _getUnscaledVertex
 * @param  {number} i
 * @param  {Vec3} out
 * @return {Vec3} The "out" vector object
 */
Trimesh.prototype._getUnscaledVertex = function(i, out){
    var i3 = i * 3;
    var vertices = this.vertices;
    return out.set(
        vertices[i3],
        vertices[i3 + 1],
        vertices[i3 + 2]
    );
};

/**
 * Get a vertex from the trimesh,transformed by the given position and quaternion.
 * @method getWorldVertex
 * @param  {number} i
 * @param  {Vec3} pos
 * @param  {Quaternion} quat
 * @param  {Vec3} out
 * @return {Vec3} The "out" vector object
 */
Trimesh.prototype.getWorldVertex = function(i, pos, quat, out){
    this.getVertex(i, out);
    Transform.pointToWorldFrame(pos, quat, out, out);
    return out;
};

/**
 * Get the three vertices for triangle i.
 * @method getTriangleVertices
 * @param  {number} i
 * @param  {Vec3} a
 * @param  {Vec3} b
 * @param  {Vec3} c
 */
Trimesh.prototype.getTriangleVertices = function(i, a, b, c){
    var i3 = i * 3;
    this.getVertex(this.indices[i3], a);
    this.getVertex(this.indices[i3 + 1], b);
    this.getVertex(this.indices[i3 + 2], c);
};

/**
 * Compute the normal of triangle i.
 * @method getNormal
 * @param  {Number} i
 * @param  {Vec3} target
 * @return {Vec3} The "target" vector object
 */
Trimesh.prototype.getNormal = function(i, target){
    var i3 = i * 3;
    return target.set(
        this.normals[i3],
        this.normals[i3 + 1],
        this.normals[i3 + 2]
    );
};

var cli_aabb = new AABB();

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 * @return {Vec3} The "target" vector object
 */
Trimesh.prototype.calculateLocalInertia = function(mass,target){
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    this.computeLocalAABB(cli_aabb);
    var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x,
        y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y,
        z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
    return target.set(
        1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z ),
        1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z ),
        1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x )
    );
};

var computeLocalAABB_worldVert = new Vec3();

/**
 * Compute the local AABB for the trimesh
 * @method computeLocalAABB
 * @param  {AABB} aabb
 */
Trimesh.prototype.computeLocalAABB = function(aabb){
    var l = aabb.lowerBound,
        u = aabb.upperBound,
        n = this.vertices.length,
        vertices = this.vertices,
        v = computeLocalAABB_worldVert;

    this.getVertex(0, v);
    l.copy(v);
    u.copy(v);

    for(var i=0; i !== n; i++){
        this.getVertex(i, v);

        if(v.x < l.x){
            l.x = v.x;
        } else if(v.x > u.x){
            u.x = v.x;
        }

        if(v.y < l.y){
            l.y = v.y;
        } else if(v.y > u.y){
            u.y = v.y;
        }

        if(v.z < l.z){
            l.z = v.z;
        } else if(v.z > u.z){
            u.z = v.z;
        }
    }
};


/**
 * Update the .aabb property
 * @method updateAABB
 */
Trimesh.prototype.updateAABB = function(){
    this.computeLocalAABB(this.aabb);
};

/**
 * Will update the .boundingSphereRadius property
 * @method updateBoundingSphereRadius
 */
Trimesh.prototype.updateBoundingSphereRadius = function(){
    // Assume points are distributed with local (0,0,0) as center
    var max2 = 0;
    var vertices = this.vertices;
    var v = new Vec3();
    for(var i=0, N=vertices.length / 3; i !== N; i++) {
        this.getVertex(i, v);
        var norm2 = v.norm2();
        if(norm2 > max2){
            max2 = norm2;
        }
    }
    this.boundingSphereRadius = Math.sqrt(max2);
};

var tempWorldVertex = new Vec3();
var calculateWorldAABB_frame = new Transform();
var calculateWorldAABB_aabb = new AABB();

/**
 * @method calculateWorldAABB
 * @param {Vec3}        pos
 * @param {Quaternion}  quat
 * @param {Vec3}        min
 * @param {Vec3}        max
 */
Trimesh.prototype.calculateWorldAABB = function(pos,quat,min,max){
    /*
    var n = this.vertices.length / 3,
        verts = this.vertices;
    var minx,miny,minz,maxx,maxy,maxz;

    var v = tempWorldVertex;
    for(var i=0; i<n; i++){
        this.getVertex(i, v);
        quat.vmult(v, v);
        pos.vadd(v, v);
        if (v.x < minx || minx===undefined){
            minx = v.x;
        } else if(v.x > maxx || maxx===undefined){
            maxx = v.x;
        }

        if (v.y < miny || miny===undefined){
            miny = v.y;
        } else if(v.y > maxy || maxy===undefined){
            maxy = v.y;
        }

        if (v.z < minz || minz===undefined){
            minz = v.z;
        } else if(v.z > maxz || maxz===undefined){
            maxz = v.z;
        }
    }
    min.set(minx,miny,minz);
    max.set(maxx,maxy,maxz);
    */

    // Faster approximation using local AABB
    var frame = calculateWorldAABB_frame;
    var result = calculateWorldAABB_aabb;
    frame.position = pos;
    frame.quaternion = quat;
    this.aabb.toWorldFrame(frame, result);
    min.copy(result.lowerBound);
    max.copy(result.upperBound);
};

/**
 * Get approximate volume
 * @method volume
 * @return {Number}
 */
Trimesh.prototype.volume = function(){
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
};

/**
 * Create a Trimesh instance, shaped as a torus.
 * @static
 * @method createTorus
 * @param  {number} [radius=1]
 * @param  {number} [tube=0.5]
 * @param  {number} [radialSegments=8]
 * @param  {number} [tubularSegments=6]
 * @param  {number} [arc=6.283185307179586]
 * @return {Trimesh} A torus
 */
Trimesh.createTorus = function (radius, tube, radialSegments, tubularSegments, arc) {
    radius = radius || 1;
    tube = tube || 0.5;
    radialSegments = radialSegments || 8;
    tubularSegments = tubularSegments || 6;
    arc = arc || Math.PI * 2;

    var vertices = [];
    var indices = [];

    for ( var j = 0; j <= radialSegments; j ++ ) {
        for ( var i = 0; i <= tubularSegments; i ++ ) {
            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;

            var x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
            var y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
            var z = tube * Math.sin( v );

            vertices.push( x, y, z );
        }
    }

    for ( var j = 1; j <= radialSegments; j ++ ) {
        for ( var i = 1; i <= tubularSegments; i ++ ) {
            var a = ( tubularSegments + 1 ) * j + i - 1;
            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
            var d = ( tubularSegments + 1 ) * j + i;

            indices.push(a, b, d);
            indices.push(b, c, d);
        }
    }

    return new Trimesh(vertices, indices);
};

},{"../collision/AABB":3,"../math/Quaternion":29,"../math/Transform":30,"../math/Vec3":31,"../utils/Octree":51,"./Shape":44}],47:[function(require,module,exports){
module.exports = GSSolver;

var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Solver = require('./Solver');

/**
 * Constraint equation Gauss-Seidel solver.
 * @class GSSolver
 * @constructor
 * @todo The spook parameters should be specified for each constraint, not globally.
 * @author schteppe / https://github.com/schteppe
 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
 * @extends Solver
 */
function GSSolver(){
    Solver.call(this);

    /**
     * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
     * @property iterations
     * @type {Number}
     * @todo write more about solver and iterations in the wiki
     */
    this.iterations = 10;

    /**
     * When tolerance is reached, the system is assumed to be converged.
     * @property tolerance
     * @type {Number}
     */
    this.tolerance = 1e-7;
}
GSSolver.prototype = new Solver();

var GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.
var GSSolver_solve_invCs = [];
var GSSolver_solve_Bs = [];
GSSolver.prototype.solve = function(dt,world){
    var iter = 0,
        maxIter = this.iterations,
        tolSquared = this.tolerance*this.tolerance,
        equations = this.equations,
        Neq = equations.length,
        bodies = world.bodies,
        Nbodies = bodies.length,
        h = dt,
        q, B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj;

    // Update solve mass
    if(Neq !== 0){
        for(var i=0; i!==Nbodies; i++){
            bodies[i].updateSolveMassProperties();
        }
    }

    // Things that does not change during iteration can be computed once
    var invCs = GSSolver_solve_invCs,
        Bs = GSSolver_solve_Bs,
        lambda = GSSolver_solve_lambda;
    invCs.length = Neq;
    Bs.length = Neq;
    lambda.length = Neq;
    for(var i=0; i!==Neq; i++){
        var c = equations[i];
        lambda[i] = 0.0;
        Bs[i] = c.computeB(h);
        invCs[i] = 1.0 / c.computeC();
    }

    if(Neq !== 0){

        // Reset vlambda
        for(var i=0; i!==Nbodies; i++){
            var b=bodies[i],
                vlambda=b.vlambda,
                wlambda=b.wlambda;
            vlambda.set(0,0,0);
            wlambda.set(0,0,0);
        }

        // Iterate over equations
        for(iter=0; iter!==maxIter; iter++){

            // Accumulate the total error for each iteration.
            deltalambdaTot = 0.0;

            for(var j=0; j!==Neq; j++){

                var c = equations[j];

                // Compute iteration
                B = Bs[j];
                invC = invCs[j];
                lambdaj = lambda[j];
                GWlambda = c.computeGWlambda();
                deltalambda = invC * ( B - GWlambda - c.eps * lambdaj );

                // Clamp if we are not within the min/max interval
                if(lambdaj + deltalambda < c.minForce){
                    deltalambda = c.minForce - lambdaj;
                } else if(lambdaj + deltalambda > c.maxForce){
                    deltalambda = c.maxForce - lambdaj;
                }
                lambda[j] += deltalambda;

                deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

                c.addToWlambda(deltalambda);
            }

            // If the total error is small enough - stop iterate
            if(deltalambdaTot*deltalambdaTot < tolSquared){
                break;
            }
        }

        // Add result to velocity
        for(var i=0; i!==Nbodies; i++){
            var b=bodies[i],
                v=b.velocity,
                w=b.angularVelocity;

            b.vlambda.vmul(b.linearFactor, b.vlambda);
            v.vadd(b.vlambda, v);

            b.wlambda.vmul(b.angularFactor, b.wlambda);
            w.vadd(b.wlambda, w);
        }

        // Set the .multiplier property of each equation
        var l = equations.length;
        var invDt = 1 / h;
        while(l--){
            equations[l].multiplier = lambda[l] * invDt;
        }
    }

    return iter;
};

},{"../math/Quaternion":29,"../math/Vec3":31,"./Solver":48}],48:[function(require,module,exports){
module.exports = Solver;

/**
 * Constraint equation solver base class.
 * @class Solver
 * @constructor
 * @author schteppe / https://github.com/schteppe
 */
function Solver(){
    /**
     * All equations to be solved
     * @property {Array} equations
     */
    this.equations = [];
}

/**
 * Should be implemented in subclasses!
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
Solver.prototype.solve = function(dt,world){
    // Should return the number of iterations done!
    return 0;
};

/**
 * Add an equation
 * @method addEquation
 * @param {Equation} eq
 */
Solver.prototype.addEquation = function(eq){
    if (eq.enabled) {
        this.equations.push(eq);
    }
};

/**
 * Remove an equation
 * @method removeEquation
 * @param {Equation} eq
 */
Solver.prototype.removeEquation = function(eq){
    var eqs = this.equations;
    var i = eqs.indexOf(eq);
    if(i !== -1){
        eqs.splice(i,1);
    }
};

/**
 * Add all equations
 * @method removeAllEquations
 */
Solver.prototype.removeAllEquations = function(){
    this.equations.length = 0;
};


},{}],49:[function(require,module,exports){
module.exports = SplitSolver;

var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Solver = require('./Solver');
var Body = require('../objects/Body');

/**
 * Splits the equations into islands and solves them independently. Can improve performance.
 * @class SplitSolver
 * @constructor
 * @extends Solver
 * @param {Solver} subsolver
 */
function SplitSolver(subsolver){
    Solver.call(this);
    this.iterations = 10;
    this.tolerance = 1e-7;
    this.subsolver = subsolver;
    this.nodes = [];
    this.nodePool = [];

    // Create needed nodes, reuse if possible
    while(this.nodePool.length < 128){
        this.nodePool.push(this.createNode());
    }
}
SplitSolver.prototype = new Solver();

// Returns the number of subsystems
var SplitSolver_solve_nodes = []; // All allocated node objects
var SplitSolver_solve_nodePool = []; // All allocated node objects
var SplitSolver_solve_eqs = [];   // Temp array
var SplitSolver_solve_bds = [];   // Temp array
var SplitSolver_solve_dummyWorld = {bodies:[]}; // Temp object

var STATIC = Body.STATIC;
function getUnvisitedNode(nodes){
    var Nnodes = nodes.length;
    for(var i=0; i!==Nnodes; i++){
        var node = nodes[i];
        if(!node.visited && !(node.body.type & STATIC)){
            return node;
        }
    }
    return false;
}

var queue = [];
function bfs(root,visitFunc,bds,eqs){
    queue.push(root);
    root.visited = true;
    visitFunc(root,bds,eqs);
    while(queue.length) {
        var node = queue.pop();
        // Loop over unvisited child nodes
        var child;
        while((child = getUnvisitedNode(node.children))) {
            child.visited = true;
            visitFunc(child,bds,eqs);
            queue.push(child);
        }
    }
}

function visitFunc(node,bds,eqs){
    bds.push(node.body);
    var Neqs = node.eqs.length;
    for(var i=0; i!==Neqs; i++){
        var eq = node.eqs[i];
        if(eqs.indexOf(eq) === -1){
            eqs.push(eq);
        }
    }
}

SplitSolver.prototype.createNode = function(){
    return { body:null, children:[], eqs:[], visited:false };
};

/**
 * Solve the subsystems
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
SplitSolver.prototype.solve = function(dt,world){
    var nodes=SplitSolver_solve_nodes,
        nodePool=this.nodePool,
        bodies=world.bodies,
        equations=this.equations,
        Neq=equations.length,
        Nbodies=bodies.length,
        subsolver=this.subsolver;

    // Create needed nodes, reuse if possible
    while(nodePool.length < Nbodies){
        nodePool.push(this.createNode());
    }
    nodes.length = Nbodies;
    for (var i = 0; i < Nbodies; i++) {
        nodes[i] = nodePool[i];
    }

    // Reset node values
    for(var i=0; i!==Nbodies; i++){
        var node = nodes[i];
        node.body = bodies[i];
        node.children.length = 0;
        node.eqs.length = 0;
        node.visited = false;
    }
    for(var k=0; k!==Neq; k++){
        var eq=equations[k],
            i=bodies.indexOf(eq.bi),
            j=bodies.indexOf(eq.bj),
            ni=nodes[i],
            nj=nodes[j];
        ni.children.push(nj);
        ni.eqs.push(eq);
        nj.children.push(ni);
        nj.eqs.push(eq);
    }

    var child, n=0, eqs=SplitSolver_solve_eqs;

    subsolver.tolerance = this.tolerance;
    subsolver.iterations = this.iterations;

    var dummyWorld = SplitSolver_solve_dummyWorld;
    while((child = getUnvisitedNode(nodes))){
        eqs.length = 0;
        dummyWorld.bodies.length = 0;
        bfs(child, visitFunc, dummyWorld.bodies, eqs);

        var Neqs = eqs.length;

        eqs = eqs.sort(sortById);

        for(var i=0; i!==Neqs; i++){
            subsolver.addEquation(eqs[i]);
        }

        var iter = subsolver.solve(dt,dummyWorld);
        subsolver.removeAllEquations();
        n++;
    }

    return n;
};

function sortById(a, b){
    return b.id - a.id;
}
},{"../math/Quaternion":29,"../math/Vec3":31,"../objects/Body":32,"./Solver":48}],50:[function(require,module,exports){
/**
 * Base class for objects that dispatches events.
 * @class EventTarget
 * @constructor
 */
var EventTarget = function () {

};

module.exports = EventTarget;

EventTarget.prototype = {
    constructor: EventTarget,

    /**
     * Add an event listener
     * @method addEventListener
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventTarget} The self object, for chainability.
     */
    addEventListener: function ( type, listener ) {
        if ( this._listeners === undefined ){ this._listeners = {}; }
        var listeners = this._listeners;
        if ( listeners[ type ] === undefined ) {
            listeners[ type ] = [];
        }
        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
            listeners[ type ].push( listener );
        }
        return this;
    },

    /**
     * Check if an event listener is added
     * @method hasEventListener
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    hasEventListener: function ( type, listener ) {
        if ( this._listeners === undefined ){ return false; }
        var listeners = this._listeners;
        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
            return true;
        }
        return false;
    },

    /**
     * Check if any event listener of the given type is added
     * @method hasAnyEventListener
     * @param  {String} type
     * @return {Boolean}
     */
    hasAnyEventListener: function ( type ) {
        if ( this._listeners === undefined ){ return false; }
        var listeners = this._listeners;
        return ( listeners[ type ] !== undefined );
    },

    /**
     * Remove an event listener
     * @method removeEventListener
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventTarget} The self object, for chainability.
     */
    removeEventListener: function ( type, listener ) {
        if ( this._listeners === undefined ){ return this; }
        var listeners = this._listeners;
        if ( listeners[type] === undefined ){ return this; }
        var index = listeners[ type ].indexOf( listener );
        if ( index !== - 1 ) {
            listeners[ type ].splice( index, 1 );
        }
        return this;
    },

    /**
     * Emit an event.
     * @method dispatchEvent
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventTarget} The self object, for chainability.
     */
    dispatchEvent: function ( event ) {
        if ( this._listeners === undefined ){ return this; }
        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];
        if ( listenerArray !== undefined ) {
            event.target = this;
            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
                listenerArray[ i ].call( this, event );
            }
        }
        return this;
    }
};

},{}],51:[function(require,module,exports){
var AABB = require('../collision/AABB');
var Vec3 = require('../math/Vec3');

module.exports = Octree;

/**
 * @class OctreeNode
 * @param {object} [options]
 * @param {Octree} [options.root]
 * @param {AABB} [options.aabb]
 */
function OctreeNode(options){
    options = options || {};

    /**
     * The root node
     * @property {OctreeNode} root
     */
    this.root = options.root || null;

    /**
     * Boundary of this node
     * @property {AABB} aabb
     */
    this.aabb = options.aabb ? options.aabb.clone() : new AABB();

    /**
     * Contained data at the current node level.
     * @property {Array} data
     */
    this.data = [];

    /**
     * Children to this node
     * @property {Array} children
     */
    this.children = [];
}

/**
 * @class Octree
 * @param {AABB} aabb The total AABB of the tree
 * @param {object} [options]
 * @param {number} [options.maxDepth=8]
 * @extends OctreeNode
 */
function Octree(aabb, options){
    options = options || {};
    options.root = null;
    options.aabb = aabb;
    OctreeNode.call(this, options);

    /**
     * Maximum subdivision depth
     * @property {number} maxDepth
     */
    this.maxDepth = typeof(options.maxDepth) !== 'undefined' ? options.maxDepth : 8;
}
Octree.prototype = new OctreeNode();

OctreeNode.prototype.reset = function(aabb, options){
    this.children.length = this.data.length = 0;
};

/**
 * Insert data into this node
 * @method insert
 * @param  {AABB} aabb
 * @param  {object} elementData
 * @return {boolean} True if successful, otherwise false
 */
OctreeNode.prototype.insert = function(aabb, elementData, level){
    var nodeData = this.data;
    level = level || 0;

    // Ignore objects that do not belong in this node
    if (!this.aabb.contains(aabb)){
        return false; // object cannot be added
    }

    var children = this.children;

    if(level < (this.maxDepth || this.root.maxDepth)){
        // Subdivide if there are no children yet
        var subdivided = false;
        if (!children.length){
            this.subdivide();
            subdivided = true;
        }

        // add to whichever node will accept it
        for (var i = 0; i !== 8; i++) {
            if (children[i].insert(aabb, elementData, level + 1)){
                return true;
            }
        }

        if(subdivided){
            // No children accepted! Might as well just remove em since they contain none
            children.length = 0;
        }
    }

    // Too deep, or children didnt want it. add it in current node
    nodeData.push(elementData);

    return true;
};

var halfDiagonal = new Vec3();

/**
 * Create 8 equally sized children nodes and put them in the .children array.
 * @method subdivide
 */
OctreeNode.prototype.subdivide = function() {
    var aabb = this.aabb;
    var l = aabb.lowerBound;
    var u = aabb.upperBound;

    var children = this.children;

    children.push(
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,0) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,0) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,0) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,0) }) })
    );

    u.vsub(l, halfDiagonal);
    halfDiagonal.scale(0.5, halfDiagonal);

    var root = this.root || this;

    for (var i = 0; i !== 8; i++) {
        var child = children[i];

        // Set current node as root
        child.root = root;

        // Compute bounds
        var lowerBound = child.aabb.lowerBound;
        lowerBound.x *= halfDiagonal.x;
        lowerBound.y *= halfDiagonal.y;
        lowerBound.z *= halfDiagonal.z;

        lowerBound.vadd(l, lowerBound);

        // Upper bound is always lower bound + halfDiagonal
        lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
    }
};

/**
 * Get all data, potentially within an AABB
 * @method aabbQuery
 * @param  {AABB} aabb
 * @param  {array} result
 * @return {array} The "result" object
 */
OctreeNode.prototype.aabbQuery = function(aabb, result) {

    var nodeData = this.data;

    // abort if the range does not intersect this node
    // if (!this.aabb.overlaps(aabb)){
    //     return result;
    // }

    // Add objects at this level
    // Array.prototype.push.apply(result, nodeData);

    // Add child data
    // @todo unwrap recursion into a queue / loop, that's faster in JS
    var children = this.children;


    // for (var i = 0, N = this.children.length; i !== N; i++) {
    //     children[i].aabbQuery(aabb, result);
    // }

    var queue = [this];
    while (queue.length) {
        var node = queue.pop();
        if (node.aabb.overlaps(aabb)){
            Array.prototype.push.apply(result, node.data);
        }
        Array.prototype.push.apply(queue, node.children);
    }

    return result;
};

var tmpAABB = new AABB();

/**
 * Get all data, potentially intersected by a ray.
 * @method rayQuery
 * @param  {Ray} ray
 * @param  {Transform} treeTransform
 * @param  {array} result
 * @return {array} The "result" object
 */
OctreeNode.prototype.rayQuery = function(ray, treeTransform, result) {

    // Use aabb query for now.
    // @todo implement real ray query which needs less lookups
    ray.getAABB(tmpAABB);
    tmpAABB.toLocalFrame(treeTransform, tmpAABB);
    this.aabbQuery(tmpAABB, result);

    return result;
};

/**
 * @method removeEmptyNodes
 */
OctreeNode.prototype.removeEmptyNodes = function() {
    var queue = [this];
    while (queue.length) {
        var node = queue.pop();
        for (var i = node.children.length - 1; i >= 0; i--) {
            if(!node.children[i].data.length){
                node.children.splice(i, 1);
            }
        }
        Array.prototype.push.apply(queue, node.children);
    }
};

},{"../collision/AABB":3,"../math/Vec3":31}],52:[function(require,module,exports){
module.exports = Pool;

/**
 * For pooling objects that can be reused.
 * @class Pool
 * @constructor
 */
function Pool(){
    /**
     * The pooled objects
     * @property {Array} objects
     */
    this.objects = [];

    /**
     * Constructor of the objects
     * @property {mixed} type
     */
    this.type = Object;
}

/**
 * Release an object after use
 * @method release
 * @param {Object} obj
 */
Pool.prototype.release = function(){
    var Nargs = arguments.length;
    for(var i=0; i!==Nargs; i++){
        this.objects.push(arguments[i]);
    }
    return this;
};

/**
 * Get an object
 * @method get
 * @return {mixed}
 */
Pool.prototype.get = function(){
    if(this.objects.length===0){
        return this.constructObject();
    } else {
        return this.objects.pop();
    }
};

/**
 * Construct an object. Should be implmented in each subclass.
 * @method constructObject
 * @return {mixed}
 */
Pool.prototype.constructObject = function(){
    throw new Error("constructObject() not implemented in this Pool subclass yet!");
};

/**
 * @method resize
 * @param {number} size
 * @return {Pool} Self, for chaining
 */
Pool.prototype.resize = function (size) {
    var objects = this.objects;

    while (objects.length > size) {
        objects.pop();
    }

    while (objects.length < size) {
        objects.push(this.constructObject());
    }

    return this;
};


},{}],53:[function(require,module,exports){
module.exports = TupleDictionary;

/**
 * @class TupleDictionary
 * @constructor
 */
function TupleDictionary() {

    /**
     * The data storage
     * @property data
     * @type {Object}
     */
    this.data = { keys:[] };
}

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
TupleDictionary.prototype.get = function(i, j) {
    if (i > j) {
        // swap
        var temp = j;
        j = i;
        i = temp;
    }
    return this.data[i+'-'+j];
};

/**
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
TupleDictionary.prototype.set = function(i, j, value) {
    if (i > j) {
        var temp = j;
        j = i;
        i = temp;
    }
    var key = i+'-'+j;

    // Check if key already exists
    if(!this.get(i,j)){
        this.data.keys.push(key);
    }

    this.data[key] = value;
};

/**
 * @method reset
 */
TupleDictionary.prototype.reset = function() {
    var data = this.data,
        keys = data.keys;
    while(keys.length > 0){
        var key = keys.pop();
        delete data[key];
    }
};

},{}],54:[function(require,module,exports){
function Utils(){}

module.exports = Utils;

/**
 * Extend an options object with default values.
 * @static
 * @method defaults
 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
 * @param  {object} defaults An object containing default values.
 * @return {object} The modified options object.
 */
Utils.defaults = function(options, defaults){
    options = options || {};

    for(var key in defaults){
        if(!(key in options)){
            options[key] = defaults[key];
        }
    }

    return options;
};

},{}],55:[function(require,module,exports){
module.exports = Vec3Pool;

var Vec3 = require('../math/Vec3');
var Pool = require('./Pool');

/**
 * @class Vec3Pool
 * @constructor
 * @extends Pool
 */
function Vec3Pool(){
    Pool.call(this);
    this.type = Vec3;
}
Vec3Pool.prototype = new Pool();

/**
 * Construct a vector
 * @method constructObject
 * @return {Vec3}
 */
Vec3Pool.prototype.constructObject = function(){
    return new Vec3();
};

},{"../math/Vec3":31,"./Pool":52}],56:[function(require,module,exports){
module.exports = Narrowphase;

var AABB = require('../collision/AABB');
var Body = require('../objects/Body');
var Shape = require('../shapes/Shape');
var Ray = require('../collision/Ray');
var Vec3 = require('../math/Vec3');
var Transform = require('../math/Transform');
var ConvexPolyhedron = require('../shapes/ConvexPolyhedron');
var Quaternion = require('../math/Quaternion');
var Solver = require('../solver/Solver');
var Vec3Pool = require('../utils/Vec3Pool');
var ContactEquation = require('../equations/ContactEquation');
var FrictionEquation = require('../equations/FrictionEquation');

/**
 * Helper class for the World. Generates ContactEquations.
 * @class Narrowphase
 * @constructor
 * @todo Sphere-ConvexPolyhedron contacts
 * @todo Contact reduction
 * @todo  should move methods to prototype
 */
function Narrowphase(world){

    /**
     * Internal storage of pooled contact points.
     * @property {Array} contactPointPool
     */
    this.contactPointPool = [];

    this.frictionEquationPool = [];

    this.result = [];
    this.frictionResult = [];

    /**
     * Pooled vectors.
     * @property {Vec3Pool} v3pool
     */
    this.v3pool = new Vec3Pool();

    this.world = world;
    this.currentContactMaterial = null;

    /**
     * @property {Boolean} enableFrictionReduction
     */
    this.enableFrictionReduction = false;
}

/**
 * Make a contact object, by using the internal pool or creating a new one.
 * @method createContactEquation
 * @param {Body} bi
 * @param {Body} bj
 * @param {Shape} si
 * @param {Shape} sj
 * @param {Shape} overrideShapeA
 * @param {Shape} overrideShapeB
 * @return {ContactEquation}
 */
Narrowphase.prototype.createContactEquation = function(bi, bj, si, sj, overrideShapeA, overrideShapeB){
    var c;
    if(this.contactPointPool.length){
        c = this.contactPointPool.pop();
        c.bi = bi;
        c.bj = bj;
    } else {
        c = new ContactEquation(bi, bj);
    }

    c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

    var cm = this.currentContactMaterial;

    c.restitution = cm.restitution;

    c.setSpookParams(
        cm.contactEquationStiffness,
        cm.contactEquationRelaxation,
        this.world.dt
    );

    var matA = si.material || bi.material;
    var matB = sj.material || bj.material;
    if(matA && matB && matA.restitution >= 0 && matB.restitution >= 0){
        c.restitution = matA.restitution * matB.restitution;
    }

    c.si = overrideShapeA || si;
    c.sj = overrideShapeB || sj;

    return c;
};

Narrowphase.prototype.createFrictionEquationsFromContact = function(contactEquation, outArray){
    var bodyA = contactEquation.bi;
    var bodyB = contactEquation.bj;
    var shapeA = contactEquation.si;
    var shapeB = contactEquation.sj;

    var world = this.world;
    var cm = this.currentContactMaterial;

    // If friction or restitution were specified in the material, use them
    var friction = cm.friction;
    var matA = shapeA.material || bodyA.material;
    var matB = shapeB.material || bodyB.material;
    if(matA && matB && matA.friction >= 0 && matB.friction >= 0){
        friction = matA.friction * matB.friction;
    }

    if(friction > 0){

        // Create 2 tangent equations
        var mug = friction * world.gravity.length();
        var reducedMass = (bodyA.invMass + bodyB.invMass);
        if(reducedMass > 0){
            reducedMass = 1/reducedMass;
        }
        var pool = this.frictionEquationPool;
        var c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);
        var c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);

        c1.bi = c2.bi = bodyA;
        c1.bj = c2.bj = bodyB;
        c1.minForce = c2.minForce = -mug*reducedMass;
        c1.maxForce = c2.maxForce = mug*reducedMass;

        // Copy over the relative vectors
        c1.ri.copy(contactEquation.ri);
        c1.rj.copy(contactEquation.rj);
        c2.ri.copy(contactEquation.ri);
        c2.rj.copy(contactEquation.rj);

        // Construct tangents
        contactEquation.ni.tangents(c1.t, c2.t);

        // Set spook params
        c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
        c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);

        c1.enabled = c2.enabled = contactEquation.enabled;

        outArray.push(c1, c2);

        return true;
    }

    return false;
};

var averageNormal = new Vec3();
var averageContactPointA = new Vec3();
var averageContactPointB = new Vec3();

// Take the average N latest contact point on the plane.
Narrowphase.prototype.createFrictionFromAverage = function(numContacts){
    // The last contactEquation
    var c = this.result[this.result.length - 1];

    // Create the result: two "average" friction equations
    if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
        return;
    }

    var f1 = this.frictionResult[this.frictionResult.length - 2];
    var f2 = this.frictionResult[this.frictionResult.length - 1];

    averageNormal.setZero();
    averageContactPointA.setZero();
    averageContactPointB.setZero();

    var bodyA = c.bi;
    var bodyB = c.bj;
    for(var i=0; i!==numContacts; i++){
        c = this.result[this.result.length - 1 - i];
        if(c.bodyA !== bodyA){
            averageNormal.vadd(c.ni, averageNormal);
            averageContactPointA.vadd(c.ri, averageContactPointA);
            averageContactPointB.vadd(c.rj, averageContactPointB);
        } else {
            averageNormal.vsub(c.ni, averageNormal);
            averageContactPointA.vadd(c.rj, averageContactPointA);
            averageContactPointB.vadd(c.ri, averageContactPointB);
        }
    }

    var invNumContacts = 1 / numContacts;
    averageContactPointA.scale(invNumContacts, f1.ri);
    averageContactPointB.scale(invNumContacts, f1.rj);
    f2.ri.copy(f1.ri); // Should be the same
    f2.rj.copy(f1.rj);
    averageNormal.normalize();
    averageNormal.tangents(f1.t, f2.t);
    // return eq;
};


var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();
var tmpQuat1 = new Quaternion();
var tmpQuat2 = new Quaternion();

/**
 * Generate all contacts between a list of body pairs
 * @method getContacts
 * @param {array} p1 Array of body indices
 * @param {array} p2 Array of body indices
 * @param {World} world
 * @param {array} result Array to store generated contacts
 * @param {array} oldcontacts Optional. Array of reusable contact objects
 */
Narrowphase.prototype.getContacts = function(p1, p2, world, result, oldcontacts, frictionResult, frictionPool){
    // Save old contact objects
    this.contactPointPool = oldcontacts;
    this.frictionEquationPool = frictionPool;
    this.result = result;
    this.frictionResult = frictionResult;

    var qi = tmpQuat1;
    var qj = tmpQuat2;
    var xi = tmpVec1;
    var xj = tmpVec2;

    for(var k=0, N=p1.length; k!==N; k++){

        // Get current collision bodies
        var bi = p1[k],
            bj = p2[k];

        // Get contact material
        var bodyContactMaterial = null;
        if(bi.material && bj.material){
            bodyContactMaterial = world.getContactMaterial(bi.material,bj.material) || null;
        }

        var justTest = (
            (
                (bi.type & Body.KINEMATIC) && (bj.type & Body.STATIC)
            ) || (
                (bi.type & Body.STATIC) && (bj.type & Body.KINEMATIC)
            ) || (
                (bi.type & Body.KINEMATIC) && (bj.type & Body.KINEMATIC)
            )
        );

        for (var i = 0; i < bi.shapes.length; i++) {
            bi.quaternion.mult(bi.shapeOrientations[i], qi);
            bi.quaternion.vmult(bi.shapeOffsets[i], xi);
            xi.vadd(bi.position, xi);
            var si = bi.shapes[i];

            for (var j = 0; j < bj.shapes.length; j++) {

                // Compute world transform of shapes
                bj.quaternion.mult(bj.shapeOrientations[j], qj);
                bj.quaternion.vmult(bj.shapeOffsets[j], xj);
                xj.vadd(bj.position, xj);
                var sj = bj.shapes[j];

                if(!((si.collisionFilterMask & sj.collisionFilterGroup) && (sj.collisionFilterMask & si.collisionFilterGroup))){
                    continue;
                }

                if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
                    continue;
                }

                // Get collision material
                var shapeContactMaterial = null;
                if(si.material && sj.material){
                    shapeContactMaterial = world.getContactMaterial(si.material,sj.material) || null;
                }

                this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial;

                // Get contacts
                var resolver = this[si.type | sj.type];
                if(resolver){
                    var retval = false;
                    if (si.type < sj.type) {
                        retval = resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
                    } else {
                        retval = resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest);
                    }

                    if(retval && justTest){
                        // Register overlap
                        world.shapeOverlapKeeper.set(si.id, sj.id);
                        world.bodyOverlapKeeper.set(bi.id, bj.id);
                    }
                }
            }
        }
    }
};

var numWarnings = 0;
var maxWarnings = 10;

function warn(msg){
    if(numWarnings > maxWarnings){
        return;
    }

    numWarnings++;

    console.warn(msg);
}

Narrowphase.prototype[Shape.types.BOX | Shape.types.BOX] =
Narrowphase.prototype.boxBox = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){
    si.convexPolyhedronRepresentation.material = si.material;
    sj.convexPolyhedronRepresentation.material = sj.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    return this.convexConvex(si.convexPolyhedronRepresentation,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj,justTest);
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.boxConvex = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexConvex(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj,justTest);
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] =
Narrowphase.prototype.boxParticle = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexParticle(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj,justTest);
};

/**
 * @method sphereSphere
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE] =
Narrowphase.prototype.sphereSphere = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){
    if(justTest){
        return xi.distanceSquared(xj) < Math.pow(si.radius + sj.radius, 2);
    }

    // We will have only one contact in this case
    var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);

    // Contact normal
    xj.vsub(xi, r.ni);
    r.ni.normalize();

    // Contact point locations
    r.ri.copy(r.ni);
    r.rj.copy(r.ni);
    r.ri.mult(si.radius, r.ri);
    r.rj.mult(-sj.radius, r.rj);

    r.ri.vadd(xi, r.ri);
    r.ri.vsub(bi.position, r.ri);

    r.rj.vadd(xj, r.rj);
    r.rj.vsub(bj.position, r.rj);

    this.result.push(r);

    this.createFrictionEquationsFromContact(r, this.frictionResult);
};

/**
 * @method planeTrimesh
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
var planeTrimesh_normal = new Vec3();
var planeTrimesh_relpos = new Vec3();
var planeTrimesh_projected = new Vec3();
Narrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] =
Narrowphase.prototype.planeTrimesh = function(
    planeShape,
    trimeshShape,
    planePos,
    trimeshPos,
    planeQuat,
    trimeshQuat,
    planeBody,
    trimeshBody,
    rsi,
    rsj,
    justTest
){
    // Make contacts!
    var v = new Vec3();

    var normal = planeTrimesh_normal;
    normal.set(0,0,1);
    planeQuat.vmult(normal,normal); // Turn normal according to plane

    for(var i=0; i<trimeshShape.vertices.length / 3; i++){

        // Get world vertex from trimesh
        trimeshShape.getVertex(i, v);

        // Safe up
        var v2 = new Vec3();
        v2.copy(v);
        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);

        // Check plane side
        var relpos = planeTrimesh_relpos;
        v.vsub(planePos, relpos);
        var dot = normal.dot(relpos);

        if(dot <= 0.0){
            if(justTest){
                return true;
            }

            var r = this.createContactEquation(planeBody,trimeshBody,planeShape,trimeshShape,rsi,rsj);

            r.ni.copy(normal); // Contact normal is the plane normal

            // Get vertex position projected on plane
            var projected = planeTrimesh_projected;
            normal.scale(relpos.dot(normal), projected);
            v.vsub(projected,projected);

            // ri is the projected world position minus plane position
            r.ri.copy(projected);
            r.ri.vsub(planeBody.position, r.ri);

            r.rj.copy(v);
            r.rj.vsub(trimeshBody.position, r.rj);

            // Store result
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
    }
};

/**
 * @method sphereTrimesh
 * @param  {Shape}      sphereShape
 * @param  {Shape}      trimeshShape
 * @param  {Vec3}       spherePos
 * @param  {Vec3}       trimeshPos
 * @param  {Quaternion} sphereQuat
 * @param  {Quaternion} trimeshQuat
 * @param  {Body}       sphereBody
 * @param  {Body}       trimeshBody
 */
var sphereTrimesh_normal = new Vec3();
var sphereTrimesh_relpos = new Vec3();
var sphereTrimesh_projected = new Vec3();
var sphereTrimesh_v = new Vec3();
var sphereTrimesh_v2 = new Vec3();
var sphereTrimesh_edgeVertexA = new Vec3();
var sphereTrimesh_edgeVertexB = new Vec3();
var sphereTrimesh_edgeVector = new Vec3();
var sphereTrimesh_edgeVectorUnit = new Vec3();
var sphereTrimesh_localSpherePos = new Vec3();
var sphereTrimesh_tmp = new Vec3();
var sphereTrimesh_va = new Vec3();
var sphereTrimesh_vb = new Vec3();
var sphereTrimesh_vc = new Vec3();
var sphereTrimesh_localSphereAABB = new AABB();
var sphereTrimesh_triangles = [];
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] =
Narrowphase.prototype.sphereTrimesh = function (
    sphereShape,
    trimeshShape,
    spherePos,
    trimeshPos,
    sphereQuat,
    trimeshQuat,
    sphereBody,
    trimeshBody,
    rsi,
    rsj,
    justTest
) {

    var edgeVertexA = sphereTrimesh_edgeVertexA;
    var edgeVertexB = sphereTrimesh_edgeVertexB;
    var edgeVector = sphereTrimesh_edgeVector;
    var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
    var localSpherePos = sphereTrimesh_localSpherePos;
    var tmp = sphereTrimesh_tmp;
    var localSphereAABB = sphereTrimesh_localSphereAABB;
    var v2 = sphereTrimesh_v2;
    var relpos = sphereTrimesh_relpos;
    var triangles = sphereTrimesh_triangles;

    // Convert sphere position to local in the trimesh
    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos);

    // Get the aabb of the sphere locally in the trimesh
    var sphereRadius = sphereShape.radius;
    localSphereAABB.lowerBound.set(
        localSpherePos.x - sphereRadius,
        localSpherePos.y - sphereRadius,
        localSpherePos.z - sphereRadius
    );
    localSphereAABB.upperBound.set(
        localSpherePos.x + sphereRadius,
        localSpherePos.y + sphereRadius,
        localSpherePos.z + sphereRadius
    );

    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles);
    //for (var i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All

    // Vertices
    var v = sphereTrimesh_v;
    var radiusSquared = sphereShape.radius * sphereShape.radius;
    for(var i=0; i<triangles.length; i++){
        for (var j = 0; j < 3; j++) {

            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v);

            // Check vertex overlap in sphere
            v.vsub(localSpherePos, relpos);

            if(relpos.norm2() <= radiusSquared){

                // Safe up
                v2.copy(v);
                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);

                v.vsub(spherePos, relpos);

                if(justTest){
                    return true;
                }

                var r = this.createContactEquation(sphereBody,trimeshBody,sphereShape,trimeshShape,rsi,rsj);
                r.ni.copy(relpos);
                r.ni.normalize();

                // ri is the vector from sphere center to the sphere surface
                r.ri.copy(r.ni);
                r.ri.scale(sphereShape.radius, r.ri);
                r.ri.vadd(spherePos, r.ri);
                r.ri.vsub(sphereBody.position, r.ri);

                r.rj.copy(v);
                r.rj.vsub(trimeshBody.position, r.rj);

                // Store result
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
        }
    }

    // Check all edges
    for(var i=0; i<triangles.length; i++){
        for (var j = 0; j < 3; j++) {

            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + ((j+1)%3)], edgeVertexB);
            edgeVertexB.vsub(edgeVertexA, edgeVector);

            // Project sphere position to the edge
            localSpherePos.vsub(edgeVertexB, tmp);
            var positionAlongEdgeB = tmp.dot(edgeVector);

            localSpherePos.vsub(edgeVertexA, tmp);
            var positionAlongEdgeA = tmp.dot(edgeVector);

            if(positionAlongEdgeA > 0 && positionAlongEdgeB < 0){

                // Now check the orthogonal distance from edge to sphere center
                localSpherePos.vsub(edgeVertexA, tmp);

                edgeVectorUnit.copy(edgeVector);
                edgeVectorUnit.normalize();
                positionAlongEdgeA = tmp.dot(edgeVectorUnit);

                edgeVectorUnit.scale(positionAlongEdgeA, tmp);
                tmp.vadd(edgeVertexA, tmp);

                // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame
                var dist = tmp.distanceTo(localSpherePos);
                if(dist < sphereShape.radius){

                    if(justTest){
                        return true;
                    }

                    var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape,rsi,rsj);

                    tmp.vsub(localSpherePos, r.ni);
                    r.ni.normalize();
                    r.ni.scale(sphereShape.radius, r.ri);

                    Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
                    tmp.vsub(trimeshBody.position, r.rj);

                    Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                    Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);

                    this.result.push(r);
                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                }
            }
        }
    }

    // Triangle faces
    var va = sphereTrimesh_va;
    var vb = sphereTrimesh_vb;
    var vc = sphereTrimesh_vc;
    var normal = sphereTrimesh_normal;
    for(var i=0, N = triangles.length; i !== N; i++){
        trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
        trimeshShape.getNormal(triangles[i], normal);
        localSpherePos.vsub(va, tmp);
        var dist = tmp.dot(normal);
        normal.scale(dist, tmp);
        localSpherePos.vsub(tmp, tmp);

        // tmp is now the sphere position projected to the triangle plane
        dist = tmp.distanceTo(localSpherePos);
        if(Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius){
            if(justTest){
                return true;
            }
            var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape,rsi,rsj);

            tmp.vsub(localSpherePos, r.ni);
            r.ni.normalize();
            r.ni.scale(sphereShape.radius, r.ri);

            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
            tmp.vsub(trimeshBody.position, r.rj);

            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);

            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
    }

    triangles.length = 0;
};

var point_on_plane_to_sphere = new Vec3();
var plane_to_sphere_ortho = new Vec3();

/**
 * @method spherePlane
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] =
Narrowphase.prototype.spherePlane = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){
    // We will have one contact in this case
    var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);

    // Contact normal
    r.ni.set(0,0,1);
    qj.vmult(r.ni, r.ni);
    r.ni.negate(r.ni); // body i is the sphere, flip normal
    r.ni.normalize(); // Needed?

    // Vector from sphere center to contact point
    r.ni.mult(si.radius, r.ri);

    // Project down sphere on plane
    xi.vsub(xj, point_on_plane_to_sphere);
    r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,r.rj); // The sphere position projected to plane

    if(-point_on_plane_to_sphere.dot(r.ni) <= si.radius){

        if(justTest){
            return true;
        }

        // Make it relative to the body
        var ri = r.ri;
        var rj = r.rj;
        ri.vadd(xi, ri);
        ri.vsub(bi.position, ri);
        rj.vadd(xj, rj);
        rj.vsub(bj.position, rj);

        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
};

// See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html
var pointInPolygon_edge = new Vec3();
var pointInPolygon_edge_x_normal = new Vec3();
var pointInPolygon_vtp = new Vec3();
function pointInPolygon(verts, normal, p){
    var positiveResult = null;
    var N = verts.length;
    for(var i=0; i!==N; i++){
        var v = verts[i];

        // Get edge to the next vertex
        var edge = pointInPolygon_edge;
        verts[(i+1) % (N)].vsub(v,edge);

        // Get cross product between polygon normal and the edge
        var edge_x_normal = pointInPolygon_edge_x_normal;
        //var edge_x_normal = new Vec3();
        edge.cross(normal,edge_x_normal);

        // Get vector between point and current vertex
        var vertex_to_p = pointInPolygon_vtp;
        p.vsub(v,vertex_to_p);

        // This dot product determines which side of the edge the point is
        var r = edge_x_normal.dot(vertex_to_p);

        // If all such dot products have same sign, we are inside the polygon.
        if(positiveResult===null || (r>0 && positiveResult===true) || (r<=0 && positiveResult===false)){
            if(positiveResult===null){
                positiveResult = r>0;
            }
            continue;
        } else {
            return false; // Encountered some other sign. Exit.
        }
    }

    // If we got here, all dot products were of the same sign.
    return true;
}

var box_to_sphere = new Vec3();
var sphereBox_ns = new Vec3();
var sphereBox_ns1 = new Vec3();
var sphereBox_ns2 = new Vec3();
var sphereBox_sides = [new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3()];
var sphereBox_sphere_to_corner = new Vec3();
var sphereBox_side_ns = new Vec3();
var sphereBox_side_ns1 = new Vec3();
var sphereBox_side_ns2 = new Vec3();

/**
 * @method sphereBox
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] =
Narrowphase.prototype.sphereBox = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){
    var v3pool = this.v3pool;

    // we refer to the box as body j
    var sides = sphereBox_sides;
    xi.vsub(xj,box_to_sphere);
    sj.getSideNormals(sides,qj);
    var R =     si.radius;
    var penetrating_sides = [];

    // Check side (plane) intersections
    var found = false;

    // Store the resulting side penetration info
    var side_ns = sphereBox_side_ns;
    var side_ns1 = sphereBox_side_ns1;
    var side_ns2 = sphereBox_side_ns2;
    var side_h = null;
    var side_penetrations = 0;
    var side_dot1 = 0;
    var side_dot2 = 0;
    var side_distance = null;
    for(var idx=0,nsides=sides.length; idx!==nsides && found===false; idx++){
        // Get the plane side normal (ns)
        var ns = sphereBox_ns;
        ns.copy(sides[idx]);

        var h = ns.norm();
        ns.normalize();

        // The normal/distance dot product tells which side of the plane we are
        var dot = box_to_sphere.dot(ns);

        if(dot<h+R && dot>0){
            // Intersects plane. Now check the other two dimensions
            var ns1 = sphereBox_ns1;
            var ns2 = sphereBox_ns2;
            ns1.copy(sides[(idx+1)%3]);
            ns2.copy(sides[(idx+2)%3]);
            var h1 = ns1.norm();
            var h2 = ns2.norm();
            ns1.normalize();
            ns2.normalize();
            var dot1 = box_to_sphere.dot(ns1);
            var dot2 = box_to_sphere.dot(ns2);
            if(dot1<h1 && dot1>-h1 && dot2<h2 && dot2>-h2){
                var dist = Math.abs(dot-h-R);
                if(side_distance===null || dist < side_distance){
                    side_distance = dist;
                    side_dot1 = dot1;
                    side_dot2 = dot2;
                    side_h = h;
                    side_ns.copy(ns);
                    side_ns1.copy(ns1);
                    side_ns2.copy(ns2);
                    side_penetrations++;

                    if(justTest){
                        return true;
                    }
                }
            }
        }
    }
    if(side_penetrations){
        found = true;
        var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
        side_ns.mult(-R,r.ri); // Sphere r
        r.ni.copy(side_ns);
        r.ni.negate(r.ni); // Normal should be out of sphere
        side_ns.mult(side_h,side_ns);
        side_ns1.mult(side_dot1,side_ns1);
        side_ns.vadd(side_ns1,side_ns);
        side_ns2.mult(side_dot2,side_ns2);
        side_ns.vadd(side_ns2,r.rj);

        // Make relative to bodies
        r.ri.vadd(xi, r.ri);
        r.ri.vsub(bi.position, r.ri);
        r.rj.vadd(xj, r.rj);
        r.rj.vsub(bj.position, r.rj);

        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }

    // Check corners
    var rj = v3pool.get();
    var sphere_to_corner = sphereBox_sphere_to_corner;
    for(var j=0; j!==2 && !found; j++){
        for(var k=0; k!==2 && !found; k++){
            for(var l=0; l!==2 && !found; l++){
                rj.set(0,0,0);
                if(j){
                    rj.vadd(sides[0],rj);
                } else {
                    rj.vsub(sides[0],rj);
                }
                if(k){
                    rj.vadd(sides[1],rj);
                } else {
                    rj.vsub(sides[1],rj);
                }
                if(l){
                    rj.vadd(sides[2],rj);
                } else {
                    rj.vsub(sides[2],rj);
                }

                // World position of corner
                xj.vadd(rj,sphere_to_corner);
                sphere_to_corner.vsub(xi,sphere_to_corner);

                if(sphere_to_corner.norm2() < R*R){
                    if(justTest){
                        return true;
                    }
                    found = true;
                    var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
                    r.ri.copy(sphere_to_corner);
                    r.ri.normalize();
                    r.ni.copy(r.ri);
                    r.ri.mult(R,r.ri);
                    r.rj.copy(rj);

                    // Make relative to bodies
                    r.ri.vadd(xi, r.ri);
                    r.ri.vsub(bi.position, r.ri);
                    r.rj.vadd(xj, r.rj);
                    r.rj.vsub(bj.position, r.rj);

                    this.result.push(r);
                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                }
            }
        }
    }
    v3pool.release(rj);
    rj = null;

    // Check edges
    var edgeTangent = v3pool.get();
    var edgeCenter = v3pool.get();
    var r = v3pool.get(); // r = edge center to sphere center
    var orthogonal = v3pool.get();
    var dist = v3pool.get();
    var Nsides = sides.length;
    for(var j=0; j!==Nsides && !found; j++){
        for(var k=0; k!==Nsides && !found; k++){
            if(j%3 !== k%3){
                // Get edge tangent
                sides[k].cross(sides[j],edgeTangent);
                edgeTangent.normalize();
                sides[j].vadd(sides[k], edgeCenter);
                r.copy(xi);
                r.vsub(edgeCenter,r);
                r.vsub(xj,r);
                var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction
                edgeTangent.mult(orthonorm,orthogonal); // Vector from edge center to sphere center in the tangent direction

                // Find the third side orthogonal to this one
                var l = 0;
                while(l===j%3 || l===k%3){
                    l++;
                }

                // vec from edge center to sphere projected to the plane orthogonal to the edge tangent
                dist.copy(xi);
                dist.vsub(orthogonal,dist);
                dist.vsub(edgeCenter,dist);
                dist.vsub(xj,dist);

                // Distances in tangent direction and distance in the plane orthogonal to it
                var tdist = Math.abs(orthonorm);
                var ndist = dist.norm();

                if(tdist < sides[l].norm() && ndist<R){
                    if(justTest){
                        return true;
                    }
                    found = true;
                    var res = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
                    edgeCenter.vadd(orthogonal,res.rj); // box rj
                    res.rj.copy(res.rj);
                    dist.negate(res.ni);
                    res.ni.normalize();

                    res.ri.copy(res.rj);
                    res.ri.vadd(xj,res.ri);
                    res.ri.vsub(xi,res.ri);
                    res.ri.normalize();
                    res.ri.mult(R,res.ri);

                    // Make relative to bodies
                    res.ri.vadd(xi, res.ri);
                    res.ri.vsub(bi.position, res.ri);
                    res.rj.vadd(xj, res.rj);
                    res.rj.vsub(bj.position, res.rj);

                    this.result.push(res);
                    this.createFrictionEquationsFromContact(res, this.frictionResult);
                }
            }
        }
    }
    v3pool.release(edgeTangent,edgeCenter,r,orthogonal,dist);
};

var convex_to_sphere = new Vec3();
var sphereConvex_edge = new Vec3();
var sphereConvex_edgeUnit = new Vec3();
var sphereConvex_sphereToCorner = new Vec3();
var sphereConvex_worldCorner = new Vec3();
var sphereConvex_worldNormal = new Vec3();
var sphereConvex_worldPoint = new Vec3();
var sphereConvex_worldSpherePointClosestToPlane = new Vec3();
var sphereConvex_penetrationVec = new Vec3();
var sphereConvex_sphereToWorldPoint = new Vec3();

/**
 * @method sphereConvex
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.sphereConvex = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){
    var v3pool = this.v3pool;
    xi.vsub(xj,convex_to_sphere);
    var normals = sj.faceNormals;
    var faces = sj.faces;
    var verts = sj.vertices;
    var R =     si.radius;
    var penetrating_sides = [];

    // if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){
    //     return;
    // }

    // Check corners
    for(var i=0; i!==verts.length; i++){
        var v = verts[i];

        // World position of corner
        var worldCorner = sphereConvex_worldCorner;
        qj.vmult(v,worldCorner);
        xj.vadd(worldCorner,worldCorner);
        var sphere_to_corner = sphereConvex_sphereToCorner;
        worldCorner.vsub(xi, sphere_to_corner);
        if(sphere_to_corner.norm2() < R * R){
            if(justTest){
                return true;
            }
            found = true;
            var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
            r.ri.copy(sphere_to_corner);
            r.ri.normalize();
            r.ni.copy(r.ri);
            r.ri.mult(R,r.ri);
            worldCorner.vsub(xj,r.rj);

            // Should be relative to the body.
            r.ri.vadd(xi, r.ri);
            r.ri.vsub(bi.position, r.ri);

            // Should be relative to the body.
            r.rj.vadd(xj, r.rj);
            r.rj.vsub(bj.position, r.rj);

            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
            return;
        }
    }

    // Check side (plane) intersections
    var found = false;
    for(var i=0, nfaces=faces.length; i!==nfaces && found===false; i++){
        var normal = normals[i];
        var face = faces[i];

        // Get world-transformed normal of the face
        var worldNormal = sphereConvex_worldNormal;
        qj.vmult(normal,worldNormal);

        // Get a world vertex from the face
        var worldPoint = sphereConvex_worldPoint;
        qj.vmult(verts[face[0]],worldPoint);
        worldPoint.vadd(xj,worldPoint);

        // Get a point on the sphere, closest to the face normal
        var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
        worldNormal.mult(-R, worldSpherePointClosestToPlane);
        xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);

        // Vector from a face point to the closest point on the sphere
        var penetrationVec = sphereConvex_penetrationVec;
        worldSpherePointClosestToPlane.vsub(worldPoint,penetrationVec);

        // The penetration. Negative value means overlap.
        var penetration = penetrationVec.dot(worldNormal);

        var worldPointToSphere = sphereConvex_sphereToWorldPoint;
        xi.vsub(worldPoint, worldPointToSphere);

        if(penetration < 0 && worldPointToSphere.dot(worldNormal)>0){
            // Intersects plane. Now check if the sphere is inside the face polygon
            var faceVerts = []; // Face vertices, in world coords
            for(var j=0, Nverts=face.length; j!==Nverts; j++){
                var worldVertex = v3pool.get();
                qj.vmult(verts[face[j]], worldVertex);
                xj.vadd(worldVertex,worldVertex);
                faceVerts.push(worldVertex);
            }

            if(pointInPolygon(faceVerts,worldNormal,xi)){ // Is the sphere center in the face polygon?
                if(justTest){
                    return true;
                }
                found = true;
                var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);

                worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact
                worldNormal.negate(r.ni); // Normal pointing out of sphere

                var penetrationVec2 = v3pool.get();
                worldNormal.mult(-penetration, penetrationVec2);
                var penetrationSpherePoint = v3pool.get();
                worldNormal.mult(-R, penetrationSpherePoint);

                //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);
                xi.vsub(xj,r.rj);
                r.rj.vadd(penetrationSpherePoint,r.rj);
                r.rj.vadd(penetrationVec2 , r.rj);

                // Should be relative to the body.
                r.rj.vadd(xj, r.rj);
                r.rj.vsub(bj.position, r.rj);

                // Should be relative to the body.
                r.ri.vadd(xi, r.ri);
                r.ri.vsub(bi.position, r.ri);

                v3pool.release(penetrationVec2);
                v3pool.release(penetrationSpherePoint);

                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);

                // Release world vertices
                for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
                    v3pool.release(faceVerts[j]);
                }

                return; // We only expect *one* face contact
            } else {
                // Edge?
                for(var j=0; j!==face.length; j++){

                    // Get two world transformed vertices
                    var v1 = v3pool.get();
                    var v2 = v3pool.get();
                    qj.vmult(verts[face[(j+1)%face.length]], v1);
                    qj.vmult(verts[face[(j+2)%face.length]], v2);
                    xj.vadd(v1, v1);
                    xj.vadd(v2, v2);

                    // Construct edge vector
                    var edge = sphereConvex_edge;
                    v2.vsub(v1,edge);

                    // Construct the same vector, but normalized
                    var edgeUnit = sphereConvex_edgeUnit;
                    edge.unit(edgeUnit);

                    // p is xi projected onto the edge
                    var p = v3pool.get();
                    var v1_to_xi = v3pool.get();
                    xi.vsub(v1, v1_to_xi);
                    var dot = v1_to_xi.dot(edgeUnit);
                    edgeUnit.mult(dot, p);
                    p.vadd(v1, p);

                    // Compute a vector from p to the center of the sphere
                    var xi_to_p = v3pool.get();
                    p.vsub(xi, xi_to_p);

                    // Collision if the edge-sphere distance is less than the radius
                    // AND if p is in between v1 and v2
                    if(dot > 0 && dot*dot<edge.norm2() && xi_to_p.norm2() < R*R){ // Collision if the edge-sphere distance is less than the radius
                        // Edge contact!
                        if(justTest){
                            return true;
                        }
                        var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
                        p.vsub(xj,r.rj);

                        p.vsub(xi,r.ni);
                        r.ni.normalize();

                        r.ni.mult(R,r.ri);

                        // Should be relative to the body.
                        r.rj.vadd(xj, r.rj);
                        r.rj.vsub(bj.position, r.rj);

                        // Should be relative to the body.
                        r.ri.vadd(xi, r.ri);
                        r.ri.vsub(bi.position, r.ri);

                        this.result.push(r);
                        this.createFrictionEquationsFromContact(r, this.frictionResult);

                        // Release world vertices
                        for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
                            v3pool.release(faceVerts[j]);
                        }

                        v3pool.release(v1);
                        v3pool.release(v2);
                        v3pool.release(p);
                        v3pool.release(xi_to_p);
                        v3pool.release(v1_to_xi);

                        return;
                    }

                    v3pool.release(v1);
                    v3pool.release(v2);
                    v3pool.release(p);
                    v3pool.release(xi_to_p);
                    v3pool.release(v1_to_xi);
                }
            }

            // Release world vertices
            for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
                v3pool.release(faceVerts[j]);
            }
        }
    }
};

var planeBox_normal = new Vec3();
var plane_to_corner = new Vec3();

/**
 * @method planeBox
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] =
Narrowphase.prototype.planeBox = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){
    sj.convexPolyhedronRepresentation.material = sj.material;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    sj.convexPolyhedronRepresentation.id = sj.id;
    return this.planeConvex(si,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj,justTest);
};

var planeConvex_v = new Vec3();
var planeConvex_normal = new Vec3();
var planeConvex_relpos = new Vec3();
var planeConvex_projected = new Vec3();

/**
 * @method planeConvex
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.planeConvex = function(
    planeShape,
    convexShape,
    planePosition,
    convexPosition,
    planeQuat,
    convexQuat,
    planeBody,
    convexBody,
    si,
    sj,
    justTest
){
    // Simply return the points behind the plane.
    var worldVertex = planeConvex_v,
        worldNormal = planeConvex_normal;
    worldNormal.set(0,0,1);
    planeQuat.vmult(worldNormal,worldNormal); // Turn normal according to plane orientation

    var numContacts = 0;
    var relpos = planeConvex_relpos;
    for(var i = 0; i !== convexShape.vertices.length; i++){

        // Get world convex vertex
        worldVertex.copy(convexShape.vertices[i]);
        convexQuat.vmult(worldVertex, worldVertex);
        convexPosition.vadd(worldVertex, worldVertex);
        worldVertex.vsub(planePosition, relpos);

        var dot = worldNormal.dot(relpos);
        if(dot <= 0.0){
            if(justTest){
                return true;
            }

            var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj);

            // Get vertex position projected on plane
            var projected = planeConvex_projected;
            worldNormal.mult(worldNormal.dot(relpos),projected);
            worldVertex.vsub(projected, projected);
            projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

            r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane

            // rj is now just the vector from the convex center to the vertex
            worldVertex.vsub(convexPosition, r.rj);

            // Make it relative to the body
            r.ri.vadd(planePosition, r.ri);
            r.ri.vsub(planeBody.position, r.ri);
            r.rj.vadd(convexPosition, r.rj);
            r.rj.vsub(convexBody.position, r.rj);

            this.result.push(r);
            numContacts++;
            if(!this.enableFrictionReduction){
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
        }
    }

    if(this.enableFrictionReduction && numContacts){
        this.createFrictionFromAverage(numContacts);
    }
};

var convexConvex_sepAxis = new Vec3();
var convexConvex_q = new Vec3();

/**
 * @method convexConvex
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.convexConvex = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest,faceListA,faceListB){
    var sepAxis = convexConvex_sepAxis;

    if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
        return;
    }

    if(si.findSeparatingAxis(sj,xi,qi,xj,qj,sepAxis,faceListA,faceListB)){
        var res = [];
        var q = convexConvex_q;
        si.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);
        var numContacts = 0;
        for(var j = 0; j !== res.length; j++){
            if(justTest){
                return true;
            }
            var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
                ri = r.ri,
                rj = r.rj;
            sepAxis.negate(r.ni);
            res[j].normal.negate(q);
            q.mult(res[j].depth, q);
            res[j].point.vadd(q, ri);
            rj.copy(res[j].point);

            // Contact points are in world coordinates. Transform back to relative
            ri.vsub(xi,ri);
            rj.vsub(xj,rj);

            // Make relative to bodies
            ri.vadd(xi, ri);
            ri.vsub(bi.position, ri);
            rj.vadd(xj, rj);
            rj.vsub(bj.position, rj);

            this.result.push(r);
            numContacts++;
            if(!this.enableFrictionReduction){
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
        }
        if(this.enableFrictionReduction && numContacts){
            this.createFrictionFromAverage(numContacts);
        }
    }
};


/**
 * @method convexTrimesh
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
// Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.TRIMESH] =
// Narrowphase.prototype.convexTrimesh = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){
//     var sepAxis = convexConvex_sepAxis;

//     if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
//         return;
//     }

//     // Construct a temp hull for each triangle
//     var hullB = new ConvexPolyhedron();

//     hullB.faces = [[0,1,2]];
//     var va = new Vec3();
//     var vb = new Vec3();
//     var vc = new Vec3();
//     hullB.vertices = [
//         va,
//         vb,
//         vc
//     ];

//     for (var i = 0; i < sj.indices.length / 3; i++) {

//         var triangleNormal = new Vec3();
//         sj.getNormal(i, triangleNormal);
//         hullB.faceNormals = [triangleNormal];

//         sj.getTriangleVertices(i, va, vb, vc);

//         var d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
//         if(!d){
//             triangleNormal.scale(-1, triangleNormal);
//             d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);

//             if(!d){
//                 continue;
//             }
//         }

//         var res = [];
//         var q = convexConvex_q;
//         si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
//         for(var j = 0; j !== res.length; j++){
//             var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
//                 ri = r.ri,
//                 rj = r.rj;
//             r.ni.copy(triangleNormal);
//             r.ni.negate(r.ni);
//             res[j].normal.negate(q);
//             q.mult(res[j].depth, q);
//             res[j].point.vadd(q, ri);
//             rj.copy(res[j].point);

//             // Contact points are in world coordinates. Transform back to relative
//             ri.vsub(xi,ri);
//             rj.vsub(xj,rj);

//             // Make relative to bodies
//             ri.vadd(xi, ri);
//             ri.vsub(bi.position, ri);
//             rj.vadd(xj, rj);
//             rj.vsub(bj.position, rj);

//             result.push(r);
//         }
//     }
// };

var particlePlane_normal = new Vec3();
var particlePlane_relpos = new Vec3();
var particlePlane_projected = new Vec3();

/**
 * @method particlePlane
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] =
Narrowphase.prototype.planeParticle = function(sj,si,xj,xi,qj,qi,bj,bi,rsi,rsj,justTest){
    var normal = particlePlane_normal;
    normal.set(0,0,1);
    bj.quaternion.vmult(normal,normal); // Turn normal according to plane orientation
    var relpos = particlePlane_relpos;
    xi.vsub(bj.position,relpos);
    var dot = normal.dot(relpos);
    if(dot <= 0.0){

        if(justTest){
            return true;
        }

        var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
        r.ni.copy(normal); // Contact normal is the plane normal
        r.ni.negate(r.ni);
        r.ri.set(0,0,0); // Center of particle

        // Get particle position projected on plane
        var projected = particlePlane_projected;
        normal.mult(normal.dot(xi),projected);
        xi.vsub(projected,projected);
        //projected.vadd(bj.position,projected);

        // rj is now the projected world position minus plane position
        r.rj.copy(projected);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
};

var particleSphere_normal = new Vec3();

/**
 * @method particleSphere
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] =
Narrowphase.prototype.sphereParticle = function(sj,si,xj,xi,qj,qi,bj,bi,rsi,rsj,justTest){
    // The normal is the unit vector from sphere center to particle center
    var normal = particleSphere_normal;
    normal.set(0,0,1);
    xi.vsub(xj,normal);
    var lengthSquared = normal.norm2();

    if(lengthSquared <= sj.radius * sj.radius){
        if(justTest){
            return true;
        }
        var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
        normal.normalize();
        r.rj.copy(normal);
        r.rj.mult(sj.radius,r.rj);
        r.ni.copy(normal); // Contact normal
        r.ni.negate(r.ni);
        r.ri.set(0,0,0); // Center of particle
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
};

// WIP
var cqj = new Quaternion();
var convexParticle_local = new Vec3();
var convexParticle_normal = new Vec3();
var convexParticle_penetratedFaceNormal = new Vec3();
var convexParticle_vertexToParticle = new Vec3();
var convexParticle_worldPenetrationVec = new Vec3();

/**
 * @method convexParticle
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.convexParticle = function(sj,si,xj,xi,qj,qi,bj,bi,rsi,rsj,justTest){
    var penetratedFaceIndex = -1;
    var penetratedFaceNormal = convexParticle_penetratedFaceNormal;
    var worldPenetrationVec = convexParticle_worldPenetrationVec;
    var minPenetration = null;
    var numDetectedFaces = 0;

    // Convert particle position xi to local coords in the convex
    var local = convexParticle_local;
    local.copy(xi);
    local.vsub(xj,local); // Convert position to relative the convex origin
    qj.conjugate(cqj);
    cqj.vmult(local,local);

    if(sj.pointIsInside(local)){

        if(sj.worldVerticesNeedsUpdate){
            sj.computeWorldVertices(xj,qj);
        }
        if(sj.worldFaceNormalsNeedsUpdate){
            sj.computeWorldFaceNormals(qj);
        }

        // For each world polygon in the polyhedra
        for(var i=0,nfaces=sj.faces.length; i!==nfaces; i++){

            // Construct world face vertices
            var verts = [ sj.worldVertices[ sj.faces[i][0] ] ];
            var normal = sj.worldFaceNormals[i];

            // Check how much the particle penetrates the polygon plane.
            xi.vsub(verts[0],convexParticle_vertexToParticle);
            var penetration = -normal.dot(convexParticle_vertexToParticle);
            if(minPenetration===null || Math.abs(penetration)<Math.abs(minPenetration)){

                if(justTest){
                    return true;
                }

                minPenetration = penetration;
                penetratedFaceIndex = i;
                penetratedFaceNormal.copy(normal);
                numDetectedFaces++;
            }
        }

        if(penetratedFaceIndex!==-1){
            // Setup contact
            var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec);

            // rj is the particle position projected to the face
            worldPenetrationVec.vadd(xi,worldPenetrationVec);
            worldPenetrationVec.vsub(xj,worldPenetrationVec);
            r.rj.copy(worldPenetrationVec);
            //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
            //projectedToFace.copy(r.rj);

            //qj.vmult(r.rj,r.rj);
            penetratedFaceNormal.negate( r.ni ); // Contact normal
            r.ri.set(0,0,0); // Center of particle

            var ri = r.ri,
                rj = r.rj;

            // Make relative to bodies
            ri.vadd(xi, ri);
            ri.vsub(bi.position, ri);
            rj.vadd(xj, rj);
            rj.vsub(bj.position, rj);

            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
        } else {
            console.warn("Point found inside convex, but did not find penetrating face!");
        }
    }
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] =
Narrowphase.prototype.boxHeightfield = function (si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexHeightfield(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj,justTest);
};

var convexHeightfield_tmp1 = new Vec3();
var convexHeightfield_tmp2 = new Vec3();
var convexHeightfield_faceList = [0];

/**
 * @method convexHeightfield
 */
Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] =
Narrowphase.prototype.convexHeightfield = function (
    convexShape,
    hfShape,
    convexPos,
    hfPos,
    convexQuat,
    hfQuat,
    convexBody,
    hfBody,
    rsi,
    rsj,
    justTest
){
    var data = hfShape.data,
        w = hfShape.elementSize,
        radius = convexShape.boundingSphereRadius,
        worldPillarOffset = convexHeightfield_tmp2,
        faceList = convexHeightfield_faceList;

    // Get sphere position to heightfield local!
    var localConvexPos = convexHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);

    // Get the index of the data points to test against
    var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,
        iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,
        iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,
        iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;

    // Bail out if we are out of the terrain
    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length){
        return;
    }

    // Clamp index to edges
    if(iMinX < 0){ iMinX = 0; }
    if(iMaxX < 0){ iMaxX = 0; }
    if(iMinY < 0){ iMinY = 0; }
    if(iMaxY < 0){ iMaxY = 0; }
    if(iMinX >= data.length){ iMinX = data.length - 1; }
    if(iMaxX >= data.length){ iMaxX = data.length - 1; }
    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }
    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }

    var minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    var min = minMax[0];
    var max = minMax[1];

    // Bail out if we're cant touch the bounding height box
    if(localConvexPos.z - radius > max || localConvexPos.z + radius < min){
        return;
    }

    for(var i = iMinX; i < iMaxX; i++){
        for(var j = iMinY; j < iMaxY; j++){

            var intersecting = false;

            // Lower triangle
            hfShape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
                intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
            }

            if(justTest && intersecting){
                return true;
            }

            // Upper triangle
            hfShape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
                intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
            }

            if(justTest && intersecting){
                return true;
            }
        }
    }
};

var sphereHeightfield_tmp1 = new Vec3();
var sphereHeightfield_tmp2 = new Vec3();

/**
 * @method sphereHeightfield
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] =
Narrowphase.prototype.sphereHeightfield = function (
    sphereShape,
    hfShape,
    spherePos,
    hfPos,
    sphereQuat,
    hfQuat,
    sphereBody,
    hfBody,
    rsi,
    rsj,
    justTest
){
    var data = hfShape.data,
        radius = sphereShape.radius,
        w = hfShape.elementSize,
        worldPillarOffset = sphereHeightfield_tmp2;

    // Get sphere position to heightfield local!
    var localSpherePos = sphereHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);

    // Get the index of the data points to test against
    var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,
        iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,
        iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,
        iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;

    // Bail out if we are out of the terrain
    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length){
        return;
    }

    // Clamp index to edges
    if(iMinX < 0){ iMinX = 0; }
    if(iMaxX < 0){ iMaxX = 0; }
    if(iMinY < 0){ iMinY = 0; }
    if(iMaxY < 0){ iMaxY = 0; }
    if(iMinX >= data.length){ iMinX = data.length - 1; }
    if(iMaxX >= data.length){ iMaxX = data.length - 1; }
    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }
    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }

    var minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    var min = minMax[0];
    var max = minMax[1];

    // Bail out if we're cant touch the bounding height box
    if(localSpherePos.z - radius > max || localSpherePos.z + radius < min){
        return;
    }

    var result = this.result;
    for(var i = iMinX; i < iMaxX; i++){
        for(var j = iMinY; j < iMaxY; j++){

            var numContactsBefore = result.length;

            var intersecting = false;

            // Lower triangle
            hfShape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
                intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
            }

            if(justTest && intersecting){
                return true;
            }

            // Upper triangle
            hfShape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
                intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
            }

            if(justTest && intersecting){
                return true;
            }

            var numContacts = result.length - numContactsBefore;

            if(numContacts > 2){
                return;
            }
            /*
            // Skip all but 1
            for (var k = 0; k < numContacts - 1; k++) {
                result.pop();
            }
            */
        }
    }
};

},{"../collision/AABB":3,"../collision/Ray":10,"../equations/ContactEquation":20,"../equations/FrictionEquation":22,"../math/Quaternion":29,"../math/Transform":30,"../math/Vec3":31,"../objects/Body":32,"../shapes/ConvexPolyhedron":39,"../shapes/Shape":44,"../solver/Solver":48,"../utils/Vec3Pool":55}],57:[function(require,module,exports){
/* global performance */

module.exports = World;

var Shape = require('../shapes/Shape');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var GSSolver = require('../solver/GSSolver');
var ContactEquation = require('../equations/ContactEquation');
var FrictionEquation = require('../equations/FrictionEquation');
var Narrowphase = require('./Narrowphase');
var EventTarget = require('../utils/EventTarget');
var ArrayCollisionMatrix = require('../collision/ArrayCollisionMatrix');
var OverlapKeeper = require('../collision/OverlapKeeper');
var Material = require('../material/Material');
var ContactMaterial = require('../material/ContactMaterial');
var Body = require('../objects/Body');
var TupleDictionary = require('../utils/TupleDictionary');
var RaycastResult = require('../collision/RaycastResult');
var AABB = require('../collision/AABB');
var Ray = require('../collision/Ray');
var NaiveBroadphase = require('../collision/NaiveBroadphase');

/**
 * The physics world
 * @class World
 * @constructor
 * @extends EventTarget
 * @param {object} [options]
 * @param {Vec3} [options.gravity]
 * @param {boolean} [options.allowSleep]
 * @param {Broadphase} [options.broadphase]
 * @param {Solver} [options.solver]
 * @param {boolean} [options.quatNormalizeFast]
 * @param {number} [options.quatNormalizeSkip]
 */
function World(options){
    options = options || {};
    EventTarget.apply(this);

    /**
     * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
     * @property {Number} dt
     */
    this.dt = -1;

    /**
     * Makes bodies go to sleep when they've been inactive
     * @property allowSleep
     * @type {Boolean}
     * @default false
     */
    this.allowSleep = !!options.allowSleep;

    /**
     * All the current contacts (instances of ContactEquation) in the world.
     * @property contacts
     * @type {Array}
     */
    this.contacts = [];
    this.frictionEquations = [];

    /**
     * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
     * @property quatNormalizeSkip
     * @type {Number}
     * @default 0
     */
    this.quatNormalizeSkip = options.quatNormalizeSkip !== undefined ? options.quatNormalizeSkip : 0;

    /**
     * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.
     * @property quatNormalizeFast
     * @type {Boolean}
     * @see Quaternion.normalizeFast
     * @see Quaternion.normalize
     * @default false
     */
    this.quatNormalizeFast = options.quatNormalizeFast !== undefined ? options.quatNormalizeFast : false;

    /**
     * The wall-clock time since simulation start
     * @property time
     * @type {Number}
     */
    this.time = 0.0;

    /**
     * Number of timesteps taken since start
     * @property stepnumber
     * @type {Number}
     */
    this.stepnumber = 0;

    /// Default and last timestep sizes
    this.default_dt = 1/60;

    this.nextId = 0;
    /**
     * @property gravity
     * @type {Vec3}
     */
    this.gravity = new Vec3();
    if(options.gravity){
        this.gravity.copy(options.gravity);
    }

    /**
     * The broadphase algorithm to use. Default is NaiveBroadphase
     * @property broadphase
     * @type {Broadphase}
     */
    this.broadphase = options.broadphase !== undefined ? options.broadphase : new NaiveBroadphase();

    /**
     * @property bodies
     * @type {Array}
     */
    this.bodies = [];

    /**
     * The solver algorithm to use. Default is GSSolver
     * @property solver
     * @type {Solver}
     */
    this.solver = options.solver !== undefined ? options.solver : new GSSolver();

    /**
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    /**
     * @property narrowphase
     * @type {Narrowphase}
     */
    this.narrowphase = new Narrowphase(this);

    /**
     * @property {ArrayCollisionMatrix} collisionMatrix
	 * @type {ArrayCollisionMatrix}
	 */
	this.collisionMatrix = new ArrayCollisionMatrix();

    /**
     * CollisionMatrix from the previous step.
     * @property {ArrayCollisionMatrix} collisionMatrixPrevious
	 * @type {ArrayCollisionMatrix}
	 */
	this.collisionMatrixPrevious = new ArrayCollisionMatrix();

    this.bodyOverlapKeeper = new OverlapKeeper();
    this.shapeOverlapKeeper = new OverlapKeeper();

    /**
     * All added materials
     * @property materials
     * @type {Array}
     */
    this.materials = [];

    /**
     * @property contactmaterials
     * @type {Array}
     */
    this.contactmaterials = [];

    /**
     * Used to look up a ContactMaterial given two instances of Material.
     * @property {TupleDictionary} contactMaterialTable
     */
    this.contactMaterialTable = new TupleDictionary();

    this.defaultMaterial = new Material("default");

    /**
     * This contact material is used if no suitable contactmaterial is found for a contact.
     * @property defaultContactMaterial
     * @type {ContactMaterial}
     */
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0.0 });

    /**
     * @property doProfiling
     * @type {Boolean}
     */
    this.doProfiling = false;

    /**
     * @property profile
     * @type {Object}
     */
    this.profile = {
        solve:0,
        makeContactConstraints:0,
        broadphase:0,
        integrate:0,
        narrowphase:0,
    };

    /**
     * Time accumulator for interpolation. See http://gafferongames.com/game-physics/fix-your-timestep/
     * @property {Number} accumulator
     */
    this.accumulator = 0;

    /**
     * @property subsystems
     * @type {Array}
     */
    this.subsystems = [];

    /**
     * Dispatched after a body has been added to the world.
     * @event addBody
     * @param {Body} body The body that has been added to the world.
     */
    this.addBodyEvent = {
        type:"addBody",
        body : null
    };

    /**
     * Dispatched after a body has been removed from the world.
     * @event removeBody
     * @param {Body} body The body that has been removed from the world.
     */
    this.removeBodyEvent = {
        type:"removeBody",
        body : null
    };

    this.idToBodyMap = {};

    this.broadphase.setWorld(this);
}
World.prototype = new EventTarget();

// Temp stuff
var tmpAABB1 = new AABB();
var tmpArray1 = [];
var tmpRay = new Ray();

/**
 * Get the contact material between materials m1 and m2
 * @method getContactMaterial
 * @param {Material} m1
 * @param {Material} m2
 * @return {ContactMaterial} The contact material if it was found.
 */
World.prototype.getContactMaterial = function(m1,m2){
    return this.contactMaterialTable.get(m1.id,m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];
};

/**
 * Get number of objects in the world.
 * @method numObjects
 * @return {Number}
 * @deprecated
 */
World.prototype.numObjects = function(){
    return this.bodies.length;
};

/**
 * Store old collision state info
 * @method collisionMatrixTick
 */
World.prototype.collisionMatrixTick = function(){
	var temp = this.collisionMatrixPrevious;
	this.collisionMatrixPrevious = this.collisionMatrix;
	this.collisionMatrix = temp;
	this.collisionMatrix.reset();

    this.bodyOverlapKeeper.tick();
    this.shapeOverlapKeeper.tick();
};

/**
 * Add a rigid body to the simulation.
 * @method add
 * @param {Body} body
 * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
 * @todo Adding an array of bodies should be possible. This would save some loops too
 * @deprecated Use .addBody instead
 */
World.prototype.add = World.prototype.addBody = function(body){
    if(this.bodies.indexOf(body) !== -1){
        return;
    }
    body.index = this.bodies.length;
    this.bodies.push(body);
    body.world = this;
    body.initPosition.copy(body.position);
    body.initVelocity.copy(body.velocity);
    body.timeLastSleepy = this.time;
    if(body instanceof Body){
        body.initAngularVelocity.copy(body.angularVelocity);
        body.initQuaternion.copy(body.quaternion);
    }
	this.collisionMatrix.setNumObjects(this.bodies.length);
    this.addBodyEvent.body = body;
    this.idToBodyMap[body.id] = body;
    this.dispatchEvent(this.addBodyEvent);
};

/**
 * Add a constraint to the simulation.
 * @method addConstraint
 * @param {Constraint} c
 */
World.prototype.addConstraint = function(c){
    this.constraints.push(c);
};

/**
 * Removes a constraint
 * @method removeConstraint
 * @param {Constraint} c
 */
World.prototype.removeConstraint = function(c){
    var idx = this.constraints.indexOf(c);
    if(idx!==-1){
        this.constraints.splice(idx,1);
    }
};

/**
 * Raycast test
 * @method rayTest
 * @param {Vec3} from
 * @param {Vec3} to
 * @param {RaycastResult} result
 * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
 */
World.prototype.rayTest = function(from, to, result){
    if(result instanceof RaycastResult){
        // Do raycastclosest
        this.raycastClosest(from, to, {
            skipBackfaces: true
        }, result);
    } else {
        // Do raycastAll
        this.raycastAll(from, to, {
            skipBackfaces: true
        }, result);
    }
};

/**
 * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
 * @method raycastAll
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionFilterMask=-1]
 * @param  {number} [options.collisionFilterGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {Function} callback
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAll = function(from, to, options, callback){
    options.mode = Ray.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
 * @method raycastAny
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionFilterMask=-1]
 * @param  {number} [options.collisionFilterGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAny = function(from, to, options, result){
    options.mode = Ray.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and return information of the closest hit.
 * @method raycastClosest
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionFilterMask=-1]
 * @param  {number} [options.collisionFilterGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastClosest = function(from, to, options, result){
    options.mode = Ray.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Remove a rigid body from the simulation.
 * @method remove
 * @param {Body} body
 * @deprecated Use .removeBody instead
 */
World.prototype.remove = function(body){
    body.world = null;
    var n = this.bodies.length - 1,
        bodies = this.bodies,
        idx = bodies.indexOf(body);
    if(idx !== -1){
        bodies.splice(idx, 1); // Todo: should use a garbage free method

        // Recompute index
        for(var i=0; i!==bodies.length; i++){
            bodies[i].index = i;
        }

        this.collisionMatrix.setNumObjects(n);
        this.removeBodyEvent.body = body;
        delete this.idToBodyMap[body.id];
        this.dispatchEvent(this.removeBodyEvent);
    }
};

/**
 * Remove a rigid body from the simulation.
 * @method removeBody
 * @param {Body} body
 */
World.prototype.removeBody = World.prototype.remove;

World.prototype.getBodyById = function(id){
    return this.idToBodyMap[id];
};

// TODO Make a faster map
World.prototype.getShapeById = function(id){
    var bodies = this.bodies;
    for(var i=0, bl = bodies.length; i<bl; i++){
        var shapes = bodies[i].shapes;
        for (var j = 0, sl = shapes.length; j < sl; j++) {
            var shape = shapes[j];
            if(shape.id === id){
                return shape;
            }
        }
    }
};

/**
 * Adds a material to the World.
 * @method addMaterial
 * @param {Material} m
 * @todo Necessary?
 */
World.prototype.addMaterial = function(m){
    this.materials.push(m);
};

/**
 * Adds a contact material to the World
 * @method addContactMaterial
 * @param {ContactMaterial} cmat
 */
World.prototype.addContactMaterial = function(cmat) {

    // Add contact material
    this.contactmaterials.push(cmat);

    // Add current contact material to the material table
    this.contactMaterialTable.set(cmat.materials[0].id,cmat.materials[1].id,cmat);
};

// performance.now()
if(typeof performance === 'undefined'){
    performance = {};
}
if(!performance.now){
    var nowOffset = Date.now();
    if (performance.timing && performance.timing.navigationStart){
        nowOffset = performance.timing.navigationStart;
    }
    performance.now = function(){
        return Date.now() - nowOffset;
    };
}

var step_tmp1 = new Vec3();

/**
 * Step the physics world forward in time.
 *
 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
 *
 * @method step
 * @param {Number} dt                       The fixed time step size to use.
 * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.
 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
 *
 * @example
 *     // fixed timestepping without interpolation
 *     world.step(1/60);
 *
 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
 */
World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps){
    maxSubSteps = maxSubSteps || 10;
    timeSinceLastCalled = timeSinceLastCalled || 0;

    if(timeSinceLastCalled === 0){ // Fixed, simple stepping

        this.internalStep(dt);

        // Increment time
        this.time += dt;

    } else {

        this.accumulator += timeSinceLastCalled;
        var substeps = 0;
        while (this.accumulator >= dt && substeps < maxSubSteps) {
            // Do fixed steps to catch up
            this.internalStep(dt);
            this.accumulator -= dt;
            substeps++;
        }

        var t = (this.accumulator % dt) / dt;
        for(var j=0; j !== this.bodies.length; j++){
            var b = this.bodies[j];
            b.previousPosition.lerp(b.position, t, b.interpolatedPosition);
            b.previousQuaternion.slerp(b.quaternion, t, b.interpolatedQuaternion);
            b.previousQuaternion.normalize();
        }
        this.time += timeSinceLastCalled;
    }
};

var
    /**
     * Dispatched after the world has stepped forward in time.
     * @event postStep
     */
    World_step_postStepEvent = {type:"postStep"}, // Reusable event objects to save memory
    /**
     * Dispatched before the world steps forward in time.
     * @event preStep
     */
    World_step_preStepEvent = {type:"preStep"},
    World_step_collideEvent = {type:Body.COLLIDE_EVENT_NAME, body:null, contact:null },
    World_step_oldContacts = [], // Pools for unused objects
    World_step_frictionEquationPool = [],
    World_step_p1 = [], // Reusable arrays for collision pairs
    World_step_p2 = [],
    World_step_gvec = new Vec3(), // Temporary vectors and quats
    World_step_vi = new Vec3(),
    World_step_vj = new Vec3(),
    World_step_wi = new Vec3(),
    World_step_wj = new Vec3(),
    World_step_t1 = new Vec3(),
    World_step_t2 = new Vec3(),
    World_step_rixn = new Vec3(),
    World_step_rjxn = new Vec3(),
    World_step_step_q = new Quaternion(),
    World_step_step_w = new Quaternion(),
    World_step_step_wq = new Quaternion(),
    invI_tau_dt = new Vec3();
World.prototype.internalStep = function(dt){
    this.dt = dt;

    var world = this,
        that = this,
        contacts = this.contacts,
        p1 = World_step_p1,
        p2 = World_step_p2,
        N = this.numObjects(),
        bodies = this.bodies,
        solver = this.solver,
        gravity = this.gravity,
        doProfiling = this.doProfiling,
        profile = this.profile,
        DYNAMIC = Body.DYNAMIC,
        profilingStart,
        constraints = this.constraints,
        frictionEquationPool = World_step_frictionEquationPool,
        gnorm = gravity.norm(),
        gx = gravity.x,
        gy = gravity.y,
        gz = gravity.z,
        i=0;

    if(doProfiling){
        profilingStart = performance.now();
    }

    // Add gravity to all objects
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi.type === DYNAMIC){ // Only for dynamic bodies
            var f = bi.force, m = bi.mass;
            f.x += m*gx;
            f.y += m*gy;
            f.z += m*gz;
        }
    }

    // Update subsystems
    for(var i=0, Nsubsystems=this.subsystems.length; i!==Nsubsystems; i++){
        this.subsystems[i].update();
    }

    // Collision detection
    if(doProfiling){ profilingStart = performance.now(); }
    p1.length = 0; // Clean up pair arrays from last step
    p2.length = 0;
    this.broadphase.collisionPairs(this,p1,p2);
    if(doProfiling){ profile.broadphase = performance.now() - profilingStart; }

    // Remove constrained pairs with collideConnected == false
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        if(!c.collideConnected){
            for(var j = p1.length-1; j>=0; j-=1){
                if( (c.bodyA === p1[j] && c.bodyB === p2[j]) ||
                    (c.bodyB === p1[j] && c.bodyA === p2[j])){
                    p1.splice(j, 1);
                    p2.splice(j, 1);
                }
            }
        }
    }

    this.collisionMatrixTick();

    // Generate contacts
    if(doProfiling){ profilingStart = performance.now(); }
    var oldcontacts = World_step_oldContacts;
    var NoldContacts = contacts.length;

    for(i=0; i!==NoldContacts; i++){
        oldcontacts.push(contacts[i]);
    }
    contacts.length = 0;

    // Transfer FrictionEquation from current list to the pool for reuse
    var NoldFrictionEquations = this.frictionEquations.length;
    for(i=0; i!==NoldFrictionEquations; i++){
        frictionEquationPool.push(this.frictionEquations[i]);
    }
    this.frictionEquations.length = 0;

    this.narrowphase.getContacts(
        p1,
        p2,
        this,
        contacts,
        oldcontacts, // To be reused
        this.frictionEquations,
        frictionEquationPool
    );

    if(doProfiling){
        profile.narrowphase = performance.now() - profilingStart;
    }

    // Loop over all collisions
    if(doProfiling){
        profilingStart = performance.now();
    }

    // Add all friction eqs
    for (var i = 0; i < this.frictionEquations.length; i++) {
        solver.addEquation(this.frictionEquations[i]);
    }

    var ncontacts = contacts.length;
    for(var k=0; k!==ncontacts; k++){

        // Current contact
        var c = contacts[k];

        // Get current collision indeces
        var bi = c.bi,
            bj = c.bj,
            si = c.si,
            sj = c.sj;

        // Get collision properties
        var cm;
        if(bi.material && bj.material){
            cm = this.getContactMaterial(bi.material,bj.material) || this.defaultContactMaterial;
        } else {
            cm = this.defaultContactMaterial;
        }

        // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

        var mu = cm.friction;
        // c.restitution = cm.restitution;

        // If friction or restitution were specified in the material, use them
        if(bi.material && bj.material){
            if(bi.material.friction >= 0 && bj.material.friction >= 0){
                mu = bi.material.friction * bj.material.friction;
            }

            if(bi.material.restitution >= 0 && bj.material.restitution >= 0){
                c.restitution = bi.material.restitution * bj.material.restitution;
            }
        }

		// c.setSpookParams(
  //           cm.contactEquationStiffness,
  //           cm.contactEquationRelaxation,
  //           dt
  //       );

		solver.addEquation(c);

		// // Add friction constraint equation
		// if(mu > 0){

		// 	// Create 2 tangent equations
		// 	var mug = mu * gnorm;
		// 	var reducedMass = (bi.invMass + bj.invMass);
		// 	if(reducedMass > 0){
		// 		reducedMass = 1/reducedMass;
		// 	}
		// 	var pool = frictionEquationPool;
		// 	var c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
		// 	var c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
		// 	this.frictionEquations.push(c1, c2);

		// 	c1.bi = c2.bi = bi;
		// 	c1.bj = c2.bj = bj;
		// 	c1.minForce = c2.minForce = -mug*reducedMass;
		// 	c1.maxForce = c2.maxForce = mug*reducedMass;

		// 	// Copy over the relative vectors
		// 	c1.ri.copy(c.ri);
		// 	c1.rj.copy(c.rj);
		// 	c2.ri.copy(c.ri);
		// 	c2.rj.copy(c.rj);

		// 	// Construct tangents
		// 	c.ni.tangents(c1.t, c2.t);

  //           // Set spook params
  //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
  //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);

  //           c1.enabled = c2.enabled = c.enabled;

		// 	// Add equations to solver
		// 	solver.addEquation(c1);
		// 	solver.addEquation(c2);
		// }

        if( bi.allowSleep &&
            bi.type === Body.DYNAMIC &&
            bi.sleepState  === Body.SLEEPING &&
            bj.sleepState  === Body.AWAKE &&
            bj.type !== Body.STATIC
        ){
            var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();
            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
            if(speedSquaredB >= speedLimitSquaredB*2){
                bi._wakeUpAfterNarrowphase = true;
            }
        }

        if( bj.allowSleep &&
            bj.type === Body.DYNAMIC &&
            bj.sleepState  === Body.SLEEPING &&
            bi.sleepState  === Body.AWAKE &&
            bi.type !== Body.STATIC
        ){
            var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();
            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
            if(speedSquaredA >= speedLimitSquaredA*2){
                bj._wakeUpAfterNarrowphase = true;
            }
        }

        // Now we know that i and j are in contact. Set collision matrix state
		this.collisionMatrix.set(bi, bj, true);

        if (!this.collisionMatrixPrevious.get(bi, bj)) {
            // First contact!
            // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
            World_step_collideEvent.body = bj;
            World_step_collideEvent.contact = c;
            bi.dispatchEvent(World_step_collideEvent);

            World_step_collideEvent.body = bi;
            bj.dispatchEvent(World_step_collideEvent);
        }

        this.bodyOverlapKeeper.set(bi.id, bj.id);
        this.shapeOverlapKeeper.set(si.id, sj.id);
    }

    this.emitContactEvents();

    if(doProfiling){
        profile.makeContactConstraints = performance.now() - profilingStart;
        profilingStart = performance.now();
    }

    // Wake up bodies
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi._wakeUpAfterNarrowphase){
            bi.wakeUp();
            bi._wakeUpAfterNarrowphase = false;
        }
    }

    // Add user-added constraints
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        c.update();
        for(var j=0, Neq=c.equations.length; j!==Neq; j++){
            var eq = c.equations[j];
            solver.addEquation(eq);
        }
    }

    // Solve the constrained system
    solver.solve(dt,this);

    if(doProfiling){
        profile.solve = performance.now() - profilingStart;
    }

    // Remove all contacts from solver
    solver.removeAllEquations();

    // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details
    var pow = Math.pow;
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi.type & DYNAMIC){ // Only for dynamic bodies
            var ld = pow(1.0 - bi.linearDamping,dt);
            var v = bi.velocity;
            v.mult(ld,v);
            var av = bi.angularVelocity;
            if(av){
                var ad = pow(1.0 - bi.angularDamping,dt);
                av.mult(ad,av);
            }
        }
    }

    this.dispatchEvent(World_step_preStepEvent);

    // Invoke pre-step callbacks
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi.preStep){
            bi.preStep.call(bi);
        }
    }

    // Leap frog
    // vnew = v + h*f/m
    // xnew = x + h*vnew
    if(doProfiling){
        profilingStart = performance.now();
    }
    var stepnumber = this.stepnumber;
    var quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;
    var quatNormalizeFast = this.quatNormalizeFast;

    for(i=0; i!==N; i++){
        bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);
    }
    this.clearForces();

    this.broadphase.dirty = true;

    if(doProfiling){
        profile.integrate = performance.now() - profilingStart;
    }

    // Update world time
    this.time += dt;
    this.stepnumber += 1;

    this.dispatchEvent(World_step_postStepEvent);

    // Invoke post-step callbacks
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        var postStep = bi.postStep;
        if(postStep){
            postStep.call(bi);
        }
    }

    // Sleeping update
    if(this.allowSleep){
        for(i=0; i!==N; i++){
            bodies[i].sleepTick(this.time);
        }
    }
};

World.prototype.emitContactEvents = (function(){
    var additions = [];
    var removals = [];
    var beginContactEvent = {
        type: 'beginContact',
        bodyA: null,
        bodyB: null
    };
    var endContactEvent = {
        type: 'endContact',
        bodyA: null,
        bodyB: null
    };
    var beginShapeContactEvent = {
        type: 'beginShapeContact',
        bodyA: null,
        bodyB: null,
        shapeA: null,
        shapeB: null
    };
    var endShapeContactEvent = {
        type: 'endShapeContact',
        bodyA: null,
        bodyB: null,
        shapeA: null,
        shapeB: null
    };
    return function(){
        var hasBeginContact = this.hasAnyEventListener('beginContact');
        var hasEndContact = this.hasAnyEventListener('endContact');

        if(hasBeginContact || hasEndContact){
            this.bodyOverlapKeeper.getDiff(additions, removals);
        }

        if(hasBeginContact){
            for (var i = 0, l = additions.length; i < l; i += 2) {
                beginContactEvent.bodyA = this.getBodyById(additions[i]);
                beginContactEvent.bodyB = this.getBodyById(additions[i+1]);
                this.dispatchEvent(beginContactEvent);
            }
            beginContactEvent.bodyA = beginContactEvent.bodyB = null;
        }

        if(hasEndContact){
            for (var i = 0, l = removals.length; i < l; i += 2) {
                endContactEvent.bodyA = this.getBodyById(removals[i]);
                endContactEvent.bodyB = this.getBodyById(removals[i+1]);
                this.dispatchEvent(endContactEvent);
            }
            endContactEvent.bodyA = endContactEvent.bodyB = null;
        }

        additions.length = removals.length = 0;

        var hasBeginShapeContact = this.hasAnyEventListener('beginShapeContact');
        var hasEndShapeContact = this.hasAnyEventListener('endShapeContact');

        if(hasBeginShapeContact || hasEndShapeContact){
            this.shapeOverlapKeeper.getDiff(additions, removals);
        }

        if(hasBeginShapeContact){
            for (var i = 0, l = additions.length; i < l; i += 2) {
                var shapeA = this.getShapeById(additions[i]);
                var shapeB = this.getShapeById(additions[i+1]);
                beginShapeContactEvent.shapeA = shapeA;
                beginShapeContactEvent.shapeB = shapeB;
                beginShapeContactEvent.bodyA = shapeA.body;
                beginShapeContactEvent.bodyB = shapeB.body;
                this.dispatchEvent(beginShapeContactEvent);
            }
            beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null;
        }

        if(hasEndShapeContact){
            for (var i = 0, l = removals.length; i < l; i += 2) {
                var shapeA = this.getShapeById(removals[i]);
                var shapeB = this.getShapeById(removals[i+1]);
                endShapeContactEvent.shapeA = shapeA;
                endShapeContactEvent.shapeB = shapeB;
                endShapeContactEvent.bodyA = shapeA.body;
                endShapeContactEvent.bodyB = shapeB.body;
                this.dispatchEvent(endShapeContactEvent);
            }
            endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null;
        }

    };
})();

/**
 * Sets all body forces in the world to zero.
 * @method clearForces
 */
World.prototype.clearForces = function(){
    var bodies = this.bodies;
    var N = bodies.length;
    for(var i=0; i !== N; i++){
        var b = bodies[i],
            force = b.force,
            tau = b.torque;

        b.force.set(0,0,0);
        b.torque.set(0,0,0);
    }
};

},{"../collision/AABB":3,"../collision/ArrayCollisionMatrix":4,"../collision/NaiveBroadphase":7,"../collision/OverlapKeeper":9,"../collision/Ray":10,"../collision/RaycastResult":11,"../equations/ContactEquation":20,"../equations/FrictionEquation":22,"../material/ContactMaterial":25,"../material/Material":26,"../math/Quaternion":29,"../math/Vec3":31,"../objects/Body":32,"../shapes/Shape":44,"../solver/GSSolver":47,"../utils/EventTarget":50,"../utils/TupleDictionary":53,"./Narrowphase":56}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL1VzZXJzL0lseWEvQXBwRGF0YS9Sb2FtaW5nL252bS92MTguMTIuMC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwicGFja2FnZS5qc29uIiwic3JjL0Nhbm5vbi5qcyIsInNyYy9jb2xsaXNpb24vQUFCQi5qcyIsInNyYy9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXguanMiLCJzcmMvY29sbGlzaW9uL0Jyb2FkcGhhc2UuanMiLCJzcmMvY29sbGlzaW9uL0dyaWRCcm9hZHBoYXNlLmpzIiwic3JjL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UuanMiLCJzcmMvY29sbGlzaW9uL09iamVjdENvbGxpc2lvbk1hdHJpeC5qcyIsInNyYy9jb2xsaXNpb24vT3ZlcmxhcEtlZXBlci5qcyIsInNyYy9jb2xsaXNpb24vUmF5LmpzIiwic3JjL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0LmpzIiwic3JjL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlLmpzIiwic3JjL2NvbnN0cmFpbnRzL0NvbmVUd2lzdENvbnN0cmFpbnQuanMiLCJzcmMvY29uc3RyYWludHMvQ29uc3RyYWludC5qcyIsInNyYy9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnQuanMiLCJzcmMvY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50LmpzIiwic3JjL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50LmpzIiwic3JjL2NvbnN0cmFpbnRzL1BvaW50VG9Qb2ludENvbnN0cmFpbnQuanMiLCJzcmMvZXF1YXRpb25zL0NvbmVFcXVhdGlvbi5qcyIsInNyYy9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uLmpzIiwic3JjL2VxdWF0aW9ucy9FcXVhdGlvbi5qcyIsInNyYy9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbi5qcyIsInNyYy9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uLmpzIiwic3JjL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbi5qcyIsInNyYy9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWwuanMiLCJzcmMvbWF0ZXJpYWwvTWF0ZXJpYWwuanMiLCJzcmMvbWF0aC9KYWNvYmlhbkVsZW1lbnQuanMiLCJzcmMvbWF0aC9NYXQzLmpzIiwic3JjL21hdGgvUXVhdGVybmlvbi5qcyIsInNyYy9tYXRoL1RyYW5zZm9ybS5qcyIsInNyYy9tYXRoL1ZlYzMuanMiLCJzcmMvb2JqZWN0cy9Cb2R5LmpzIiwic3JjL29iamVjdHMvUmF5Y2FzdFZlaGljbGUuanMiLCJzcmMvb2JqZWN0cy9SaWdpZFZlaGljbGUuanMiLCJzcmMvb2JqZWN0cy9TUEhTeXN0ZW0uanMiLCJzcmMvb2JqZWN0cy9TcHJpbmcuanMiLCJzcmMvb2JqZWN0cy9XaGVlbEluZm8uanMiLCJzcmMvc2hhcGVzL0JveC5qcyIsInNyYy9zaGFwZXMvQ29udmV4UG9seWhlZHJvbi5qcyIsInNyYy9zaGFwZXMvQ3lsaW5kZXIuanMiLCJzcmMvc2hhcGVzL0hlaWdodGZpZWxkLmpzIiwic3JjL3NoYXBlcy9QYXJ0aWNsZS5qcyIsInNyYy9zaGFwZXMvUGxhbmUuanMiLCJzcmMvc2hhcGVzL1NoYXBlLmpzIiwic3JjL3NoYXBlcy9TcGhlcmUuanMiLCJzcmMvc2hhcGVzL1RyaW1lc2guanMiLCJzcmMvc29sdmVyL0dTU29sdmVyLmpzIiwic3JjL3NvbHZlci9Tb2x2ZXIuanMiLCJzcmMvc29sdmVyL1NwbGl0U29sdmVyLmpzIiwic3JjL3V0aWxzL0V2ZW50VGFyZ2V0LmpzIiwic3JjL3V0aWxzL09jdHJlZS5qcyIsInNyYy91dGlscy9Qb29sLmpzIiwic3JjL3V0aWxzL1R1cGxlRGljdGlvbmFyeS5qcyIsInNyYy91dGlscy9VdGlscy5qcyIsInNyYy91dGlscy9WZWMzUG9vbC5qcyIsInNyYy93b3JsZC9OYXJyb3dwaGFzZS5qcyIsInNyYy93b3JsZC9Xb3JsZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4ekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzk1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDampCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeDBEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiY2Fubm9uXCIsXG4gIFwidmVyc2lvblwiOiBcIjAuNi4yXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIGxpZ2h0d2VpZ2h0IDNEIHBoeXNpY3MgZW5naW5lIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdC5cIixcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS9jYW5ub24uanNcIixcbiAgXCJhdXRob3JcIjogXCJTdGVmYW4gSGVkbWFuIDxzY2h0ZXBwZUBnbWFpbC5jb20+IChodHRwOi8vc3RlZmZlLnNlKVwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImNhbm5vbi5qc1wiLFxuICAgIFwiY2Fubm9uXCIsXG4gICAgXCJwaHlzaWNzXCIsXG4gICAgXCJlbmdpbmVcIixcbiAgICBcIjNkXCJcbiAgXSxcbiAgXCJtYWluXCI6IFwiLi9zcmMvQ2Fubm9uLmpzXCIsXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiKlwiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvY2Fubm9uLmpzLmdpdFwiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvY2Fubm9uLmpzL2lzc3Vlc1wiXG4gIH0sXG4gIFwibGljZW5zZXNcIjogW1xuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcIk1JVFwiXG4gICAgfVxuICBdLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJqc2hpbnRcIjogXCJsYXRlc3RcIixcbiAgICBcInVnbGlmeS1qc1wiOiBcImxhdGVzdFwiLFxuICAgIFwibm9kZXVuaXRcIjogXCJeMC45LjBcIixcbiAgICBcImdydW50XCI6IFwifjAuNC4wXCIsXG4gICAgXCJncnVudC1jb250cmliLWpzaGludFwiOiBcIn4wLjEuMVwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1ub2RldW5pdFwiOiBcIl4wLjQuMVwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1jb25jYXRcIjogXCJ+MC4xLjNcIixcbiAgICBcImdydW50LWNvbnRyaWItdWdsaWZ5XCI6IFwiXjAuNS4xXCIsXG4gICAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwiXjIuMS40XCIsXG4gICAgXCJncnVudC1jb250cmliLXl1aWRvY1wiOiBcIl4wLjUuMlwiLFxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIipcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7fVxufVxuIiwiLy8gRXhwb3J0IGNsYXNzZXNcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHZlcnNpb24gOiAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcblxuICAgIEFBQkIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vQUFCQicpLFxuICAgIEFycmF5Q29sbGlzaW9uTWF0cml4IDogICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXgnKSxcbiAgICBCb2R5IDogICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vb2JqZWN0cy9Cb2R5JyksXG4gICAgQm94IDogICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NoYXBlcy9Cb3gnKSxcbiAgICBCcm9hZHBoYXNlIDogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKSxcbiAgICBDb25zdHJhaW50IDogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29uc3RyYWludHMvQ29uc3RyYWludCcpLFxuICAgIENvbnRhY3RFcXVhdGlvbiA6ICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyksXG4gICAgTmFycm93cGhhc2UgOiAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3dvcmxkL05hcnJvd3BoYXNlJyksXG4gICAgQ29uZVR3aXN0Q29uc3RyYWludCA6ICAgICAgICAgICByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0NvbmVUd2lzdENvbnN0cmFpbnQnKSxcbiAgICBDb250YWN0TWF0ZXJpYWwgOiAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJyksXG4gICAgQ29udmV4UG9seWhlZHJvbiA6ICAgICAgICAgICAgICByZXF1aXJlKCcuL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uJyksXG4gICAgQ3lsaW5kZXIgOiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NoYXBlcy9DeWxpbmRlcicpLFxuICAgIERpc3RhbmNlQ29uc3RyYWludCA6ICAgICAgICAgICAgcmVxdWlyZSgnLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnQnKSxcbiAgICBFcXVhdGlvbiA6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vZXF1YXRpb25zL0VxdWF0aW9uJyksXG4gICAgRXZlbnRUYXJnZXQgOiAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3V0aWxzL0V2ZW50VGFyZ2V0JyksXG4gICAgRnJpY3Rpb25FcXVhdGlvbiA6ICAgICAgICAgICAgICByZXF1aXJlKCcuL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uJyksXG4gICAgR1NTb2x2ZXIgOiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NvbHZlci9HU1NvbHZlcicpLFxuICAgIEdyaWRCcm9hZHBoYXNlIDogICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vR3JpZEJyb2FkcGhhc2UnKSxcbiAgICBIZWlnaHRmaWVsZCA6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL0hlaWdodGZpZWxkJyksXG4gICAgSGluZ2VDb25zdHJhaW50IDogICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0hpbmdlQ29uc3RyYWludCcpLFxuICAgIExvY2tDb25zdHJhaW50IDogICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb25zdHJhaW50cy9Mb2NrQ29uc3RyYWludCcpLFxuICAgIE1hdDMgOiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9tYXRoL01hdDMnKSxcbiAgICBNYXRlcmlhbCA6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbWF0ZXJpYWwvTWF0ZXJpYWwnKSxcbiAgICBOYWl2ZUJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29sbGlzaW9uL05haXZlQnJvYWRwaGFzZScpLFxuICAgIE9iamVjdENvbGxpc2lvbk1hdHJpeCA6ICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vT2JqZWN0Q29sbGlzaW9uTWF0cml4JyksXG4gICAgUG9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3V0aWxzL1Bvb2wnKSxcbiAgICBQYXJ0aWNsZSA6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL1BhcnRpY2xlJyksXG4gICAgUGxhbmUgOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NoYXBlcy9QbGFuZScpLFxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQgOiAgICAgICAgcmVxdWlyZSgnLi9jb25zdHJhaW50cy9Qb2ludFRvUG9pbnRDb25zdHJhaW50JyksXG4gICAgUXVhdGVybmlvbiA6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL21hdGgvUXVhdGVybmlvbicpLFxuICAgIFJheSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vUmF5JyksXG4gICAgUmF5Y2FzdFZlaGljbGUgOiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL29iamVjdHMvUmF5Y2FzdFZlaGljbGUnKSxcbiAgICBSYXljYXN0UmVzdWx0IDogICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKSxcbiAgICBSaWdpZFZlaGljbGUgOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vb2JqZWN0cy9SaWdpZFZlaGljbGUnKSxcbiAgICBSb3RhdGlvbmFsRXF1YXRpb24gOiAgICAgICAgICAgIHJlcXVpcmUoJy4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvbicpLFxuICAgIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uIDogICAgICAgcmVxdWlyZSgnLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb24nKSxcbiAgICBTQVBCcm9hZHBoYXNlIDogICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29sbGlzaW9uL1NBUEJyb2FkcGhhc2UnKSxcbiAgICBTUEhTeXN0ZW0gOiAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vb2JqZWN0cy9TUEhTeXN0ZW0nKSxcbiAgICBTaGFwZSA6ICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL1NoYXBlJyksXG4gICAgU29sdmVyIDogICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NvbHZlci9Tb2x2ZXInKSxcbiAgICBTcGhlcmUgOiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL1NwaGVyZScpLFxuICAgIFNwbGl0U29sdmVyIDogICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zb2x2ZXIvU3BsaXRTb2x2ZXInKSxcbiAgICBTcHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vb2JqZWN0cy9TcHJpbmcnKSxcbiAgICBUcmFuc2Zvcm0gOiAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbWF0aC9UcmFuc2Zvcm0nKSxcbiAgICBUcmltZXNoIDogICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL1RyaW1lc2gnKSxcbiAgICBWZWMzIDogICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbWF0aC9WZWMzJyksXG4gICAgVmVjM1Bvb2wgOiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3V0aWxzL1ZlYzNQb29sJyksXG4gICAgV29ybGQgOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3dvcmxkL1dvcmxkJyksXG59O1xuIiwidmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQUFCQjtcblxuLyoqXG4gKiBBeGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGNsYXNzLlxuICogQGNsYXNzIEFBQkJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtWZWMzfSAgIFtvcHRpb25zLnVwcGVyQm91bmRdXG4gKiBAcGFyYW0ge1ZlYzN9ICAgW29wdGlvbnMubG93ZXJCb3VuZF1cbiAqL1xuZnVuY3Rpb24gQUFCQihvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb3dlciBib3VuZCBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckJvdW5kXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5sb3dlckJvdW5kID0gbmV3IFZlYzMoKTtcbiAgICBpZihvcHRpb25zLmxvd2VyQm91bmQpe1xuICAgICAgICB0aGlzLmxvd2VyQm91bmQuY29weShvcHRpb25zLmxvd2VyQm91bmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckJvdW5kXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy51cHBlckJvdW5kID0gbmV3IFZlYzMoKTtcbiAgICBpZihvcHRpb25zLnVwcGVyQm91bmQpe1xuICAgICAgICB0aGlzLnVwcGVyQm91bmQuY29weShvcHRpb25zLnVwcGVyQm91bmQpO1xuICAgIH1cbn1cblxudmFyIHRtcCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogU2V0IHRoZSBBQUJCIGJvdW5kcyBmcm9tIGEgc2V0IG9mIHBvaW50cy5cbiAqIEBtZXRob2Qgc2V0RnJvbVBvaW50c1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFuIGFycmF5IG9mIFZlYzMncy5cbiAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdGVybmlvblxuICogQHBhcmFtIHtudW1iZXJ9IHNraW5TaXplXG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgc2VsZiBvYmplY3RcbiAqL1xuQUFCQi5wcm90b3R5cGUuc2V0RnJvbVBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cywgcG9zaXRpb24sIHF1YXRlcm5pb24sIHNraW5TaXplKXtcbiAgICB2YXIgbCA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdSA9IHRoaXMudXBwZXJCb3VuZCxcbiAgICAgICAgcSA9IHF1YXRlcm5pb247XG5cbiAgICAvLyBTZXQgdG8gdGhlIGZpcnN0IHBvaW50XG4gICAgbC5jb3B5KHBvaW50c1swXSk7XG4gICAgaWYocSl7XG4gICAgICAgIHEudm11bHQobCwgbCk7XG4gICAgfVxuICAgIHUuY29weShsKTtcblxuICAgIGZvcih2YXIgaSA9IDE7IGk8cG9pbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG5cbiAgICAgICAgaWYocSl7XG4gICAgICAgICAgICBxLnZtdWx0KHAsIHRtcCk7XG4gICAgICAgICAgICBwID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocC54ID4gdS54KXsgdS54ID0gcC54OyB9XG4gICAgICAgIGlmKHAueCA8IGwueCl7IGwueCA9IHAueDsgfVxuICAgICAgICBpZihwLnkgPiB1LnkpeyB1LnkgPSBwLnk7IH1cbiAgICAgICAgaWYocC55IDwgbC55KXsgbC55ID0gcC55OyB9XG4gICAgICAgIGlmKHAueiA+IHUueil7IHUueiA9IHAuejsgfVxuICAgICAgICBpZihwLnogPCBsLnopeyBsLnogPSBwLno7IH1cbiAgICB9XG5cbiAgICAvLyBBZGQgb2Zmc2V0XG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgIHBvc2l0aW9uLnZhZGQobCwgbCk7XG4gICAgICAgIHBvc2l0aW9uLnZhZGQodSwgdSk7XG4gICAgfVxuXG4gICAgaWYoc2tpblNpemUpe1xuICAgICAgICBsLnggLT0gc2tpblNpemU7XG4gICAgICAgIGwueSAtPSBza2luU2l6ZTtcbiAgICAgICAgbC56IC09IHNraW5TaXplO1xuICAgICAgICB1LnggKz0gc2tpblNpemU7XG4gICAgICAgIHUueSArPSBza2luU2l6ZTtcbiAgICAgICAgdS56ICs9IHNraW5TaXplO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb3B5IGJvdW5kcyBmcm9tIGFuIEFBQkIgdG8gdGhpcyBBQUJCXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmIgU291cmNlIHRvIGNvcHkgZnJvbVxuICogQHJldHVybiB7QUFCQn0gVGhlIHRoaXMgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5XG4gKi9cbkFBQkIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihhYWJiKXtcbiAgICB0aGlzLmxvd2VyQm91bmQuY29weShhYWJiLmxvd2VyQm91bmQpO1xuICAgIHRoaXMudXBwZXJCb3VuZC5jb3B5KGFhYmIudXBwZXJCb3VuZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb25lIGFuIEFBQkJcbiAqIEBtZXRob2QgY2xvbmVcbiAqL1xuQUFCQi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgQUFCQigpLmNvcHkodGhpcyk7XG59O1xuXG4vKipcbiAqIEV4dGVuZCB0aGlzIEFBQkIgc28gdGhhdCBpdCBjb3ZlcnMgdGhlIGdpdmVuIEFBQkIgdG9vLlxuICogQG1ldGhvZCBleHRlbmRcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuQUFCQi5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oYWFiYil7XG4gICAgdGhpcy5sb3dlckJvdW5kLnggPSBNYXRoLm1pbih0aGlzLmxvd2VyQm91bmQueCwgYWFiYi5sb3dlckJvdW5kLngpO1xuICAgIHRoaXMudXBwZXJCb3VuZC54ID0gTWF0aC5tYXgodGhpcy51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC54KTtcbiAgICB0aGlzLmxvd2VyQm91bmQueSA9IE1hdGgubWluKHRoaXMubG93ZXJCb3VuZC55LCBhYWJiLmxvd2VyQm91bmQueSk7XG4gICAgdGhpcy51cHBlckJvdW5kLnkgPSBNYXRoLm1heCh0aGlzLnVwcGVyQm91bmQueSwgYWFiYi51cHBlckJvdW5kLnkpO1xuICAgIHRoaXMubG93ZXJCb3VuZC56ID0gTWF0aC5taW4odGhpcy5sb3dlckJvdW5kLnosIGFhYmIubG93ZXJCb3VuZC56KTtcbiAgICB0aGlzLnVwcGVyQm91bmQueiA9IE1hdGgubWF4KHRoaXMudXBwZXJCb3VuZC56LCBhYWJiLnVwcGVyQm91bmQueik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBvdmVybGFwcyB0aGlzIEFBQkIuXG4gKiBAbWV0aG9kIG92ZXJsYXBzXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5BQUJCLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdTEgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgIGwyID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcblxuICAgIC8vICAgICAgbDIgICAgICAgIHUyXG4gICAgLy8gICAgICB8LS0tLS0tLS0tfFxuICAgIC8vIHwtLS0tLS0tLXxcbiAgICAvLyBsMSAgICAgICB1MVxuXG4gICAgdmFyIG92ZXJsYXBzWCA9ICgobDIueCA8PSB1MS54ICYmIHUxLnggPD0gdTIueCkgfHwgKGwxLnggPD0gdTIueCAmJiB1Mi54IDw9IHUxLngpKTtcbiAgICB2YXIgb3ZlcmxhcHNZID0gKChsMi55IDw9IHUxLnkgJiYgdTEueSA8PSB1Mi55KSB8fCAobDEueSA8PSB1Mi55ICYmIHUyLnkgPD0gdTEueSkpO1xuICAgIHZhciBvdmVybGFwc1ogPSAoKGwyLnogPD0gdTEueiAmJiB1MS56IDw9IHUyLnopIHx8IChsMS56IDw9IHUyLnogJiYgdTIueiA8PSB1MS56KSk7XG5cbiAgICByZXR1cm4gb3ZlcmxhcHNYICYmIG92ZXJsYXBzWSAmJiBvdmVybGFwc1o7XG59O1xuXG4vLyBNb3N0bHkgZm9yIGRlYnVnZ2luZ1xuQUFCQi5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbCA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdSA9IHRoaXMudXBwZXJCb3VuZDtcbiAgICByZXR1cm4gKHUueCAtIGwueCkgKiAodS55IC0gbC55KSAqICh1LnogLSBsLnopO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBpcyBmdWxseSBjb250YWluZWQgaW4gdGhpcyBBQUJCLlxuICogQG1ldGhvZCBjb250YWluc1xuICogQHBhcmFtIHtBQUJCfSBhYWJiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5BQUJCLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdTEgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgIGwyID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcblxuICAgIC8vICAgICAgbDIgICAgICAgIHUyXG4gICAgLy8gICAgICB8LS0tLS0tLS0tfFxuICAgIC8vIHwtLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gbDEgICAgICAgICAgICAgIHUxXG5cbiAgICByZXR1cm4gKFxuICAgICAgICAobDEueCA8PSBsMi54ICYmIHUxLnggPj0gdTIueCkgJiZcbiAgICAgICAgKGwxLnkgPD0gbDIueSAmJiB1MS55ID49IHUyLnkpICYmXG4gICAgICAgIChsMS56IDw9IGwyLnogJiYgdTEueiA+PSB1Mi56KVxuICAgICk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0Q29ybmVyc1xuICogQHBhcmFtIHtWZWMzfSBhXG4gKiBAcGFyYW0ge1ZlYzN9IGJcbiAqIEBwYXJhbSB7VmVjM30gY1xuICogQHBhcmFtIHtWZWMzfSBkXG4gKiBAcGFyYW0ge1ZlYzN9IGVcbiAqIEBwYXJhbSB7VmVjM30gZlxuICogQHBhcmFtIHtWZWMzfSBnXG4gKiBAcGFyYW0ge1ZlYzN9IGhcbiAqL1xuQUFCQi5wcm90b3R5cGUuZ2V0Q29ybmVycyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpe1xuICAgIHZhciBsID0gdGhpcy5sb3dlckJvdW5kLFxuICAgICAgICB1ID0gdGhpcy51cHBlckJvdW5kO1xuXG4gICAgYS5jb3B5KGwpO1xuICAgIGIuc2V0KCB1LngsIGwueSwgbC56ICk7XG4gICAgYy5zZXQoIHUueCwgdS55LCBsLnogKTtcbiAgICBkLnNldCggbC54LCB1LnksIHUueiApO1xuICAgIGUuc2V0KCB1LngsIGwueSwgbC56ICk7XG4gICAgZi5zZXQoIGwueCwgdS55LCBsLnogKTtcbiAgICBnLnNldCggbC54LCBsLnksIHUueiApO1xuICAgIGguY29weSh1KTtcbn07XG5cbnZhciB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVycyA9IFtcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKClcbl07XG5cbi8qKlxuICogR2V0IHRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBBQUJCIGluIGFub3RoZXIgZnJhbWUuXG4gKiBAbWV0aG9kIHRvTG9jYWxGcmFtZVxuICogQHBhcmFtICB7VHJhbnNmb3JtfSBmcmFtZVxuICogQHBhcmFtICB7QUFCQn0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgXCJ0YXJnZXRcIiBBQUJCIG9iamVjdC5cbiAqL1xuQUFCQi5wcm90b3R5cGUudG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24oZnJhbWUsIHRhcmdldCl7XG5cbiAgICB2YXIgY29ybmVycyA9IHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzO1xuICAgIHZhciBhID0gY29ybmVyc1swXTtcbiAgICB2YXIgYiA9IGNvcm5lcnNbMV07XG4gICAgdmFyIGMgPSBjb3JuZXJzWzJdO1xuICAgIHZhciBkID0gY29ybmVyc1szXTtcbiAgICB2YXIgZSA9IGNvcm5lcnNbNF07XG4gICAgdmFyIGYgPSBjb3JuZXJzWzVdO1xuICAgIHZhciBnID0gY29ybmVyc1s2XTtcbiAgICB2YXIgaCA9IGNvcm5lcnNbN107XG5cbiAgICAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lXG4gICAgdGhpcy5nZXRDb3JuZXJzKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZW0gdG8gbmV3IGxvY2FsIGZyYW1lXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IDg7IGkrKyl7XG4gICAgICAgIHZhciBjb3JuZXIgPSBjb3JuZXJzW2ldO1xuICAgICAgICBmcmFtZS5wb2ludFRvTG9jYWwoY29ybmVyLCBjb3JuZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQuc2V0RnJvbVBvaW50cyhjb3JuZXJzKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBBQUJCIGluIHRoZSBnbG9iYWwgZnJhbWUuXG4gKiBAbWV0aG9kIHRvV29ybGRGcmFtZVxuICogQHBhcmFtICB7VHJhbnNmb3JtfSBmcmFtZVxuICogQHBhcmFtICB7QUFCQn0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgXCJ0YXJnZXRcIiBBQUJCIG9iamVjdC5cbiAqL1xuQUFCQi5wcm90b3R5cGUudG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24oZnJhbWUsIHRhcmdldCl7XG5cbiAgICB2YXIgY29ybmVycyA9IHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzO1xuICAgIHZhciBhID0gY29ybmVyc1swXTtcbiAgICB2YXIgYiA9IGNvcm5lcnNbMV07XG4gICAgdmFyIGMgPSBjb3JuZXJzWzJdO1xuICAgIHZhciBkID0gY29ybmVyc1szXTtcbiAgICB2YXIgZSA9IGNvcm5lcnNbNF07XG4gICAgdmFyIGYgPSBjb3JuZXJzWzVdO1xuICAgIHZhciBnID0gY29ybmVyc1s2XTtcbiAgICB2YXIgaCA9IGNvcm5lcnNbN107XG5cbiAgICAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lXG4gICAgdGhpcy5nZXRDb3JuZXJzKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZW0gdG8gbmV3IGxvY2FsIGZyYW1lXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IDg7IGkrKyl7XG4gICAgICAgIHZhciBjb3JuZXIgPSBjb3JuZXJzW2ldO1xuICAgICAgICBmcmFtZS5wb2ludFRvV29ybGQoY29ybmVyLCBjb3JuZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQuc2V0RnJvbVBvaW50cyhjb3JuZXJzKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIEFBQkIgaXMgaGl0IGJ5IGEgcmF5LlxuICogQHBhcmFtICB7UmF5fSByYXlcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuQUFCQi5wcm90b3R5cGUub3ZlcmxhcHNSYXkgPSBmdW5jdGlvbihyYXkpe1xuICAgIHZhciB0ID0gMDtcblxuICAgIC8vIHJheS5kaXJlY3Rpb24gaXMgdW5pdCBkaXJlY3Rpb24gdmVjdG9yIG9mIHJheVxuICAgIHZhciBkaXJGcmFjWCA9IDEgLyByYXkuX2RpcmVjdGlvbi54O1xuICAgIHZhciBkaXJGcmFjWSA9IDEgLyByYXkuX2RpcmVjdGlvbi55O1xuICAgIHZhciBkaXJGcmFjWiA9IDEgLyByYXkuX2RpcmVjdGlvbi56O1xuXG4gICAgLy8gdGhpcy5sb3dlckJvdW5kIGlzIHRoZSBjb3JuZXIgb2YgQUFCQiB3aXRoIG1pbmltYWwgY29vcmRpbmF0ZXMgLSBsZWZ0IGJvdHRvbSwgcnQgaXMgbWF4aW1hbCBjb3JuZXJcbiAgICB2YXIgdDEgPSAodGhpcy5sb3dlckJvdW5kLnggLSByYXkuZnJvbS54KSAqIGRpckZyYWNYO1xuICAgIHZhciB0MiA9ICh0aGlzLnVwcGVyQm91bmQueCAtIHJheS5mcm9tLngpICogZGlyRnJhY1g7XG4gICAgdmFyIHQzID0gKHRoaXMubG93ZXJCb3VuZC55IC0gcmF5LmZyb20ueSkgKiBkaXJGcmFjWTtcbiAgICB2YXIgdDQgPSAodGhpcy51cHBlckJvdW5kLnkgLSByYXkuZnJvbS55KSAqIGRpckZyYWNZO1xuICAgIHZhciB0NSA9ICh0aGlzLmxvd2VyQm91bmQueiAtIHJheS5mcm9tLnopICogZGlyRnJhY1o7XG4gICAgdmFyIHQ2ID0gKHRoaXMudXBwZXJCb3VuZC56IC0gcmF5LmZyb20ueikgKiBkaXJGcmFjWjtcblxuICAgIC8vIHZhciB0bWluID0gTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5taW4odDEsIHQyKSwgTWF0aC5taW4odDMsIHQ0KSkpO1xuICAgIC8vIHZhciB0bWF4ID0gTWF0aC5taW4oTWF0aC5taW4oTWF0aC5tYXgodDEsIHQyKSwgTWF0aC5tYXgodDMsIHQ0KSkpO1xuICAgIHZhciB0bWluID0gTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5taW4odDEsIHQyKSwgTWF0aC5taW4odDMsIHQ0KSksIE1hdGgubWluKHQ1LCB0NikpO1xuICAgIHZhciB0bWF4ID0gTWF0aC5taW4oTWF0aC5taW4oTWF0aC5tYXgodDEsIHQyKSwgTWF0aC5tYXgodDMsIHQ0KSksIE1hdGgubWF4KHQ1LCB0NikpO1xuXG4gICAgLy8gaWYgdG1heCA8IDAsIHJheSAobGluZSkgaXMgaW50ZXJzZWN0aW5nIEFBQkIsIGJ1dCB3aG9sZSBBQUJCIGlzIGJlaGluZyB1c1xuICAgIGlmICh0bWF4IDwgMCl7XG4gICAgICAgIC8vdCA9IHRtYXg7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBpZiB0bWluID4gdG1heCwgcmF5IGRvZXNuJ3QgaW50ZXJzZWN0IEFBQkJcbiAgICBpZiAodG1pbiA+IHRtYXgpe1xuICAgICAgICAvL3QgPSB0bWF4O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXlDb2xsaXNpb25NYXRyaXg7XG5cbi8qKlxuICogQ29sbGlzaW9uIFwibWF0cml4XCIuIEl0J3MgYWN0dWFsbHkgYSB0cmlhbmd1bGFyLXNoYXBlZCBhcnJheSBvZiB3aGV0aGVyIHR3byBib2RpZXMgYXJlIHRvdWNoaW5nIHRoaXMgc3RlcCwgZm9yIHJlZmVyZW5jZSBuZXh0IHN0ZXBcbiAqIEBjbGFzcyBBcnJheUNvbGxpc2lvbk1hdHJpeFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEFycmF5Q29sbGlzaW9uTWF0cml4KCkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hdHJpeCBzdG9yYWdlXG4gICAgICogQHByb3BlcnR5IG1hdHJpeFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLm1hdHJpeCA9IFtdO1xufVxuXG4vKipcbiAqIEdldCBhbiBlbGVtZW50XG4gKiBAbWV0aG9kIGdldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQXJyYXlDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgICBpID0gaS5pbmRleDtcbiAgICBqID0gai5pbmRleDtcbiAgICBpZiAoaiA+IGkpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgaSA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hdHJpeFsoaSooaSArIDEpPj4xKSArIGotMV07XG59O1xuXG4vKipcbiAqIFNldCBhbiBlbGVtZW50XG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSB7TnVtYmVyfSBqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqL1xuQXJyYXlDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGksIGosIHZhbHVlKSB7XG4gICAgaSA9IGkuaW5kZXg7XG4gICAgaiA9IGouaW5kZXg7XG4gICAgaWYgKGogPiBpKSB7XG4gICAgICAgIHZhciB0ZW1wID0gajtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGkgPSB0ZW1wO1xuICAgIH1cbiAgICB0aGlzLm1hdHJpeFsoaSooaSArIDEpPj4xKSArIGotMV0gPSB2YWx1ZSA/IDEgOiAwO1xufTtcblxuLyoqXG4gKiBTZXRzIGFsbCBlbGVtZW50cyB0byB6ZXJvXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbkFycmF5Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGk9MCwgbD10aGlzLm1hdHJpeC5sZW5ndGg7IGkhPT1sOyBpKyspIHtcbiAgICAgICAgdGhpcy5tYXRyaXhbaV09MDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heCBudW1iZXIgb2Ygb2JqZWN0c1xuICogQG1ldGhvZCBzZXROdW1PYmplY3RzXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICovXG5BcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuc2V0TnVtT2JqZWN0cyA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLm1hdHJpeC5sZW5ndGggPSBuKihuLTEpPj4xO1xufTtcbiIsInZhciBCb2R5ID0gcmVxdWlyZSgnLi4vb2JqZWN0cy9Cb2R5Jyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9TaGFwZScpO1xudmFyIFBsYW5lID0gcmVxdWlyZSgnLi4vc2hhcGVzL1BsYW5lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBicm9hZHBoYXNlIGltcGxlbWVudGF0aW9uc1xuICogQGNsYXNzIEJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICovXG5mdW5jdGlvbiBCcm9hZHBoYXNlKCl7XG4gICAgLyoqXG4gICAgKiBUaGUgd29ybGQgdG8gc2VhcmNoIGZvciBjb2xsaXNpb25zIGluLlxuICAgICogQHByb3BlcnR5IHdvcmxkXG4gICAgKiBAdHlwZSB7V29ybGR9XG4gICAgKi9cbiAgICB0aGlzLndvcmxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgYnJvYWRwaGFzZSB1c2VzIGJvdW5kaW5nIGJveGVzIGZvciBpbnRlcnNlY3Rpb24gdGVzdCwgZWxzZSBpdCB1c2VzIGJvdW5kaW5nIHNwaGVyZXMuXG4gICAgICogQHByb3BlcnR5IHVzZUJvdW5kaW5nQm94ZXNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZUJvdW5kaW5nQm94ZXMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHRoZSBvYmplY3RzIGluIHRoZSB3b3JsZCBtb3ZlZC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGRpcnR5XG4gICAgICovXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2xsaXNpb24gcGFpcnMgZnJvbSB0aGUgd29ybGRcbiAqIEBtZXRob2QgY29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkIFRoZSB3b3JsZCB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSB7QXJyYXl9IHAxIEVtcHR5IGFycmF5IHRvIGJlIGZpbGxlZCB3aXRoIGJvZHkgb2JqZWN0c1xuICogQHBhcmFtIHtBcnJheX0gcDIgRW1wdHkgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggYm9keSBvYmplY3RzXG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmNvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQscDEscDIpe1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbGxpc2lvblBhaXJzIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyBCcm9hZFBoYXNlIGNsYXNzIVwiKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBib2R5IHBhaXIgbmVlZHMgdG8gYmUgaW50ZXJzZWN0aW9uIHRlc3RlZCBhdCBhbGwuXG4gKiBAbWV0aG9kIG5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbiA9IGZ1bmN0aW9uKGJvZHlBLGJvZHlCKXtcblxuICAgIC8vIENoZWNrIGNvbGxpc2lvbiBmaWx0ZXIgbWFza3NcbiAgICBpZiggKGJvZHlBLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keUIuY29sbGlzaW9uRmlsdGVyTWFzayk9PT0wIHx8IChib2R5Qi5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIGJvZHlBLmNvbGxpc2lvbkZpbHRlck1hc2spPT09MCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0eXBlc1xuICAgIGlmKCgoYm9keUEudHlwZSAmIEJvZHkuU1RBVElDKSE9PTAgfHwgYm9keUEuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORykgJiZcbiAgICAgICAoKGJvZHlCLnR5cGUgJiBCb2R5LlNUQVRJQykhPT0wIHx8IGJvZHlCLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpKSB7XG4gICAgICAgIC8vIEJvdGggYm9kaWVzIGFyZSBzdGF0aWMgb3Igc2xlZXBpbmcuIFNraXAuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHZvbHVtZXMgb2YgdHdvIGJvZGllcyBpbnRlcnNlY3QuXG4gKiBAbWV0aG9kIGludGVyc2VjdGlvblRlc3RcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7YXJyYXl9IHBhaXJzMVxuICogQHBhcmFtIHthcnJheX0gcGFpcnMyXG4gICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5pbnRlcnNlY3Rpb25UZXN0ID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCLCBwYWlyczEsIHBhaXJzMil7XG4gICAgaWYodGhpcy51c2VCb3VuZGluZ0JveGVzKXtcbiAgICAgICAgdGhpcy5kb0JvdW5kaW5nQm94QnJvYWRwaGFzZShib2R5QSxib2R5QixwYWlyczEscGFpcnMyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlKGJvZHlBLGJvZHlCLHBhaXJzMSxwYWlyczIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHNwaGVyZXMgb2YgdHdvIGJvZGllcyBhcmUgaW50ZXJzZWN0aW5nLlxuICogQG1ldGhvZCBkb0JvdW5kaW5nU3BoZXJlQnJvYWRwaGFzZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxIGJvZHlBIGlzIGFwcGVuZGVkIHRvIHRoaXMgYXJyYXkgaWYgaW50ZXJzZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczIgYm9keUIgaXMgYXBwZW5kZWQgdG8gdGhpcyBhcnJheSBpZiBpbnRlcnNlY3Rpb25cbiAqL1xudmFyIEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfciA9IG5ldyBWZWMzKCksIC8vIFRlbXAgb2JqZWN0c1xuICAgIEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfbm9ybWFsID0gIG5ldyBWZWMzKCksXG4gICAgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19xdWF0ID0gIG5ldyBRdWF0ZXJuaW9uKCksXG4gICAgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yZWxwb3MgID0gIG5ldyBWZWMzKCk7XG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5kb0JvdW5kaW5nU3BoZXJlQnJvYWRwaGFzZSA9IGZ1bmN0aW9uKGJvZHlBLGJvZHlCLHBhaXJzMSxwYWlyczIpe1xuICAgIHZhciByID0gQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yO1xuICAgIGJvZHlCLnBvc2l0aW9uLnZzdWIoYm9keUEucG9zaXRpb24scik7XG4gICAgdmFyIGJvdW5kaW5nUmFkaXVzU3VtMiA9IE1hdGgucG93KGJvZHlBLmJvdW5kaW5nUmFkaXVzICsgYm9keUIuYm91bmRpbmdSYWRpdXMsIDIpO1xuICAgIHZhciBub3JtMiA9IHIubm9ybTIoKTtcbiAgICBpZihub3JtMiA8IGJvdW5kaW5nUmFkaXVzU3VtMil7XG4gICAgICAgIHBhaXJzMS5wdXNoKGJvZHlBKTtcbiAgICAgICAgcGFpcnMyLnB1c2goYm9keUIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIGJveGVzIG9mIHR3byBib2RpZXMgYXJlIGludGVyc2VjdGluZy5cbiAqIEBtZXRob2QgZG9Cb3VuZGluZ0JveEJyb2FkcGhhc2VcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmRvQm91bmRpbmdCb3hCcm9hZHBoYXNlID0gZnVuY3Rpb24oYm9keUEsYm9keUIscGFpcnMxLHBhaXJzMil7XG4gICAgaWYoYm9keUEuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgYm9keUEuY29tcHV0ZUFBQkIoKTtcbiAgICB9XG4gICAgaWYoYm9keUIuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgYm9keUIuY29tcHV0ZUFBQkIoKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBBQUJCIC8gQUFCQlxuICAgIGlmKGJvZHlBLmFhYmIub3ZlcmxhcHMoYm9keUIuYWFiYikpe1xuICAgICAgICBwYWlyczEucHVzaChib2R5QSk7XG4gICAgICAgIHBhaXJzMi5wdXNoKGJvZHlCKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlIHBhaXJzIGZyb20gdGhlIHBhaXIgYXJyYXlzLlxuICogQG1ldGhvZCBtYWtlUGFpcnNVbmlxdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXG4gKi9cbnZhciBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV90ZW1wID0geyBrZXlzOltdIH0sXG4gICAgQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDEgPSBbXSxcbiAgICBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV9wMiA9IFtdO1xuQnJvYWRwaGFzZS5wcm90b3R5cGUubWFrZVBhaXJzVW5pcXVlID0gZnVuY3Rpb24ocGFpcnMxLHBhaXJzMil7XG4gICAgdmFyIHQgPSBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV90ZW1wLFxuICAgICAgICBwMSA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AxLFxuICAgICAgICBwMiA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AyLFxuICAgICAgICBOID0gcGFpcnMxLmxlbmd0aDtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgcDFbaV0gPSBwYWlyczFbaV07XG4gICAgICAgIHAyW2ldID0gcGFpcnMyW2ldO1xuICAgIH1cblxuICAgIHBhaXJzMS5sZW5ndGggPSAwO1xuICAgIHBhaXJzMi5sZW5ndGggPSAwO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgaWQxID0gcDFbaV0uaWQsXG4gICAgICAgICAgICBpZDIgPSBwMltpXS5pZDtcbiAgICAgICAgdmFyIGtleSA9IGlkMSA8IGlkMiA/IGlkMStcIixcIitpZDIgOiAgaWQyK1wiLFwiK2lkMTtcbiAgICAgICAgdFtrZXldID0gaTtcbiAgICAgICAgdC5rZXlzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PXQua2V5cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBrZXkgPSB0LmtleXMucG9wKCksXG4gICAgICAgICAgICBwYWlySW5kZXggPSB0W2tleV07XG4gICAgICAgIHBhaXJzMS5wdXNoKHAxW3BhaXJJbmRleF0pO1xuICAgICAgICBwYWlyczIucHVzaChwMltwYWlySW5kZXhdKTtcbiAgICAgICAgZGVsZXRlIHRba2V5XTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRvIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNhc3Nlc1xuICogQG1ldGhvZCBzZXRXb3JsZFxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuc2V0V29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBib3VuZGluZyBzcGhlcmVzIG9mIHR3byBib2RpZXMgb3ZlcmxhcC5cbiAqIEBtZXRob2QgYm91bmRpbmdTcGhlcmVDaGVja1xuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIGJzY19kaXN0ID0gbmV3IFZlYzMoKTtcbkJyb2FkcGhhc2UuYm91bmRpbmdTcGhlcmVDaGVjayA9IGZ1bmN0aW9uKGJvZHlBLGJvZHlCKXtcbiAgICB2YXIgZGlzdCA9IGJzY19kaXN0O1xuICAgIGJvZHlBLnBvc2l0aW9uLnZzdWIoYm9keUIucG9zaXRpb24sZGlzdCk7XG4gICAgcmV0dXJuIE1hdGgucG93KGJvZHlBLnNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgYm9keUIuc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMsMikgPiBkaXN0Lm5vcm0yKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIHRoZSBBQUJCLlxuICogQG1ldGhvZCBhYWJiUXVlcnlcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtICB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xuICAgIGNvbnNvbGUud2FybignLmFhYmJRdWVyeSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBCcm9hZHBoYXNlIHN1YmNsYXNzLicpO1xuICAgIHJldHVybiBbXTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBHcmlkQnJvYWRwaGFzZTtcblxudmFyIEJyb2FkcGhhc2UgPSByZXF1aXJlKCcuL0Jyb2FkcGhhc2UnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgU2hhcGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvU2hhcGUnKTtcblxuLyoqXG4gKiBBeGlzIGFsaWduZWQgdW5pZm9ybSBncmlkIGJyb2FkcGhhc2UuXG4gKiBAY2xhc3MgR3JpZEJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICogQHRvZG8gTmVlZHMgc3VwcG9ydCBmb3IgbW9yZSB0aGFuIGp1c3QgcGxhbmVzIGFuZCBzcGhlcmVzLlxuICogQHBhcmFtIHtWZWMzfSBhYWJiTWluXG4gKiBAcGFyYW0ge1ZlYzN9IGFhYmJNYXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBueCBOdW1iZXIgb2YgYm94ZXMgYWxvbmcgeFxuICogQHBhcmFtIHtOdW1iZXJ9IG55IE51bWJlciBvZiBib3hlcyBhbG9uZyB5XG4gKiBAcGFyYW0ge051bWJlcn0gbnogTnVtYmVyIG9mIGJveGVzIGFsb25nIHpcbiAqL1xuZnVuY3Rpb24gR3JpZEJyb2FkcGhhc2UoYWFiYk1pbixhYWJiTWF4LG54LG55LG56KXtcbiAgICBCcm9hZHBoYXNlLmFwcGx5KHRoaXMpO1xuICAgIHRoaXMubnggPSBueCB8fCAxMDtcbiAgICB0aGlzLm55ID0gbnkgfHwgMTA7XG4gICAgdGhpcy5ueiA9IG56IHx8IDEwO1xuICAgIHRoaXMuYWFiYk1pbiA9IGFhYmJNaW4gfHwgbmV3IFZlYzMoMTAwLDEwMCwxMDApO1xuICAgIHRoaXMuYWFiYk1heCA9IGFhYmJNYXggfHwgbmV3IFZlYzMoLTEwMCwtMTAwLC0xMDApO1xuXHR2YXIgbmJpbnMgPSB0aGlzLm54ICogdGhpcy5ueSAqIHRoaXMubno7XG5cdGlmIChuYmlucyA8PSAwKSB7XG5cdFx0dGhyb3cgXCJHcmlkQnJvYWRwaGFzZTogRWFjaCBkaW1lbnNpb24ncyBuIG11c3QgYmUgPjBcIjtcblx0fVxuICAgIHRoaXMuYmlucyA9IFtdO1xuXHR0aGlzLmJpbkxlbmd0aHMgPSBbXTsgLy9SYXRoZXIgdGhhbiBjb250aW51YWxseSByZXNpemluZyBhcnJheXMgKHRocmFzaGluZyB0aGUgbWVtb3J5KSwganVzdCByZWNvcmQgbGVuZ3RoIGFuZCBhbGxvdyB0aGVtIHRvIGdyb3dcblx0dGhpcy5iaW5zLmxlbmd0aCA9IG5iaW5zO1xuXHR0aGlzLmJpbkxlbmd0aHMubGVuZ3RoID0gbmJpbnM7XG5cdGZvciAodmFyIGk9MDtpPG5iaW5zO2krKykge1xuXHRcdHRoaXMuYmluc1tpXT1bXTtcblx0XHR0aGlzLmJpbkxlbmd0aHNbaV09MDtcblx0fVxufVxuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcbkdyaWRCcm9hZHBoYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyaWRCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEdldCBhbGwgdGhlIGNvbGxpc2lvbiBwYWlycyBpbiB0aGUgcGh5c2ljcyB3b3JsZFxuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXG4gKi9cbnZhciBHcmlkQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19kID0gbmV3IFZlYzMoKTtcbnZhciBHcmlkQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19iaW5Qb3MgPSBuZXcgVmVjMygpO1xuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlLmNvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQscGFpcnMxLHBhaXJzMil7XG4gICAgdmFyIE4gPSB3b3JsZC5udW1PYmplY3RzKCksXG4gICAgICAgIGJvZGllcyA9IHdvcmxkLmJvZGllcztcblxuICAgIHZhciBtYXggPSB0aGlzLmFhYmJNYXgsXG4gICAgICAgIG1pbiA9IHRoaXMuYWFiYk1pbixcbiAgICAgICAgbnggPSB0aGlzLm54LFxuICAgICAgICBueSA9IHRoaXMubnksXG4gICAgICAgIG56ID0gdGhpcy5uejtcblxuXHR2YXIgeHN0ZXAgPSBueSpuejtcblx0dmFyIHlzdGVwID0gbno7XG5cdHZhciB6c3RlcCA9IDE7XG5cbiAgICB2YXIgeG1heCA9IG1heC54LFxuICAgICAgICB5bWF4ID0gbWF4LnksXG4gICAgICAgIHptYXggPSBtYXgueixcbiAgICAgICAgeG1pbiA9IG1pbi54LFxuICAgICAgICB5bWluID0gbWluLnksXG4gICAgICAgIHptaW4gPSBtaW4uejtcblxuICAgIHZhciB4bXVsdCA9IG54IC8gKHhtYXgteG1pbiksXG4gICAgICAgIHltdWx0ID0gbnkgLyAoeW1heC15bWluKSxcbiAgICAgICAgem11bHQgPSBueiAvICh6bWF4LXptaW4pO1xuXG4gICAgdmFyIGJpbnNpemVYID0gKHhtYXggLSB4bWluKSAvIG54LFxuICAgICAgICBiaW5zaXplWSA9ICh5bWF4IC0geW1pbikgLyBueSxcbiAgICAgICAgYmluc2l6ZVogPSAoem1heCAtIHptaW4pIC8gbno7XG5cblx0dmFyIGJpblJhZGl1cyA9IE1hdGguc3FydChiaW5zaXplWCpiaW5zaXplWCArIGJpbnNpemVZKmJpbnNpemVZICsgYmluc2l6ZVoqYmluc2l6ZVopICogMC41O1xuXG4gICAgdmFyIHR5cGVzID0gU2hhcGUudHlwZXM7XG4gICAgdmFyIFNQSEVSRSA9ICAgICAgICAgICAgdHlwZXMuU1BIRVJFLFxuICAgICAgICBQTEFORSA9ICAgICAgICAgICAgIHR5cGVzLlBMQU5FLFxuICAgICAgICBCT1ggPSAgICAgICAgICAgICAgIHR5cGVzLkJPWCxcbiAgICAgICAgQ09NUE9VTkQgPSAgICAgICAgICB0eXBlcy5DT01QT1VORCxcbiAgICAgICAgQ09OVkVYUE9MWUhFRFJPTiA9ICB0eXBlcy5DT05WRVhQT0xZSEVEUk9OO1xuXG4gICAgdmFyIGJpbnM9dGhpcy5iaW5zLFxuXHRcdGJpbkxlbmd0aHM9dGhpcy5iaW5MZW5ndGhzLFxuICAgICAgICBOYmlucz10aGlzLmJpbnMubGVuZ3RoO1xuXG4gICAgLy8gUmVzZXQgYmluc1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmJpbnM7IGkrKyl7XG4gICAgICAgIGJpbkxlbmd0aHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBjZWlsID0gTWF0aC5jZWlsO1xuXHR2YXIgbWluID0gTWF0aC5taW47XG5cdHZhciBtYXggPSBNYXRoLm1heDtcblxuXHRmdW5jdGlvbiBhZGRCb3hUb0JpbnMoeDAseTAsejAseDEseTEsejEsYmkpIHtcblx0XHR2YXIgeG9mZjAgPSAoKHgwIC0geG1pbikgKiB4bXVsdCl8MCxcblx0XHRcdHlvZmYwID0gKCh5MCAtIHltaW4pICogeW11bHQpfDAsXG5cdFx0XHR6b2ZmMCA9ICgoejAgLSB6bWluKSAqIHptdWx0KXwwLFxuXHRcdFx0eG9mZjEgPSBjZWlsKCh4MSAtIHhtaW4pICogeG11bHQpLFxuXHRcdFx0eW9mZjEgPSBjZWlsKCh5MSAtIHltaW4pICogeW11bHQpLFxuXHRcdFx0em9mZjEgPSBjZWlsKCh6MSAtIHptaW4pICogem11bHQpO1xuXG5cdFx0aWYgKHhvZmYwIDwgMCkgeyB4b2ZmMCA9IDA7IH0gZWxzZSBpZiAoeG9mZjAgPj0gbngpIHsgeG9mZjAgPSBueCAtIDE7IH1cblx0XHRpZiAoeW9mZjAgPCAwKSB7IHlvZmYwID0gMDsgfSBlbHNlIGlmICh5b2ZmMCA+PSBueSkgeyB5b2ZmMCA9IG55IC0gMTsgfVxuXHRcdGlmICh6b2ZmMCA8IDApIHsgem9mZjAgPSAwOyB9IGVsc2UgaWYgKHpvZmYwID49IG56KSB7IHpvZmYwID0gbnogLSAxOyB9XG5cdFx0aWYgKHhvZmYxIDwgMCkgeyB4b2ZmMSA9IDA7IH0gZWxzZSBpZiAoeG9mZjEgPj0gbngpIHsgeG9mZjEgPSBueCAtIDE7IH1cblx0XHRpZiAoeW9mZjEgPCAwKSB7IHlvZmYxID0gMDsgfSBlbHNlIGlmICh5b2ZmMSA+PSBueSkgeyB5b2ZmMSA9IG55IC0gMTsgfVxuXHRcdGlmICh6b2ZmMSA8IDApIHsgem9mZjEgPSAwOyB9IGVsc2UgaWYgKHpvZmYxID49IG56KSB7IHpvZmYxID0gbnogLSAxOyB9XG5cblx0XHR4b2ZmMCAqPSB4c3RlcDtcblx0XHR5b2ZmMCAqPSB5c3RlcDtcblx0XHR6b2ZmMCAqPSB6c3RlcDtcblx0XHR4b2ZmMSAqPSB4c3RlcDtcblx0XHR5b2ZmMSAqPSB5c3RlcDtcblx0XHR6b2ZmMSAqPSB6c3RlcDtcblxuXHRcdGZvciAodmFyIHhvZmYgPSB4b2ZmMDsgeG9mZiA8PSB4b2ZmMTsgeG9mZiArPSB4c3RlcCkge1xuXHRcdFx0Zm9yICh2YXIgeW9mZiA9IHlvZmYwOyB5b2ZmIDw9IHlvZmYxOyB5b2ZmICs9IHlzdGVwKSB7XG5cdFx0XHRcdGZvciAodmFyIHpvZmYgPSB6b2ZmMDsgem9mZiA8PSB6b2ZmMTsgem9mZiArPSB6c3RlcCkge1xuXHRcdFx0XHRcdHZhciBpZHggPSB4b2ZmK3lvZmYrem9mZjtcblx0XHRcdFx0XHRiaW5zW2lkeF1bYmluTGVuZ3Roc1tpZHhdKytdID0gYmk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuICAgIC8vIFB1dCBhbGwgYm9kaWVzIGludG8gdGhlIGJpbnNcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcbiAgICAgICAgdmFyIHNpID0gYmkuc2hhcGU7XG5cbiAgICAgICAgc3dpdGNoKHNpLnR5cGUpe1xuICAgICAgICBjYXNlIFNQSEVSRTpcbiAgICAgICAgICAgIC8vIFB1dCBpbiBiaW5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG92ZXJsYXAgd2l0aCBvdGhlciBiaW5zXG4gICAgICAgICAgICB2YXIgeCA9IGJpLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeSA9IGJpLnBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgeiA9IGJpLnBvc2l0aW9uLno7XG4gICAgICAgICAgICB2YXIgciA9IHNpLnJhZGl1cztcblxuXHRcdFx0YWRkQm94VG9CaW5zKHgtciwgeS1yLCB6LXIsIHgrciwgeStyLCB6K3IsIGJpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUExBTkU6XG4gICAgICAgICAgICBpZihzaS53b3JsZE5vcm1hbE5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgICAgICBzaS5jb21wdXRlV29ybGROb3JtYWwoYmkucXVhdGVybmlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGxhbmVOb3JtYWwgPSBzaS53b3JsZE5vcm1hbDtcblxuXHRcdFx0Ly9SZWxhdGl2ZSBwb3NpdGlvbiBmcm9tIG9yaWdpbiBvZiBwbGFuZSBvYmplY3QgdG8gdGhlIGZpcnN0IGJpblxuXHRcdFx0Ly9JbmNyZW1lbnRlZCBhcyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIGJpbnNcblx0XHRcdHZhciB4cmVzZXQgPSB4bWluICsgYmluc2l6ZVgqMC41IC0gYmkucG9zaXRpb24ueCxcblx0XHRcdFx0eXJlc2V0ID0geW1pbiArIGJpbnNpemVZKjAuNSAtIGJpLnBvc2l0aW9uLnksXG5cdFx0XHRcdHpyZXNldCA9IHptaW4gKyBiaW5zaXplWiowLjUgLSBiaS5wb3NpdGlvbi56O1xuXG4gICAgICAgICAgICB2YXIgZCA9IEdyaWRCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX2Q7XG5cdFx0XHRkLnNldCh4cmVzZXQsIHlyZXNldCwgenJlc2V0KTtcblxuXHRcdFx0Zm9yICh2YXIgeGkgPSAwLCB4b2ZmID0gMDsgeGkgIT09IG54OyB4aSsrLCB4b2ZmICs9IHhzdGVwLCBkLnkgPSB5cmVzZXQsIGQueCArPSBiaW5zaXplWCkge1xuXHRcdFx0XHRmb3IgKHZhciB5aSA9IDAsIHlvZmYgPSAwOyB5aSAhPT0gbnk7IHlpKyssIHlvZmYgKz0geXN0ZXAsIGQueiA9IHpyZXNldCwgZC55ICs9IGJpbnNpemVZKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgemkgPSAwLCB6b2ZmID0gMDsgemkgIT09IG56OyB6aSsrLCB6b2ZmICs9IHpzdGVwLCBkLnogKz0gYmluc2l6ZVopIHtcblx0XHRcdFx0XHRcdGlmIChkLmRvdChwbGFuZU5vcm1hbCkgPCBiaW5SYWRpdXMpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGlkeCA9IHhvZmYgKyB5b2ZmICsgem9mZjtcblx0XHRcdFx0XHRcdFx0Ymluc1tpZHhdW2Jpbkxlbmd0aHNbaWR4XSsrXSA9IGJpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcblx0XHRcdGlmIChiaS5hYWJiTmVlZHNVcGRhdGUpIHtcblx0XHRcdFx0YmkuY29tcHV0ZUFBQkIoKTtcblx0XHRcdH1cblxuXHRcdFx0YWRkQm94VG9CaW5zKFxuXHRcdFx0XHRiaS5hYWJiLmxvd2VyQm91bmQueCxcblx0XHRcdFx0YmkuYWFiYi5sb3dlckJvdW5kLnksXG5cdFx0XHRcdGJpLmFhYmIubG93ZXJCb3VuZC56LFxuXHRcdFx0XHRiaS5hYWJiLnVwcGVyQm91bmQueCxcblx0XHRcdFx0YmkuYWFiYi51cHBlckJvdW5kLnksXG5cdFx0XHRcdGJpLmFhYmIudXBwZXJCb3VuZC56LFxuXHRcdFx0XHRiaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGVhY2ggYmluXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYmluczsgaSsrKXtcblx0XHR2YXIgYmluTGVuZ3RoID0gYmluTGVuZ3Roc1tpXTtcblx0XHQvL1NraXAgYmlucyB3aXRoIG5vIHBvdGVudGlhbCBjb2xsaXNpb25zXG5cdFx0aWYgKGJpbkxlbmd0aCA+IDEpIHtcblx0XHRcdHZhciBiaW4gPSBiaW5zW2ldO1xuXG5cdFx0XHQvLyBEbyBOXjIgYnJvYWRwaGFzZSBpbnNpZGVcblx0XHRcdGZvcih2YXIgeGk9MDsgeGkhPT1iaW5MZW5ndGg7IHhpKyspe1xuXHRcdFx0XHR2YXIgYmkgPSBiaW5beGldO1xuXHRcdFx0XHRmb3IodmFyIHlpPTA7IHlpIT09eGk7IHlpKyspe1xuXHRcdFx0XHRcdHZhciBiaiA9IGJpblt5aV07XG5cdFx0XHRcdFx0aWYodGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSxiaikpe1xuXHRcdFx0XHRcdFx0dGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLGJqLHBhaXJzMSxwYWlyczIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cbiAgICB9XG5cbi8vXHRmb3IgKHZhciB6aSA9IDAsIHpvZmY9MDsgemkgPCBuejsgemkrKywgem9mZis9IHpzdGVwKSB7XG4vL1x0XHRjb25zb2xlLmxvZyhcImxheWVyIFwiK3ppKTtcbi8vXHRcdGZvciAodmFyIHlpID0gMCwgeW9mZj0wOyB5aSA8IG55OyB5aSsrLCB5b2ZmICs9IHlzdGVwKSB7XG4vL1x0XHRcdHZhciByb3cgPSAnJztcbi8vXHRcdFx0Zm9yICh2YXIgeGkgPSAwLCB4b2ZmPTA7IHhpIDwgbng7IHhpKyssIHhvZmYgKz0geHN0ZXApIHtcbi8vXHRcdFx0XHR2YXIgaWR4ID0geG9mZiArIHlvZmYgKyB6b2ZmO1xuLy9cdFx0XHRcdHJvdyArPSAnICcgKyBiaW5MZW5ndGhzW2lkeF07XG4vL1x0XHRcdH1cbi8vXHRcdFx0Y29uc29sZS5sb2cocm93KTtcbi8vXHRcdH1cbi8vXHR9XG5cbiAgICB0aGlzLm1ha2VQYWlyc1VuaXF1ZShwYWlyczEscGFpcnMyKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IE5haXZlQnJvYWRwaGFzZTtcblxudmFyIEJyb2FkcGhhc2UgPSByZXF1aXJlKCcuL0Jyb2FkcGhhc2UnKTtcbnZhciBBQUJCID0gcmVxdWlyZSgnLi9BQUJCJyk7XG5cbi8qKlxuICogTmFpdmUgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbiwgdXNlZCBpbiBsYWNrIG9mIGJldHRlciBvbmVzLlxuICogQGNsYXNzIE5haXZlQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZGVzY3JpcHRpb24gVGhlIG5haXZlIGJyb2FkcGhhc2UgbG9va3MgYXQgYWxsIHBvc3NpYmxlIHBhaXJzIHdpdGhvdXQgcmVzdHJpY3Rpb24sIHRoZXJlZm9yZSBpdCBoYXMgY29tcGxleGl0eSBOXjIgKHdoaWNoIGlzIGJhZClcbiAqIEBleHRlbmRzIEJyb2FkcGhhc2VcbiAqL1xuZnVuY3Rpb24gTmFpdmVCcm9hZHBoYXNlKCl7XG4gICAgQnJvYWRwaGFzZS5hcHBseSh0aGlzKTtcbn1cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5haXZlQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBHZXQgYWxsIHRoZSBjb2xsaXNpb24gcGFpcnMgaW4gdGhlIHBoeXNpY3Mgd29ybGRcbiAqIEBtZXRob2QgY29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczFcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMlxuICovXG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmNvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQscGFpcnMxLHBhaXJzMil7XG4gICAgdmFyIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgbiA9IGJvZGllcy5sZW5ndGgsXG4gICAgICAgIGksaixiaSxiajtcblxuICAgIC8vIE5haXZlIE5eMiBmdHchXG4gICAgZm9yKGk9MDsgaSE9PW47IGkrKyl7XG4gICAgICAgIGZvcihqPTA7IGohPT1pOyBqKyspe1xuXG4gICAgICAgICAgICBiaSA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgIGJqID0gYm9kaWVzW2pdO1xuXG4gICAgICAgICAgICBpZighdGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSxiaikpe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvblRlc3QoYmksYmoscGFpcnMxLHBhaXJzMik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgdG1wQUFCQiA9IG5ldyBBQUJCKCk7XG5cbi8qKlxuICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gYW4gQUFCQi5cbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24od29ybGQsIGFhYmIsIHJlc3VsdCl7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHdvcmxkLmJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gd29ybGQuYm9kaWVzW2ldO1xuXG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGIuY29tcHV0ZUFBQkIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVnbHkgaGFjayB1bnRpbCBCb2R5IGdldHMgYWFiYlxuICAgICAgICBpZihiLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IE9iamVjdENvbGxpc2lvbk1hdHJpeDtcblxuLyoqXG4gKiBSZWNvcmRzIHdoYXQgb2JqZWN0cyBhcmUgY29sbGlkaW5nIHdpdGggZWFjaCBvdGhlclxuICogQGNsYXNzIE9iamVjdENvbGxpc2lvbk1hdHJpeFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE9iamVjdENvbGxpc2lvbk1hdHJpeCgpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXRyaXggc3RvcmFnZVxuICAgICAqIEBwcm9wZXJ0eSBtYXRyaXhcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXHR0aGlzLm1hdHJpeCA9IHt9O1xufVxuXG4vKipcbiAqIEBtZXRob2QgZ2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5PYmplY3RDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGksIGopIHtcblx0aSA9IGkuaWQ7XG5cdGogPSBqLmlkO1xuICAgIGlmIChqID4gaSkge1xuICAgICAgICB2YXIgdGVtcCA9IGo7XG4gICAgICAgIGogPSBpO1xuICAgICAgICBpID0gdGVtcDtcbiAgICB9XG5cdHJldHVybiBpKyctJytqIGluIHRoaXMubWF0cml4O1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICovXG5PYmplY3RDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGksIGosIHZhbHVlKSB7XG5cdGkgPSBpLmlkO1xuXHRqID0gai5pZDtcbiAgICBpZiAoaiA+IGkpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgaSA9IHRlbXA7XG5cdH1cblx0aWYgKHZhbHVlKSB7XG5cdFx0dGhpcy5tYXRyaXhbaSsnLScral0gPSB0cnVlO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGRlbGV0ZSB0aGlzLm1hdHJpeFtpKyctJytqXTtcblx0fVxufTtcblxuLyoqXG4gKiBFbXB0eSB0aGUgbWF0cml4XG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbk9iamVjdENvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5tYXRyaXggPSB7fTtcbn07XG5cbi8qKlxuICogU2V0IG1heCBudW1iZXIgb2Ygb2JqZWN0c1xuICogQG1ldGhvZCBzZXROdW1PYmplY3RzXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICovXG5PYmplY3RDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnNldE51bU9iamVjdHMgPSBmdW5jdGlvbihuKSB7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBPdmVybGFwS2VlcGVyO1xuXG4vKipcbiAqIEBjbGFzcyBPdmVybGFwS2VlcGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gT3ZlcmxhcEtlZXBlcigpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSBbXTtcbiAgICB0aGlzLnByZXZpb3VzID0gW107XG59XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uKGksIGopIHtcbiAgICBpZiAoaiA8IGkpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgaSA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiAoaSA8PCAxNikgfCBqO1xufTtcblxuXG4vKipcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHBhcmFtIHtOdW1iZXJ9IGpcbiAqL1xuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaikge1xuICAgIC8vIEluc2VydGlvbiBzb3J0LiBUaGlzIHdheSB0aGUgZGlmZiB3aWxsIGhhdmUgbGluZWFyIGNvbXBsZXhpdHkuXG4gICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGksIGopO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUoa2V5ID4gY3VycmVudFtpbmRleF0pe1xuICAgICAgICBpbmRleCsrO1xuICAgIH1cbiAgICBpZihrZXkgPT09IGN1cnJlbnRbaW5kZXhdKXtcbiAgICAgICAgcmV0dXJuOyAvLyBQYWlyIHdhcyBhbHJlYWR5IGFkZGVkXG4gICAgfVxuICAgIGZvcih2YXIgaj1jdXJyZW50Lmxlbmd0aC0xOyBqPj1pbmRleDsgai0tKXtcbiAgICAgICAgY3VycmVudFtqICsgMV0gPSBjdXJyZW50W2pdO1xuICAgIH1cbiAgICBjdXJyZW50W2luZGV4XSA9IGtleTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB0aWNrXG4gKi9cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG1wID0gdGhpcy5jdXJyZW50O1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMucHJldmlvdXM7XG4gICAgdGhpcy5wcmV2aW91cyA9IHRtcDtcbiAgICB0aGlzLmN1cnJlbnQubGVuZ3RoID0gMDtcbn07XG5cbmZ1bmN0aW9uIHVucGFja0FuZFB1c2goYXJyYXksIGtleSl7XG4gICAgYXJyYXkucHVzaCgoa2V5ICYgMHhGRkZGMDAwMCkgPj4gMTYsIGtleSAmIDB4MDAwMEZGRkYpO1xufVxuXG4vKipcbiAqIEBtZXRob2QgZ2V0RGlmZlxuICogQHBhcmFtICB7YXJyYXl9IGFkZGl0aW9uc1xuICogQHBhcmFtICB7YXJyYXl9IHJlbW92YWxzXG4gKi9cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldERpZmYgPSBmdW5jdGlvbihhZGRpdGlvbnMsIHJlbW92YWxzKSB7XG4gICAgdmFyIGEgPSB0aGlzLmN1cnJlbnQ7XG4gICAgdmFyIGIgPSB0aGlzLnByZXZpb3VzO1xuICAgIHZhciBhbCA9IGEubGVuZ3RoO1xuICAgIHZhciBibCA9IGIubGVuZ3RoO1xuXG4gICAgdmFyIGo9MDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsOyBpKyspIHtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgIHZhciBrZXlBID0gYVtpXTtcbiAgICAgICAgd2hpbGUoa2V5QSA+IGJbal0pe1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kID0ga2V5QSA9PT0gYltqXTtcblxuICAgICAgICBpZighZm91bmQpe1xuICAgICAgICAgICAgdW5wYWNrQW5kUHVzaChhZGRpdGlvbnMsIGtleUEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGogPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmw7IGkrKykge1xuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGtleUIgPSBiW2ldO1xuICAgICAgICB3aGlsZShrZXlCID4gYVtqXSl7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgZm91bmQgPSBhW2pdID09PSBrZXlCO1xuXG4gICAgICAgIGlmKCFmb3VuZCl7XG4gICAgICAgICAgICB1bnBhY2tBbmRQdXNoKHJlbW92YWxzLCBrZXlCKTtcbiAgICAgICAgfVxuICAgIH1cbn07IiwibW9kdWxlLmV4cG9ydHMgPSBSYXk7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL21hdGgvVHJhbnNmb3JtJyk7XG52YXIgQ29udmV4UG9seWhlZHJvbiA9IHJlcXVpcmUoJy4uL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uJyk7XG52YXIgQm94ID0gcmVxdWlyZSgnLi4vc2hhcGVzL0JveCcpO1xudmFyIFJheWNhc3RSZXN1bHQgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xudmFyIFNoYXBlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgQUFCQiA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9BQUJCJyk7XG5cbi8qKlxuICogQSBsaW5lIGluIDNEIHNwYWNlIHRoYXQgaW50ZXJzZWN0cyBib2RpZXMgYW5kIHJldHVybiBwb2ludHMuXG4gKiBAY2xhc3MgUmF5XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VmVjM30gZnJvbVxuICogQHBhcmFtIHtWZWMzfSB0b1xuICovXG5mdW5jdGlvbiBSYXkoZnJvbSwgdG8pe1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gZnJvbVxuICAgICAqL1xuICAgIHRoaXMuZnJvbSA9IGZyb20gPyBmcm9tLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSB0b1xuICAgICAqL1xuICAgIHRoaXMudG8gPSB0byA/IHRvLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IF9kaXJlY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLl9kaXJlY3Rpb24gPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZWNpc2lvbiBvZiB0aGUgcmF5LiBVc2VkIHdoZW4gY2hlY2tpbmcgcGFyYWxsZWxpdHkgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBwcmVjaXNpb25cbiAgICAgKi9cbiAgICB0aGlzLnByZWNpc2lvbiA9IDAuMDAwMTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSBSYXkgdG8gdGFrZSAuY29sbGlzaW9uUmVzcG9uc2UgZmxhZ3MgaW50byBhY2NvdW50IG9uIGJvZGllcyBhbmQgc2hhcGVzLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY2hlY2tDb2xsaXNpb25SZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHJheSBza2lwcyBhbnkgaGl0cyB3aXRoIG5vcm1hbC5kb3QocmF5RGlyZWN0aW9uKSA8IDAuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBza2lwQmFja2ZhY2VzXG4gICAgICovXG4gICAgdGhpcy5za2lwQmFja2ZhY2VzID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY29sbGlzaW9uRmlsdGVyTWFza1xuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY29sbGlzaW9uRmlsdGVyR3JvdXBcbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnNlY3Rpb24gbW9kZS4gU2hvdWxkIGJlIFJheS5BTlksIFJheS5BTEwgb3IgUmF5LkNMT1NFU1QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vZGVcbiAgICAgKi9cbiAgICB0aGlzLm1vZGUgPSBSYXkuQU5ZO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCByZXN1bHQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gICAgICovXG4gICAgdGhpcy5yZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBiZSBzZXQgdG8gdHJ1ZSBkdXJpbmcgaW50ZXJzZWN0V29ybGQoKSBpZiB0aGUgcmF5IGhpdCBhbnl0aGluZy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGhhc0hpdFxuICAgICAqL1xuICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50LCB1c2VyLXByb3ZpZGVkIHJlc3VsdCBjYWxsYmFjay4gV2lsbCBiZSB1c2VkIGlmIG1vZGUgaXMgUmF5LkFMTC5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHRoaXMuY2FsbGJhY2sgPSBmdW5jdGlvbihyZXN1bHQpe307XG59XG5SYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmF5O1xuXG5SYXkuQ0xPU0VTVCA9IDE7XG5SYXkuQU5ZID0gMjtcblJheS5BTEwgPSA0O1xuXG52YXIgdG1wQUFCQiA9IG5ldyBBQUJCKCk7XG52YXIgdG1wQXJyYXkgPSBbXTtcblxuLyoqXG4gKiBEbyBpdGVyc2VjdGlvbiBhZ2FpbnN0IGFsbCBib2RpZXMgaW4gdGhlIGdpdmVuIFdvcmxkLlxuICogQG1ldGhvZCBpbnRlcnNlY3RXb3JsZFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHJheSBoaXQgYW55dGhpbmcsIG90aGVyd2lzZSBmYWxzZS5cbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RXb3JsZCA9IGZ1bmN0aW9uICh3b3JsZCwgb3B0aW9ucykge1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCBSYXkuQU5ZO1xuICAgIHRoaXMucmVzdWx0ID0gb3B0aW9ucy5yZXN1bHQgfHwgbmV3IFJheWNhc3RSZXN1bHQoKTtcbiAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSAhIW9wdGlvbnMuc2tpcEJhY2tmYWNlcztcbiAgICB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2sgPSB0eXBlb2Yob3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgOiAtMTtcbiAgICB0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwID0gdHlwZW9mKG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXApICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXAgOiAtMTtcbiAgICBpZihvcHRpb25zLmZyb20pe1xuICAgICAgICB0aGlzLmZyb20uY29weShvcHRpb25zLmZyb20pO1xuICAgIH1cbiAgICBpZihvcHRpb25zLnRvKXtcbiAgICAgICAgdGhpcy50by5jb3B5KG9wdGlvbnMudG8pO1xuICAgIH1cbiAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpe307XG4gICAgdGhpcy5oYXNIaXQgPSBmYWxzZTtcblxuICAgIHRoaXMucmVzdWx0LnJlc2V0KCk7XG4gICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCk7XG5cbiAgICB0aGlzLmdldEFBQkIodG1wQUFCQik7XG4gICAgdG1wQXJyYXkubGVuZ3RoID0gMDtcbiAgICB3b3JsZC5icm9hZHBoYXNlLmFhYmJRdWVyeSh3b3JsZCwgdG1wQUFCQiwgdG1wQXJyYXkpO1xuICAgIHRoaXMuaW50ZXJzZWN0Qm9kaWVzKHRtcEFycmF5KTtcblxuICAgIHJldHVybiB0aGlzLmhhc0hpdDtcbn07XG5cbnZhciB2MSA9IG5ldyBWZWMzKCksXG4gICAgdjIgPSBuZXcgVmVjMygpO1xuXG4vKlxuICogQXMgcGVyIFwiQmFyeWNlbnRyaWMgVGVjaG5pcXVlXCIgYXMgbmFtZWQgaGVyZSBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvZGVmYXVsdC5odG1sIEJ1dCB3aXRob3V0IHRoZSBkaXZpc2lvblxuICovXG5SYXkucG9pbnRJblRyaWFuZ2xlID0gcG9pbnRJblRyaWFuZ2xlO1xuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKHAsIGEsIGIsIGMpIHtcbiAgICBjLnZzdWIoYSx2MCk7XG4gICAgYi52c3ViKGEsdjEpO1xuICAgIHAudnN1YihhLHYyKTtcblxuICAgIHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcbiAgICB2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XG4gICAgdmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xuICAgIHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcbiAgICB2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XG5cbiAgICB2YXIgdSx2O1xuXG4gICAgcmV0dXJuICAoICh1ID0gZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpID49IDAgKSAmJlxuICAgICAgICAgICAgKCAodiA9IGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSA+PSAwICkgJiZcbiAgICAgICAgICAgICggdSArIHYgPCAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICkgKTtcbn1cblxuLyoqXG4gKiBTaG9vdCBhIHJheSBhdCBhIGJvZHksIGdldCBiYWNrIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXQuXG4gKiBAbWV0aG9kIGludGVyc2VjdEJvZHlcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZCAtIHNldCB0aGUgcmVzdWx0IHByb3BlcnR5IG9mIHRoZSBSYXkgaW5zdGVhZC5cbiAqL1xudmFyIGludGVyc2VjdEJvZHlfeGkgPSBuZXcgVmVjMygpO1xudmFyIGludGVyc2VjdEJvZHlfcWkgPSBuZXcgUXVhdGVybmlvbigpO1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb2R5ID0gZnVuY3Rpb24gKGJvZHksIHJlc3VsdCkge1xuICAgIGlmKHJlc3VsdCl7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oKTtcbiAgICB9XG4gICAgdmFyIGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U7XG5cbiAgICBpZihjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFib2R5LmNvbGxpc2lvblJlc3BvbnNlKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKCh0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keS5jb2xsaXNpb25GaWx0ZXJNYXNrKT09PTAgfHwgKGJvZHkuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2spPT09MCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgeGkgPSBpbnRlcnNlY3RCb2R5X3hpO1xuICAgIHZhciBxaSA9IGludGVyc2VjdEJvZHlfcWk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgTiA9IGJvZHkuc2hhcGVzLmxlbmd0aDsgaSA8IE47IGkrKykge1xuICAgICAgICB2YXIgc2hhcGUgPSBib2R5LnNoYXBlc1tpXTtcblxuICAgICAgICBpZihjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFzaGFwZS5jb2xsaXNpb25SZXNwb25zZSl7XG4gICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcFxuICAgICAgICB9XG5cbiAgICAgICAgYm9keS5xdWF0ZXJuaW9uLm11bHQoYm9keS5zaGFwZU9yaWVudGF0aW9uc1tpXSwgcWkpO1xuICAgICAgICBib2R5LnF1YXRlcm5pb24udm11bHQoYm9keS5zaGFwZU9mZnNldHNbaV0sIHhpKTtcbiAgICAgICAgeGkudmFkZChib2R5LnBvc2l0aW9uLCB4aSk7XG5cbiAgICAgICAgdGhpcy5pbnRlcnNlY3RTaGFwZShcbiAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgcWksXG4gICAgICAgICAgICB4aSxcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgKTtcblxuICAgICAgICBpZih0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcCl7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RCb2RpZXNcbiAqIEBwYXJhbSB7QXJyYXl9IGJvZGllcyBBbiBhcnJheSBvZiBCb2R5IG9iamVjdHMuXG4gKiBAcGFyYW0ge1JheWNhc3RSZXN1bHR9IFtyZXN1bHRdIERlcHJlY2F0ZWRcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb2RpZXMgPSBmdW5jdGlvbiAoYm9kaWVzLCByZXN1bHQpIHtcbiAgICBpZihyZXN1bHQpe1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gYm9kaWVzLmxlbmd0aDsgIXRoaXMucmVzdWx0Ll9zaG91bGRTdG9wICYmIGkgPCBsOyBpICsrICkge1xuICAgICAgICB0aGlzLmludGVyc2VjdEJvZHkoYm9kaWVzW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIF9kaXJlY3Rpb24gdmVjdG9yLlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgX3VwZGF0ZURpcmVjdGlvblxuICovXG5SYXkucHJvdG90eXBlLl91cGRhdGVEaXJlY3Rpb24gPSBmdW5jdGlvbigpe1xuICAgIHRoaXMudG8udnN1Yih0aGlzLmZyb20sIHRoaXMuX2RpcmVjdGlvbik7XG4gICAgdGhpcy5fZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFNoYXBlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdFxuICogQHBhcmFtIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0U2hhcGUgPSBmdW5jdGlvbihzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHkpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuXG5cbiAgICAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZVxuICAgIHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbihmcm9tLCB0aGlzLl9kaXJlY3Rpb24sIHBvc2l0aW9uKTtcbiAgICBpZiAoIGRpc3RhbmNlID4gc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW50ZXJzZWN0TWV0aG9kID0gdGhpc1tzaGFwZS50eXBlXTtcbiAgICBpZihpbnRlcnNlY3RNZXRob2Qpe1xuICAgICAgICBpbnRlcnNlY3RNZXRob2QuY2FsbCh0aGlzLCBzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHNoYXBlKTtcbiAgICB9XG59O1xuXG52YXIgdmVjdG9yID0gbmV3IFZlYzMoKTtcbnZhciBub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIGludGVyc2VjdFBvaW50ID0gbmV3IFZlYzMoKTtcblxudmFyIGEgPSBuZXcgVmVjMygpO1xudmFyIGIgPSBuZXcgVmVjMygpO1xudmFyIGMgPSBuZXcgVmVjMygpO1xudmFyIGQgPSBuZXcgVmVjMygpO1xuXG52YXIgdG1wUmF5Y2FzdFJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RCb3hcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0Qm94ID0gZnVuY3Rpb24oc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCByZXBvcnRlZFNoYXBlKXtcbiAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RDb252ZXgoc2hhcGUuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSk7XG59O1xuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1hdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb3g7XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RQbGFuZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RQbGFuZSA9IGZ1bmN0aW9uKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uO1xuXG4gICAgLy8gR2V0IHBsYW5lIG5vcm1hbFxuICAgIHZhciB3b3JsZE5vcm1hbCA9IG5ldyBWZWMzKDAsIDAsIDEpO1xuICAgIHF1YXQudm11bHQod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsKTtcblxuICAgIHZhciBsZW4gPSBuZXcgVmVjMygpO1xuICAgIGZyb20udnN1Yihwb3NpdGlvbiwgbGVuKTtcbiAgICB2YXIgcGxhbmVUb0Zyb20gPSBsZW4uZG90KHdvcmxkTm9ybWFsKTtcbiAgICB0by52c3ViKHBvc2l0aW9uLCBsZW4pO1xuICAgIHZhciBwbGFuZVRvVG8gPSBsZW4uZG90KHdvcmxkTm9ybWFsKTtcblxuICAgIGlmKHBsYW5lVG9Gcm9tICogcGxhbmVUb1RvID4gMCl7XG4gICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgYXJlIG9uIHRoZSBzYW1lIHNpZGUgb2YgdGhlIHBsYW5lLi4uIGJhaWwgb3V0XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZihmcm9tLmRpc3RhbmNlVG8odG8pIDwgcGxhbmVUb0Zyb20pe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5fZG90X2RpciA9IHdvcmxkTm9ybWFsLmRvdChkaXJlY3Rpb24pO1xuXG4gICAgaWYgKE1hdGguYWJzKG5fZG90X2RpcikgPCB0aGlzLnByZWNpc2lvbikge1xuICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb25cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwbGFuZVBvaW50VG9Gcm9tID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgZGlyX3NjYWxlZF93aXRoX3QgPSBuZXcgVmVjMygpO1xuICAgIHZhciBoaXRQb2ludFdvcmxkID0gbmV3IFZlYzMoKTtcblxuICAgIGZyb20udnN1Yihwb3NpdGlvbiwgcGxhbmVQb2ludFRvRnJvbSk7XG4gICAgdmFyIHQgPSAtd29ybGROb3JtYWwuZG90KHBsYW5lUG9pbnRUb0Zyb20pIC8gbl9kb3RfZGlyO1xuICAgIGRpcmVjdGlvbi5zY2FsZSh0LCBkaXJfc2NhbGVkX3dpdGhfdCk7XG4gICAgZnJvbS52YWRkKGRpcl9zY2FsZWRfd2l0aF90LCBoaXRQb2ludFdvcmxkKTtcblxuICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsLCBoaXRQb2ludFdvcmxkLCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7XG59O1xuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORV0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdFBsYW5lO1xuXG4vKipcbiAqIEdldCB0aGUgd29ybGQgQUFCQiBvZiB0aGUgcmF5LlxuICogQG1ldGhvZCBnZXRBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKi9cblJheS5wcm90b3R5cGUuZ2V0QUFCQiA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICByZXN1bHQubG93ZXJCb3VuZC54ID0gTWF0aC5taW4odG8ueCwgZnJvbS54KTtcbiAgICByZXN1bHQubG93ZXJCb3VuZC55ID0gTWF0aC5taW4odG8ueSwgZnJvbS55KTtcbiAgICByZXN1bHQubG93ZXJCb3VuZC56ID0gTWF0aC5taW4odG8ueiwgZnJvbS56KTtcbiAgICByZXN1bHQudXBwZXJCb3VuZC54ID0gTWF0aC5tYXgodG8ueCwgZnJvbS54KTtcbiAgICByZXN1bHQudXBwZXJCb3VuZC55ID0gTWF0aC5tYXgodG8ueSwgZnJvbS55KTtcbiAgICByZXN1bHQudXBwZXJCb3VuZC56ID0gTWF0aC5tYXgodG8ueiwgZnJvbS56KTtcbn07XG5cbnZhciBpbnRlcnNlY3RDb252ZXhPcHRpb25zID0ge1xuICAgIGZhY2VMaXN0OiBbMF1cbn07XG52YXIgd29ybGRQaWxsYXJPZmZzZXQgPSBuZXcgVmVjMygpO1xudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX2xvY2FsUmF5ID0gbmV3IFJheSgpO1xudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX2luZGV4ID0gW107XG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbWluTWF4ID0gW107XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RIZWlnaHRmaWVsZFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSl7XG4gICAgdmFyIGRhdGEgPSBzaGFwZS5kYXRhLFxuICAgICAgICB3ID0gc2hhcGUuZWxlbWVudFNpemU7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSByYXkgdG8gbG9jYWwgaGVpZ2h0ZmllbGQgY29vcmRpbmF0ZXNcbiAgICB2YXIgbG9jYWxSYXkgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbFJheTsgLy9uZXcgUmF5KHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgbG9jYWxSYXkuZnJvbS5jb3B5KHRoaXMuZnJvbSk7XG4gICAgbG9jYWxSYXkudG8uY29weSh0aGlzLnRvKTtcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGxvY2FsUmF5LmZyb20sIGxvY2FsUmF5LmZyb20pO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgbG9jYWxSYXkudG8sIGxvY2FsUmF5LnRvKTtcbiAgICBsb2NhbFJheS5fdXBkYXRlRGlyZWN0aW9uKCk7XG5cbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcbiAgICB2YXIgaW5kZXggPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9pbmRleDtcbiAgICB2YXIgaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFk7XG5cbiAgICAvLyBTZXQgdG8gbWF4XG4gICAgaU1pblggPSBpTWluWSA9IDA7XG4gICAgaU1heFggPSBpTWF4WSA9IHNoYXBlLmRhdGEubGVuZ3RoIC0gMTtcblxuICAgIHZhciBhYWJiID0gbmV3IEFBQkIoKTtcbiAgICBsb2NhbFJheS5nZXRBQUJCKGFhYmIpO1xuXG4gICAgc2hhcGUuZ2V0SW5kZXhPZlBvc2l0aW9uKGFhYmIubG93ZXJCb3VuZC54LCBhYWJiLmxvd2VyQm91bmQueSwgaW5kZXgsIHRydWUpO1xuICAgIGlNaW5YID0gTWF0aC5tYXgoaU1pblgsIGluZGV4WzBdKTtcbiAgICBpTWluWSA9IE1hdGgubWF4KGlNaW5ZLCBpbmRleFsxXSk7XG4gICAgc2hhcGUuZ2V0SW5kZXhPZlBvc2l0aW9uKGFhYmIudXBwZXJCb3VuZC54LCBhYWJiLnVwcGVyQm91bmQueSwgaW5kZXgsIHRydWUpO1xuICAgIGlNYXhYID0gTWF0aC5taW4oaU1heFgsIGluZGV4WzBdICsgMSk7XG4gICAgaU1heFkgPSBNYXRoLm1pbihpTWF4WSwgaW5kZXhbMV0gKyAxKTtcblxuICAgIGZvcih2YXIgaSA9IGlNaW5YOyBpIDwgaU1heFg7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaiA9IGlNaW5ZOyBqIDwgaU1heFk7IGorKyl7XG5cbiAgICAgICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNoYXBlLmdldEFhYmJBdEluZGV4KGksIGosIGFhYmIpO1xuICAgICAgICAgICAgaWYoIWFhYmIub3ZlcmxhcHNSYXkobG9jYWxSYXkpKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG93ZXIgdHJpYW5nbGVcbiAgICAgICAgICAgIHNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdCwgc2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdENvbnZleChzaGFwZS5waWxsYXJDb252ZXgsIHF1YXQsIHdvcmxkUGlsbGFyT2Zmc2V0LCBib2R5LCByZXBvcnRlZFNoYXBlLCBpbnRlcnNlY3RDb252ZXhPcHRpb25zKTtcblxuICAgICAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBwZXIgdHJpYW5nbGVcbiAgICAgICAgICAgIHNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpO1xuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBzaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0Q29udmV4KHNoYXBlLnBpbGxhckNvbnZleCwgcXVhdCwgd29ybGRQaWxsYXJPZmZzZXQsIGJvZHksIHJlcG9ydGVkU2hhcGUsIGludGVyc2VjdENvbnZleE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuSEVJR0hURklFTERdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RIZWlnaHRmaWVsZDtcblxudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFNwaGVyZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RTcGhlcmUgPSBmdW5jdGlvbihzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tLFxuICAgICAgICB0byA9IHRoaXMudG8sXG4gICAgICAgIHIgPSBzaGFwZS5yYWRpdXM7XG5cbiAgICB2YXIgYSA9IE1hdGgucG93KHRvLnggLSBmcm9tLngsIDIpICsgTWF0aC5wb3codG8ueSAtIGZyb20ueSwgMikgKyBNYXRoLnBvdyh0by56IC0gZnJvbS56LCAyKTtcbiAgICB2YXIgYiA9IDIgKiAoKHRvLnggLSBmcm9tLngpICogKGZyb20ueCAtIHBvc2l0aW9uLngpICsgKHRvLnkgLSBmcm9tLnkpICogKGZyb20ueSAtIHBvc2l0aW9uLnkpICsgKHRvLnogLSBmcm9tLnopICogKGZyb20ueiAtIHBvc2l0aW9uLnopKTtcbiAgICB2YXIgYyA9IE1hdGgucG93KGZyb20ueCAtIHBvc2l0aW9uLngsIDIpICsgTWF0aC5wb3coZnJvbS55IC0gcG9zaXRpb24ueSwgMikgKyBNYXRoLnBvdyhmcm9tLnogLSBwb3NpdGlvbi56LCAyKSAtIE1hdGgucG93KHIsIDIpO1xuXG4gICAgdmFyIGRlbHRhID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XG5cbiAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50O1xuICAgIHZhciBub3JtYWwgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbDtcblxuICAgIGlmKGRlbHRhIDwgMCl7XG4gICAgICAgIC8vIE5vIGludGVyc2VjdGlvblxuICAgICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYoZGVsdGEgPT09IDApe1xuICAgICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIGZyb20ubGVycCh0bywgZGVsdGEsIGludGVyc2VjdGlvblBvaW50KTtcblxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xuICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG5cbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgLTEpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGQxID0gKC0gYiAtIE1hdGguc3FydChkZWx0YSkpIC8gKDIgKiBhKTtcbiAgICAgICAgdmFyIGQyID0gKC0gYiArIE1hdGguc3FydChkZWx0YSkpIC8gKDIgKiBhKTtcblxuICAgICAgICBpZihkMSA+PSAwICYmIGQxIDw9IDEpe1xuICAgICAgICAgICAgZnJvbS5sZXJwKHRvLCBkMSwgaW50ZXJzZWN0aW9uUG9pbnQpO1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQudnN1Yihwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHJlcG9ydGVkU2hhcGUsIGJvZHksIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGQyID49IDAgJiYgZDIgPD0gMSl7XG4gICAgICAgICAgICBmcm9tLmxlcnAodG8sIGQyLCBpbnRlcnNlY3Rpb25Qb2ludCk7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xuICAgICAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgLTEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0U3BoZXJlO1xuXG5cbnZhciBpbnRlcnNlY3RDb252ZXhfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RDb252ZXhfbWluRGlzdE5vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0Q29udmV4X21pbkRpc3RJbnRlcnNlY3QgPSBuZXcgVmVjMygpO1xudmFyIGludGVyc2VjdENvbnZleF92ZWN0b3IgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0Q29udmV4XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMuZmFjZUxpc3RdXG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0Q29udmV4ID0gZnVuY3Rpb24gaW50ZXJzZWN0Q29udmV4KFxuICAgIHNoYXBlLFxuICAgIHF1YXQsXG4gICAgcG9zaXRpb24sXG4gICAgYm9keSxcbiAgICByZXBvcnRlZFNoYXBlLFxuICAgIG9wdGlvbnNcbil7XG4gICAgdmFyIG1pbkRpc3ROb3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdE5vcm1hbDtcbiAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0Q29udmV4X25vcm1hbDtcbiAgICB2YXIgdmVjdG9yID0gaW50ZXJzZWN0Q29udmV4X3ZlY3RvcjtcbiAgICB2YXIgbWluRGlzdEludGVyc2VjdCA9IGludGVyc2VjdENvbnZleF9taW5EaXN0SW50ZXJzZWN0O1xuICAgIHZhciBmYWNlTGlzdCA9IChvcHRpb25zICYmIG9wdGlvbnMuZmFjZUxpc3QpIHx8IG51bGw7XG5cbiAgICAvLyBDaGVja2luZyBmYWNlc1xuICAgIHZhciBmYWNlcyA9IHNoYXBlLmZhY2VzLFxuICAgICAgICB2ZXJ0aWNlcyA9IHNoYXBlLnZlcnRpY2VzLFxuICAgICAgICBub3JtYWxzID0gc2hhcGUuZmFjZU5vcm1hbHM7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbjtcblxuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHZhciB0byA9IHRoaXMudG87XG4gICAgdmFyIGZyb21Ub0Rpc3RhbmNlID0gZnJvbS5kaXN0YW5jZVRvKHRvKTtcblxuICAgIHZhciBtaW5EaXN0ID0gLTE7XG4gICAgdmFyIE5mYWNlcyA9IGZhY2VMaXN0ID8gZmFjZUxpc3QubGVuZ3RoIDogZmFjZXMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcblxuICAgIGZvciAodmFyIGogPSAwOyAhcmVzdWx0Ll9zaG91bGRTdG9wICYmIGogPCBOZmFjZXM7IGorKykge1xuICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdCA/IGZhY2VMaXN0W2pdIDogajtcblxuICAgICAgICB2YXIgZmFjZSA9IGZhY2VzW2ZpXTtcbiAgICAgICAgdmFyIGZhY2VOb3JtYWwgPSBub3JtYWxzW2ZpXTtcbiAgICAgICAgdmFyIHEgPSBxdWF0O1xuICAgICAgICB2YXIgeCA9IHBvc2l0aW9uO1xuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiByYXkgaW50ZXJzZWN0cyB0aGUgcGxhbmUgb2YgdGhlIGZhY2VcbiAgICAgICAgLy8gbm90ZTogdGhpcyB3b3JrcyByZWdhcmRsZXNzIG9mIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGZhY2Ugbm9ybWFsXG5cbiAgICAgICAgLy8gR2V0IHBsYW5lIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLi4uXG4gICAgICAgIHZlY3Rvci5jb3B5KHZlcnRpY2VzW2ZhY2VbMF1dKTtcbiAgICAgICAgcS52bXVsdCh2ZWN0b3IsdmVjdG9yKTtcbiAgICAgICAgdmVjdG9yLnZhZGQoeCx2ZWN0b3IpO1xuXG4gICAgICAgIC8vIC4uLmJ1dCBtYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSByYXkgZnJvbS4gV2UnbGwgZml4IHRoaXMgbGF0ZXIuXG4gICAgICAgIHZlY3Rvci52c3ViKGZyb20sdmVjdG9yKTtcblxuICAgICAgICAvLyBHZXQgcGxhbmUgbm9ybWFsXG4gICAgICAgIHEudm11bHQoZmFjZU5vcm1hbCxub3JtYWwpO1xuXG4gICAgICAgIC8vIElmIHRoaXMgZG90IHByb2R1Y3QgaXMgbmVnYXRpdmUsIHdlIGhhdmUgc29tZXRoaW5nIGludGVyZXN0aW5nXG4gICAgICAgIHZhciBkb3QgPSBkaXJlY3Rpb24uZG90KG5vcm1hbCk7XG5cbiAgICAgICAgLy8gQmFpbCBvdXQgaWYgcmF5IGFuZCBwbGFuZSBhcmUgcGFyYWxsZWxcbiAgICAgICAgaWYgKCBNYXRoLmFicyggZG90ICkgPCB0aGlzLnByZWNpc2lvbiApe1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjIGRpc3RhbmNlIHRvIHBsYW5lXG4gICAgICAgIHZhciBzY2FsYXIgPSBub3JtYWwuZG90KHZlY3RvcikgLyBkb3Q7XG5cbiAgICAgICAgLy8gaWYgbmVnYXRpdmUgZGlzdGFuY2UsIHRoZW4gcGxhbmUgaXMgYmVoaW5kIHJheVxuICAgICAgICBpZiAoc2NhbGFyIDwgMCl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIChkb3QgPCAwKSB7XG5cbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXJcbiAgICAgICAgZGlyZWN0aW9uLm11bHQoc2NhbGFyLGludGVyc2VjdFBvaW50KTtcbiAgICAgICAgaW50ZXJzZWN0UG9pbnQudmFkZChmcm9tLGludGVyc2VjdFBvaW50KTtcblxuICAgICAgICAvLyBhIGlzIHRoZSBwb2ludCB3ZSBjb21wYXJlIHBvaW50cyBiIGFuZCBjIHdpdGguXG4gICAgICAgIGEuY29weSh2ZXJ0aWNlc1tmYWNlWzBdXSk7XG4gICAgICAgIHEudm11bHQoYSxhKTtcbiAgICAgICAgeC52YWRkKGEsYSk7XG5cbiAgICAgICAgZm9yKHZhciBpID0gMTsgIXJlc3VsdC5fc2hvdWxkU3RvcCAmJiBpIDwgZmFjZS5sZW5ndGggLSAxOyBpKyspe1xuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIDMgdmVydGljZXMgdG8gd29ybGQgY29vcmRzXG4gICAgICAgICAgICBiLmNvcHkodmVydGljZXNbZmFjZVtpXV0pO1xuICAgICAgICAgICAgYy5jb3B5KHZlcnRpY2VzW2ZhY2VbaSsxXV0pO1xuICAgICAgICAgICAgcS52bXVsdChiLGIpO1xuICAgICAgICAgICAgcS52bXVsdChjLGMpO1xuICAgICAgICAgICAgeC52YWRkKGIsYik7XG4gICAgICAgICAgICB4LnZhZGQoYyxjKTtcblxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhmcm9tKTtcblxuICAgICAgICAgICAgaWYoIShwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGEsIGIsIGMpIHx8IHBvaW50SW5UcmlhbmdsZShpbnRlcnNlY3RQb2ludCwgYiwgYSwgYykpIHx8IGRpc3RhbmNlID4gZnJvbVRvRGlzdGFuY2Upe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdFBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCBmaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gfVxuICAgIH1cbn07XG5SYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST05dID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RDb252ZXg7XG5cbnZhciBpbnRlcnNlY3RUcmltZXNoX25vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbERpcmVjdGlvbiA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbEZyb20gPSBuZXcgVmVjMygpO1xudmFyIGludGVyc2VjdFRyaW1lc2hfbG9jYWxUbyA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0VHJpbWVzaF93b3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0VHJpbWVzaF93b3JsZEludGVyc2VjdFBvaW50ID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX2xvY2FsQUFCQiA9IG5ldyBBQUJCKCk7XG52YXIgaW50ZXJzZWN0VHJpbWVzaF90cmlhbmdsZXMgPSBbXTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX3RyZWVUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RUcmltZXNoXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHRvZG8gT3B0aW1pemUgYnkgdHJhbnNmb3JtaW5nIHRoZSB3b3JsZCB0byBsb2NhbCBzcGFjZSBmaXJzdC5cbiAqIEB0b2RvIFVzZSBPY3RyZWUgbG9va3VwXG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0VHJpbWVzaCA9IGZ1bmN0aW9uIGludGVyc2VjdFRyaW1lc2goXG4gICAgbWVzaCxcbiAgICBxdWF0LFxuICAgIHBvc2l0aW9uLFxuICAgIGJvZHksXG4gICAgcmVwb3J0ZWRTaGFwZSxcbiAgICBvcHRpb25zXG4pe1xuICAgIHZhciBub3JtYWwgPSBpbnRlcnNlY3RUcmltZXNoX25vcm1hbDtcbiAgICB2YXIgdHJpYW5nbGVzID0gaW50ZXJzZWN0VHJpbWVzaF90cmlhbmdsZXM7XG4gICAgdmFyIHRyZWVUcmFuc2Zvcm0gPSBpbnRlcnNlY3RUcmltZXNoX3RyZWVUcmFuc2Zvcm07XG4gICAgdmFyIG1pbkRpc3ROb3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdE5vcm1hbDtcbiAgICB2YXIgdmVjdG9yID0gaW50ZXJzZWN0Q29udmV4X3ZlY3RvcjtcbiAgICB2YXIgbWluRGlzdEludGVyc2VjdCA9IGludGVyc2VjdENvbnZleF9taW5EaXN0SW50ZXJzZWN0O1xuICAgIHZhciBsb2NhbEFBQkIgPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsQUFCQjtcbiAgICB2YXIgbG9jYWxEaXJlY3Rpb24gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uO1xuICAgIHZhciBsb2NhbEZyb20gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbTtcbiAgICB2YXIgbG9jYWxUbyA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxUbztcbiAgICB2YXIgd29ybGRJbnRlcnNlY3RQb2ludCA9IGludGVyc2VjdFRyaW1lc2hfd29ybGRJbnRlcnNlY3RQb2ludDtcbiAgICB2YXIgd29ybGROb3JtYWwgPSBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsO1xuICAgIHZhciBmYWNlTGlzdCA9IChvcHRpb25zICYmIG9wdGlvbnMuZmFjZUxpc3QpIHx8IG51bGw7XG5cbiAgICAvLyBDaGVja2luZyBmYWNlc1xuICAgIHZhciBpbmRpY2VzID0gbWVzaC5pbmRpY2VzLFxuICAgICAgICB2ZXJ0aWNlcyA9IG1lc2gudmVydGljZXMsXG4gICAgICAgIG5vcm1hbHMgPSBtZXNoLmZhY2VOb3JtYWxzO1xuXG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uO1xuXG4gICAgdmFyIG1pbkRpc3QgPSAtMTtcbiAgICB0cmVlVHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHRyZWVUcmFuc2Zvcm0ucXVhdGVybmlvbi5jb3B5KHF1YXQpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJheSB0byBsb2NhbCBzcGFjZSFcbiAgICBUcmFuc2Zvcm0udmVjdG9yVG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBkaXJlY3Rpb24sIGxvY2FsRGlyZWN0aW9uKTtcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGZyb20sIGxvY2FsRnJvbSk7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCB0bywgbG9jYWxUbyk7XG5cbiAgICBsb2NhbFRvLnggKj0gbWVzaC5zY2FsZS54O1xuICAgIGxvY2FsVG8ueSAqPSBtZXNoLnNjYWxlLnk7XG4gICAgbG9jYWxUby56ICo9IG1lc2guc2NhbGUuejtcbiAgICBsb2NhbEZyb20ueCAqPSBtZXNoLnNjYWxlLng7XG4gICAgbG9jYWxGcm9tLnkgKj0gbWVzaC5zY2FsZS55O1xuICAgIGxvY2FsRnJvbS56ICo9IG1lc2guc2NhbGUuejtcblxuICAgIGxvY2FsVG8udnN1Yihsb2NhbEZyb20sIGxvY2FsRGlyZWN0aW9uKTtcbiAgICBsb2NhbERpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgIHZhciBmcm9tVG9EaXN0YW5jZVNxdWFyZWQgPSBsb2NhbEZyb20uZGlzdGFuY2VTcXVhcmVkKGxvY2FsVG8pO1xuXG4gICAgbWVzaC50cmVlLnJheVF1ZXJ5KHRoaXMsIHRyZWVUcmFuc2Zvcm0sIHRyaWFuZ2xlcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgTiA9IHRyaWFuZ2xlcy5sZW5ndGg7ICF0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcCAmJiBpICE9PSBOOyBpKyspIHtcbiAgICAgICAgdmFyIHRyaWFuZ2xlc0luZGV4ID0gdHJpYW5nbGVzW2ldO1xuXG4gICAgICAgIG1lc2guZ2V0Tm9ybWFsKHRyaWFuZ2xlc0luZGV4LCBub3JtYWwpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiByYXkgaW50ZXJzZWN0cyB0aGUgcGxhbmUgb2YgdGhlIGZhY2VcbiAgICAgICAgLy8gbm90ZTogdGhpcyB3b3JrcyByZWdhcmRsZXNzIG9mIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGZhY2Ugbm9ybWFsXG5cbiAgICAgICAgLy8gR2V0IHBsYW5lIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLi4uXG4gICAgICAgIG1lc2guZ2V0VmVydGV4KGluZGljZXNbdHJpYW5nbGVzSW5kZXggKiAzXSwgYSk7XG5cbiAgICAgICAgLy8gLi4uYnV0IG1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIHJheSBmcm9tLiBXZSdsbCBmaXggdGhpcyBsYXRlci5cbiAgICAgICAgYS52c3ViKGxvY2FsRnJvbSx2ZWN0b3IpO1xuXG4gICAgICAgIC8vIElmIHRoaXMgZG90IHByb2R1Y3QgaXMgbmVnYXRpdmUsIHdlIGhhdmUgc29tZXRoaW5nIGludGVyZXN0aW5nXG4gICAgICAgIHZhciBkb3QgPSBsb2NhbERpcmVjdGlvbi5kb3Qobm9ybWFsKTtcblxuICAgICAgICAvLyBCYWlsIG91dCBpZiByYXkgYW5kIHBsYW5lIGFyZSBwYXJhbGxlbFxuICAgICAgICAvLyBpZiAoTWF0aC5hYnMoIGRvdCApIDwgdGhpcy5wcmVjaXNpb24pe1xuICAgICAgICAvLyAgICAgY29udGludWU7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBjYWxjIGRpc3RhbmNlIHRvIHBsYW5lXG4gICAgICAgIHZhciBzY2FsYXIgPSBub3JtYWwuZG90KHZlY3RvcikgLyBkb3Q7XG5cbiAgICAgICAgLy8gaWYgbmVnYXRpdmUgZGlzdGFuY2UsIHRoZW4gcGxhbmUgaXMgYmVoaW5kIHJheVxuICAgICAgICBpZiAoc2NhbGFyIDwgMCl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludGVyc2VjdGlvbiBwb2ludCBpcyBmcm9tICsgZGlyZWN0aW9uICogc2NhbGFyXG4gICAgICAgIGxvY2FsRGlyZWN0aW9uLnNjYWxlKHNjYWxhcixpbnRlcnNlY3RQb2ludCk7XG4gICAgICAgIGludGVyc2VjdFBvaW50LnZhZGQobG9jYWxGcm9tLGludGVyc2VjdFBvaW50KTtcblxuICAgICAgICAvLyBHZXQgdHJpYW5nbGUgdmVydGljZXNcbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXgoaW5kaWNlc1t0cmlhbmdsZXNJbmRleCAqIDMgKyAxXSwgYik7XG4gICAgICAgIG1lc2guZ2V0VmVydGV4KGluZGljZXNbdHJpYW5nbGVzSW5kZXggKiAzICsgMl0sIGMpO1xuXG4gICAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVNxdWFyZWQobG9jYWxGcm9tKTtcblxuICAgICAgICBpZighKHBvaW50SW5UcmlhbmdsZShpbnRlcnNlY3RQb2ludCwgYiwgYSwgYykgfHwgcG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBhLCBiLCBjKSkgfHwgc3F1YXJlZERpc3RhbmNlID4gZnJvbVRvRGlzdGFuY2VTcXVhcmVkKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIGludGVyc2VjdHBvaW50IGFuZCBub3JtYWwgdG8gd29ybGRcbiAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZShxdWF0LCBub3JtYWwsIHdvcmxkTm9ybWFsKTtcbiAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBpbnRlcnNlY3RQb2ludCwgd29ybGRJbnRlcnNlY3RQb2ludCk7XG4gICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsLCB3b3JsZEludGVyc2VjdFBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCB0cmlhbmdsZXNJbmRleCk7XG4gICAgfVxuICAgIHRyaWFuZ2xlcy5sZW5ndGggPSAwO1xufTtcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuVFJJTUVTSF0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdFRyaW1lc2g7XG5cblxuLyoqXG4gKiBAbWV0aG9kIHJlcG9ydEludGVyc2VjdGlvblxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1ZlYzN9IG5vcm1hbFxuICogQHBhcmFtICB7VmVjM30gaGl0UG9pbnRXb3JsZFxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBpbnRlcnNlY3Rpb25zIHNob3VsZCBjb250aW51ZVxuICovXG5SYXkucHJvdG90eXBlLnJlcG9ydEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKG5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIGhpdEZhY2VJbmRleCl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgZGlzdGFuY2UgPSBmcm9tLmRpc3RhbmNlVG8oaGl0UG9pbnRXb3JsZCk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0O1xuXG4gICAgLy8gU2tpcCBiYWNrIGZhY2VzP1xuICAgIGlmKHRoaXMuc2tpcEJhY2tmYWNlcyAmJiBub3JtYWwuZG90KHRoaXMuX2RpcmVjdGlvbikgPiAwKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc3VsdC5oaXRGYWNlSW5kZXggPSB0eXBlb2YoaGl0RmFjZUluZGV4KSAhPT0gJ3VuZGVmaW5lZCcgPyBoaXRGYWNlSW5kZXggOiAtMTtcblxuICAgIHN3aXRjaCh0aGlzLm1vZGUpe1xuICAgIGNhc2UgUmF5LkFMTDpcbiAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIGRpc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdC5oYXNIaXQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBSYXkuQ0xPU0VTVDpcblxuICAgICAgICAvLyBTdG9yZSBpZiBjbG9zZXIgdGhhbiBjdXJyZW50IGNsb3Nlc3RcbiAgICAgICAgaWYoZGlzdGFuY2UgPCByZXN1bHQuZGlzdGFuY2UgfHwgIXJlc3VsdC5oYXNIaXQpe1xuICAgICAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgUmF5LkFOWTpcblxuICAgICAgICAvLyBSZXBvcnQgYW5kIHN0b3AuXG4gICAgICAgIHRoaXMuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgcmVzdWx0Ll9zaG91bGRTdG9wID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxudmFyIHYwID0gbmV3IFZlYzMoKSxcbiAgICBpbnRlcnNlY3QgPSBuZXcgVmVjMygpO1xuZnVuY3Rpb24gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKGZyb20sIGRpcmVjdGlvbiwgcG9zaXRpb24pIHtcblxuICAgIC8vIHYwIGlzIHZlY3RvciBmcm9tIGZyb20gdG8gcG9zaXRpb25cbiAgICBwb3NpdGlvbi52c3ViKGZyb20sdjApO1xuICAgIHZhciBkb3QgPSB2MC5kb3QoZGlyZWN0aW9uKTtcblxuICAgIC8vIGludGVyc2VjdCA9IGRpcmVjdGlvbipkb3QgKyBmcm9tXG4gICAgZGlyZWN0aW9uLm11bHQoZG90LGludGVyc2VjdCk7XG4gICAgaW50ZXJzZWN0LnZhZGQoZnJvbSxpbnRlcnNlY3QpO1xuXG4gICAgdmFyIGRpc3RhbmNlID0gcG9zaXRpb24uZGlzdGFuY2VUbyhpbnRlcnNlY3QpO1xuXG4gICAgcmV0dXJuIGRpc3RhbmNlO1xufVxuXG4iLCJ2YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RSZXN1bHQ7XG5cbi8qKlxuICogU3RvcmFnZSBmb3IgUmF5IGNhc3RpbmcgZGF0YS5cbiAqIEBjbGFzcyBSYXljYXN0UmVzdWx0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmF5Y2FzdFJlc3VsdCgpe1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IHJheUZyb21Xb3JsZFxuXHQgKi9cblx0dGhpcy5yYXlGcm9tV29ybGQgPSBuZXcgVmVjMygpO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IHJheVRvV29ybGRcblx0ICovXG5cdHRoaXMucmF5VG9Xb3JsZCA9IG5ldyBWZWMzKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gaGl0Tm9ybWFsV29ybGRcblx0ICovXG5cdHRoaXMuaGl0Tm9ybWFsV29ybGQgPSBuZXcgVmVjMygpO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IGhpdFBvaW50V29ybGRcblx0ICovXG5cdHRoaXMuaGl0UG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzSGl0XG5cdCAqL1xuXHR0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgaGl0IHNoYXBlLCBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge1NoYXBlfSBzaGFwZVxuXHQgKi9cblx0dGhpcy5zaGFwZSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBoaXQgYm9keSwgb3IgbnVsbC5cblx0ICogQHByb3BlcnR5IHtCb2R5fSBib2R5XG5cdCAqL1xuXHR0aGlzLmJvZHkgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBUaGUgaW5kZXggb2YgdGhlIGhpdCB0cmlhbmdsZSwgaWYgdGhlIGhpdCBzaGFwZSB3YXMgYSB0cmltZXNoLlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gaGl0RmFjZUluZGV4XG5cdCAqIEBkZWZhdWx0IC0xXG5cdCAqL1xuXHR0aGlzLmhpdEZhY2VJbmRleCA9IC0xO1xuXG5cdC8qKlxuXHQgKiBEaXN0YW5jZSB0byB0aGUgaGl0LiBXaWxsIGJlIHNldCB0byAtMSBpZiB0aGVyZSB3YXMgbm8gaGl0LlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gZGlzdGFuY2Vcblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuZGlzdGFuY2UgPSAtMTtcblxuXHQvKipcblx0ICogSWYgdGhlIHJheSBzaG91bGQgc3RvcCB0cmF2ZXJzaW5nIHRoZSBib2RpZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gX3Nob3VsZFN0b3Bcblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdHRoaXMuX3Nob3VsZFN0b3AgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXNldCBhbGwgcmVzdWx0IGRhdGEuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnJheUZyb21Xb3JsZC5zZXRaZXJvKCk7XG5cdHRoaXMucmF5VG9Xb3JsZC5zZXRaZXJvKCk7XG5cdHRoaXMuaGl0Tm9ybWFsV29ybGQuc2V0WmVybygpO1xuXHR0aGlzLmhpdFBvaW50V29ybGQuc2V0WmVybygpO1xuXHR0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblx0dGhpcy5ib2R5ID0gbnVsbDtcblx0dGhpcy5oaXRGYWNlSW5kZXggPSAtMTtcblx0dGhpcy5kaXN0YW5jZSA9IC0xO1xuXHR0aGlzLl9zaG91bGRTdG9wID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgYWJvcnRcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuXHR0aGlzLl9zaG91bGRTdG9wID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7VmVjM30gcmF5RnJvbVdvcmxkXG4gKiBAcGFyYW0ge1ZlYzN9IHJheVRvV29ybGRcbiAqIEBwYXJhbSB7VmVjM30gaGl0Tm9ybWFsV29ybGRcbiAqIEBwYXJhbSB7VmVjM30gaGl0UG9pbnRXb3JsZFxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKFxuXHRyYXlGcm9tV29ybGQsXG5cdHJheVRvV29ybGQsXG5cdGhpdE5vcm1hbFdvcmxkLFxuXHRoaXRQb2ludFdvcmxkLFxuXHRzaGFwZSxcblx0Ym9keSxcblx0ZGlzdGFuY2Vcbil7XG5cdHRoaXMucmF5RnJvbVdvcmxkLmNvcHkocmF5RnJvbVdvcmxkKTtcblx0dGhpcy5yYXlUb1dvcmxkLmNvcHkocmF5VG9Xb3JsZCk7XG5cdHRoaXMuaGl0Tm9ybWFsV29ybGQuY29weShoaXROb3JtYWxXb3JsZCk7XG5cdHRoaXMuaGl0UG9pbnRXb3JsZC5jb3B5KGhpdFBvaW50V29ybGQpO1xuXHR0aGlzLnNoYXBlID0gc2hhcGU7XG5cdHRoaXMuYm9keSA9IGJvZHk7XG5cdHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbn07IiwidmFyIFNoYXBlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgQnJvYWRwaGFzZSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU0FQQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBTd2VlcCBhbmQgcHJ1bmUgYnJvYWRwaGFzZSBhbG9uZyBvbmUgYXhpcy5cbiAqXG4gKiBAY2xhc3MgU0FQQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dvcmxkfSBbd29ybGRdXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXG4gKi9cbmZ1bmN0aW9uIFNBUEJyb2FkcGhhc2Uod29ybGQpe1xuICAgIEJyb2FkcGhhc2UuYXBwbHkodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGJvZGllcyBjdXJyZW50bHkgaW4gdGhlIGJyb2FkcGhhc2UuXG4gICAgICogQHByb3BlcnR5IGF4aXNMaXN0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXhpc0xpc3QgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZCB0byBzZWFyY2ggaW4uXG4gICAgICogQHByb3BlcnR5IHdvcmxkXG4gICAgICogQHR5cGUge1dvcmxkfVxuICAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXhpcyB0byBzb3J0IHRoZSBib2RpZXMgYWxvbmcuIFNldCB0byAwIGZvciB4IGF4aXMsIGFuZCAxIGZvciB5IGF4aXMuIEZvciBiZXN0IHBlcmZvcm1hbmNlLCBjaG9vc2UgYW4gYXhpcyB0aGF0IHRoZSBib2RpZXMgYXJlIHNwcmVhZCBvdXQgbW9yZSBvbi5cbiAgICAgKiBAcHJvcGVydHkgYXhpc0luZGV4XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmF4aXNJbmRleCA9IDA7XG5cbiAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xuXG4gICAgdGhpcy5fYWRkQm9keUhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgYXhpc0xpc3QucHVzaChlLmJvZHkpO1xuICAgIH07XG5cbiAgICB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgaWR4ID0gYXhpc0xpc3QuaW5kZXhPZihlLmJvZHkpO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGF4aXNMaXN0LnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYod29ybGQpe1xuICAgICAgICB0aGlzLnNldFdvcmxkKHdvcmxkKTtcbiAgICB9XG59XG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZSA9IG5ldyBCcm9hZHBoYXNlKCk7XG5cbi8qKlxuICogQ2hhbmdlIHRoZSB3b3JsZFxuICogQG1ldGhvZCBzZXRXb3JsZFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xuICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxuICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDtcblxuICAgIC8vIEFkZCBhbGwgYm9kaWVzIGZyb20gdGhlIG5ldyB3b3JsZFxuICAgIGZvcih2YXIgaT0wOyBpPHdvcmxkLmJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuYXhpc0xpc3QucHVzaCh3b3JsZC5ib2RpZXNbaV0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBvbGQgaGFuZGxlcnMsIGlmIGFueVxuICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhZGRCb2R5XCIsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTtcbiAgICB3b3JsZC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVtb3ZlQm9keVwiLCB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7XG5cbiAgICAvLyBBZGQgaGFuZGxlcnMgdG8gdXBkYXRlIHRoZSBsaXN0IG9mIGJvZGllcy5cbiAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKFwiYWRkQm9keVwiLCB0aGlzLl9hZGRCb2R5SGFuZGxlcik7XG4gICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcihcInJlbW92ZUJvZHlcIiwgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpO1xuXG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGluc2VydGlvblNvcnRYXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFggPSBmdW5jdGlvbihhKSB7XG4gICAgZm9yKHZhciBpPTEsbD1hLmxlbmd0aDtpPGw7aSsrKSB7XG4gICAgICAgIHZhciB2ID0gYVtpXTtcbiAgICAgICAgZm9yKHZhciBqPWkgLSAxO2o+PTA7ai0tKSB7XG4gICAgICAgICAgICBpZihhW2pdLmFhYmIubG93ZXJCb3VuZC54IDw9IHYuYWFiYi5sb3dlckJvdW5kLngpe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVtqKzFdID0gYVtqXTtcbiAgICAgICAgfVxuICAgICAgICBhW2orMV0gPSB2O1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBpbnNlcnRpb25Tb3J0WVxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRZID0gZnVuY3Rpb24oYSkge1xuICAgIGZvcih2YXIgaT0xLGw9YS5sZW5ndGg7aTxsO2krKykge1xuICAgICAgICB2YXIgdiA9IGFbaV07XG4gICAgICAgIGZvcih2YXIgaj1pIC0gMTtqPj0wO2otLSkge1xuICAgICAgICAgICAgaWYoYVtqXS5hYWJiLmxvd2VyQm91bmQueSA8PSB2LmFhYmIubG93ZXJCb3VuZC55KXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFbaisxXSA9IGFbal07XG4gICAgICAgIH1cbiAgICAgICAgYVtqKzFdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgaW5zZXJ0aW9uU29ydFpcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBmb3IodmFyIGk9MSxsPWEubGVuZ3RoO2k8bDtpKyspIHtcbiAgICAgICAgdmFyIHYgPSBhW2ldO1xuICAgICAgICBmb3IodmFyIGo9aSAtIDE7aj49MDtqLS0pIHtcbiAgICAgICAgICAgIGlmKGFbal0uYWFiYi5sb3dlckJvdW5kLnogPD0gdi5hYWJiLmxvd2VyQm91bmQueil7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhW2orMV0gPSBhW2pdO1xuICAgICAgICB9XG4gICAgICAgIGFbaisxXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBDb2xsZWN0IGFsbCBjb2xsaXNpb24gcGFpcnNcbiAqIEBtZXRob2QgY29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtBcnJheX0gcDJcbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwMSxwMil7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsXG4gICAgICAgIE4gPSBib2RpZXMubGVuZ3RoLFxuICAgICAgICBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleCxcbiAgICAgICAgaSwgajtcblxuICAgIGlmKHRoaXMuZGlydHkpe1xuICAgICAgICB0aGlzLnNvcnRMaXN0KCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBMb29rIHRocm91Z2ggdGhlIGxpc3RcbiAgICBmb3IoaT0wOyBpICE9PSBOOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgZm9yKGo9aSsxOyBqIDwgTjsgaisrKXtcbiAgICAgICAgICAgIHZhciBiaiA9IGJvZGllc1tqXTtcblxuICAgICAgICAgICAgaWYoIXRoaXMubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24oYmksYmopKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIVNBUEJyb2FkcGhhc2UuY2hlY2tCb3VuZHMoYmksYmosYXhpc0luZGV4KSl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uVGVzdChiaSxiaixwMSxwMik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zb3J0TGlzdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGF4aXNMaXN0ID0gdGhpcy5heGlzTGlzdDtcbiAgICB2YXIgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7XG4gICAgdmFyIE4gPSBheGlzTGlzdC5sZW5ndGg7XG5cbiAgICAvLyBVcGRhdGUgQUFCQnNcbiAgICBmb3IodmFyIGkgPSAwOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYXhpc0xpc3RbaV07XG4gICAgICAgIGlmKGJpLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiaS5jb21wdXRlQUFCQigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCB0aGUgbGlzdFxuICAgIGlmKGF4aXNJbmRleCA9PT0gMCl7XG4gICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFgoYXhpc0xpc3QpO1xuICAgIH0gZWxzZSBpZihheGlzSW5kZXggPT09IDEpe1xuICAgICAgICBTQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRZKGF4aXNMaXN0KTtcbiAgICB9IGVsc2UgaWYoYXhpc0luZGV4ID09PSAyKXtcbiAgICAgICAgU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WihheGlzTGlzdCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRzIG9mIHR3byBib2RpZXMgb3ZlcmxhcCwgYWxvbmcgdGhlIGdpdmVuIFNBUCBheGlzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjaGVja0JvdW5kc1xuICogQHBhcmFtICB7Qm9keX0gYmlcbiAqIEBwYXJhbSAge0JvZHl9IGJqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGF4aXNJbmRleFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuU0FQQnJvYWRwaGFzZS5jaGVja0JvdW5kcyA9IGZ1bmN0aW9uKGJpLCBiaiwgYXhpc0luZGV4KXtcbiAgICB2YXIgYmlQb3M7XG4gICAgdmFyIGJqUG9zO1xuXG4gICAgaWYoYXhpc0luZGV4ID09PSAwKXtcbiAgICAgICAgYmlQb3MgPSBiaS5wb3NpdGlvbi54O1xuICAgICAgICBialBvcyA9IGJqLnBvc2l0aW9uLng7XG4gICAgfSBlbHNlIGlmKGF4aXNJbmRleCA9PT0gMSl7XG4gICAgICAgIGJpUG9zID0gYmkucG9zaXRpb24ueTtcbiAgICAgICAgYmpQb3MgPSBiai5wb3NpdGlvbi55O1xuICAgIH0gZWxzZSBpZihheGlzSW5kZXggPT09IDIpe1xuICAgICAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLno7XG4gICAgICAgIGJqUG9zID0gYmoucG9zaXRpb24uejtcbiAgICB9XG5cbiAgICB2YXIgcmkgPSBiaS5ib3VuZGluZ1JhZGl1cyxcbiAgICAgICAgcmogPSBiai5ib3VuZGluZ1JhZGl1cyxcbiAgICAgICAgYm91bmRBMSA9IGJpUG9zIC0gcmksXG4gICAgICAgIGJvdW5kQTIgPSBiaVBvcyArIHJpLFxuICAgICAgICBib3VuZEIxID0gYmpQb3MgLSByaixcbiAgICAgICAgYm91bmRCMiA9IGJqUG9zICsgcmo7XG5cbiAgICByZXR1cm4gYm91bmRCMSA8IGJvdW5kQTI7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSB2YXJpYW5jZSBvZiB0aGUgYm9keSBwb3NpdGlvbnMgYW5kIGVzdGltYXRlcyB0aGUgYmVzdFxuICogYXhpcyB0byB1c2UuIFdpbGwgYXV0b21hdGljYWxseSBzZXQgcHJvcGVydHkgLmF4aXNJbmRleC5cbiAqIEBtZXRob2QgYXV0b0RldGVjdEF4aXNcbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuYXV0b0RldGVjdEF4aXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzdW1YPTAsXG4gICAgICAgIHN1bVgyPTAsXG4gICAgICAgIHN1bVk9MCxcbiAgICAgICAgc3VtWTI9MCxcbiAgICAgICAgc3VtWj0wLFxuICAgICAgICBzdW1aMj0wLFxuICAgICAgICBib2RpZXMgPSB0aGlzLmF4aXNMaXN0LFxuICAgICAgICBOID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgaW52Tj0xL047XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIHZhciBjZW50ZXJYID0gYi5wb3NpdGlvbi54O1xuICAgICAgICBzdW1YICs9IGNlbnRlclg7XG4gICAgICAgIHN1bVgyICs9IGNlbnRlclgqY2VudGVyWDtcblxuICAgICAgICB2YXIgY2VudGVyWSA9IGIucG9zaXRpb24ueTtcbiAgICAgICAgc3VtWSArPSBjZW50ZXJZO1xuICAgICAgICBzdW1ZMiArPSBjZW50ZXJZKmNlbnRlclk7XG5cbiAgICAgICAgdmFyIGNlbnRlclogPSBiLnBvc2l0aW9uLno7XG4gICAgICAgIHN1bVogKz0gY2VudGVyWjtcbiAgICAgICAgc3VtWjIgKz0gY2VudGVyWipjZW50ZXJaO1xuICAgIH1cblxuICAgIHZhciB2YXJpYW5jZVggPSBzdW1YMiAtIHN1bVgqc3VtWCppbnZOLFxuICAgICAgICB2YXJpYW5jZVkgPSBzdW1ZMiAtIHN1bVkqc3VtWSppbnZOLFxuICAgICAgICB2YXJpYW5jZVogPSBzdW1aMiAtIHN1bVoqc3VtWippbnZOO1xuXG4gICAgaWYodmFyaWFuY2VYID4gdmFyaWFuY2VZKXtcbiAgICAgICAgaWYodmFyaWFuY2VYID4gdmFyaWFuY2VaKXtcbiAgICAgICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMDtcbiAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgdGhpcy5heGlzSW5kZXggPSAyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKHZhcmlhbmNlWSA+IHZhcmlhbmNlWil7XG4gICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMTtcbiAgICB9IGVsc2V7XG4gICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGJvZGllcyBpbi5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbih3b3JsZCwgYWFiYiwgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgICBpZih0aGlzLmRpcnR5KXtcbiAgICAgICAgdGhpcy5zb3J0TGlzdCgpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4LCBheGlzID0gJ3gnO1xuICAgIGlmKGF4aXNJbmRleCA9PT0gMSl7IGF4aXMgPSAneSc7IH1cbiAgICBpZihheGlzSW5kZXggPT09IDIpeyBheGlzID0gJ3onOyB9XG5cbiAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xuICAgIHZhciBsb3dlciA9IGFhYmIubG93ZXJCb3VuZFtheGlzXTtcbiAgICB2YXIgdXBwZXIgPSBhYWJiLnVwcGVyQm91bmRbYXhpc107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGF4aXNMaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBheGlzTGlzdFtpXTtcblxuICAgICAgICBpZihiLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiLmNvbXB1dGVBQUJCKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihiLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IENvbmVUd2lzdENvbnN0cmFpbnQ7XG5cbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG52YXIgUG9pbnRUb1BvaW50Q29uc3RyYWludCA9IHJlcXVpcmUoJy4vUG9pbnRUb1BvaW50Q29uc3RyYWludCcpO1xudmFyIENvbmVFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Db25lRXF1YXRpb24nKTtcbnZhciBSb3RhdGlvbmFsRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyk7XG52YXIgQ29udGFjdEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcblxuLyoqXG4gKiBAY2xhc3MgQ29uZVR3aXN0Q29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBpdm90QV1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucGl2b3RCXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQV1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0JdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxuICogQGV4dGVuZHMgUG9pbnRUb1BvaW50Q29uc3RyYWludFxuICovXG5mdW5jdGlvbiBDb25lVHdpc3RDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG5cbiAgICAvLyBTZXQgcGl2b3QgcG9pbnQgaW4gYmV0d2VlblxuICAgIHZhciBwaXZvdEEgPSBvcHRpb25zLnBpdm90QSA/IG9wdGlvbnMucGl2b3RBLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuICAgIHZhciBwaXZvdEIgPSBvcHRpb25zLnBpdm90QiA/IG9wdGlvbnMucGl2b3RCLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoKTtcbiAgICB0aGlzLmF4aXNCID0gb3B0aW9ucy5heGlzQiA/IG9wdGlvbnMuYXhpc0IuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpO1xuXG4gICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gISFvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ7XG5cbiAgICB0aGlzLmFuZ2xlID0gdHlwZW9mKG9wdGlvbnMuYW5nbGUpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5nbGUgOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtDb25lRXF1YXRpb259IGNvbmVFcXVhdGlvblxuICAgICAqL1xuICAgIHZhciBjID0gdGhpcy5jb25lRXF1YXRpb24gPSBuZXcgQ29uZUVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHR3aXN0RXF1YXRpb25cbiAgICAgKi9cbiAgICB2YXIgdCA9IHRoaXMudHdpc3RFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG4gICAgdGhpcy50d2lzdEFuZ2xlID0gdHlwZW9mKG9wdGlvbnMudHdpc3RBbmdsZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy50d2lzdEFuZ2xlIDogMDtcblxuICAgIC8vIE1ha2UgdGhlIGNvbmUgZXF1YXRpb24gcHVzaCB0aGUgYm9kaWVzIHRvd2FyZCB0aGUgY29uZSBheGlzLCBub3Qgb3V0d2FyZFxuICAgIGMubWF4Rm9yY2UgPSAwO1xuICAgIGMubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG5cbiAgICAvLyBNYWtlIHRoZSB0d2lzdCBlcXVhdGlvbiBhZGQgdG9ycXVlIHRvd2FyZCB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgIHQubWF4Rm9yY2UgPSAwO1xuICAgIHQubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG5cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGMsIHQpO1xufVxuQ29uZVR3aXN0Q29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludCgpO1xuQ29uZVR3aXN0Q29uc3RyYWludC5jb25zdHJ1Y3RvciA9IENvbmVUd2lzdENvbnN0cmFpbnQ7XG5cbnZhciBDb25lVHdpc3RDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciBDb25lVHdpc3RDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyID0gbmV3IFZlYzMoKTtcblxuQ29uZVR3aXN0Q29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGNvbmUgPSB0aGlzLmNvbmVFcXVhdGlvbixcbiAgICAgICAgdHdpc3QgPSB0aGlzLnR3aXN0RXF1YXRpb247XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYXhlcyB0byB0aGUgY29uZSBjb25zdHJhaW50XG4gICAgYm9keUEudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuYXhpc0EsIGNvbmUuYXhpc0EpO1xuICAgIGJvZHlCLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmF4aXNCLCBjb25lLmF4aXNCKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgd29ybGQgYXhlcyBpbiB0aGUgdHdpc3QgY29uc3RyYWludFxuICAgIHRoaXMuYXhpc0EudGFuZ2VudHModHdpc3QuYXhpc0EsIHR3aXN0LmF4aXNBKTtcbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodHdpc3QuYXhpc0EsIHR3aXN0LmF4aXNBKTtcblxuICAgIHRoaXMuYXhpc0IudGFuZ2VudHModHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTtcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTtcblxuICAgIGNvbmUuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgIHR3aXN0Lm1heEFuZ2xlID0gdGhpcy50d2lzdEFuZ2xlO1xufTtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50O1xuXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpO1xuXG4vKipcbiAqIENvbnN0cmFpbnQgYmFzZSBjbGFzc1xuICogQGNsYXNzIENvbnN0cmFpbnRcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkPXRydWVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLndha2VVcEJvZGllcz10cnVlXVxuICovXG5mdW5jdGlvbiBDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICBjb2xsaWRlQ29ubmVjdGVkIDogdHJ1ZSxcbiAgICAgICAgd2FrZVVwQm9kaWVzIDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEVxdWF0aW9ucyB0byBiZSBzb2x2ZWQgaW4gdGhpcyBjb25zdHJhaW50XG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5QVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keUJcbiAgICAgKi9cbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gaWRcbiAgICAgKi9cbiAgICB0aGlzLmlkID0gQ29uc3RyYWludC5pZENvdW50ZXIrKztcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSBib2RpZXMgdG8gY29sbGlkZSB3aGVuIHRoZXkgYXJlIGNvbm5lY3RlZC5cbiAgICAgKiBAcHJvcGVydHkgY29sbGlkZUNvbm5lY3RlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9IG9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZDtcblxuICAgIGlmKG9wdGlvbnMud2FrZVVwQm9kaWVzKXtcbiAgICAgICAgaWYoYm9keUEpe1xuICAgICAgICAgICAgYm9keUEud2FrZVVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoYm9keUIpe1xuICAgICAgICAgICAgYm9keUIud2FrZVVwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogVXBkYXRlIGFsbCB0aGUgZXF1YXRpb25zIHdpdGggZGF0YS5cbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIHVwZGF0ZSgpIG5vdCBpbXBsbWVtZW50ZWQgaW4gdGhpcyBDb25zdHJhaW50IHN1YmNsYXNzIVwiKTtcbn07XG5cbi8qKlxuICogRW5hYmxlcyBhbGwgZXF1YXRpb25zIGluIHRoZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBlbmFibGVcbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgZm9yKHZhciBpPTA7IGk8ZXFzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZXFzW2ldLmVuYWJsZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGlzYWJsZXMgYWxsIGVxdWF0aW9ucyBpbiB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2QgZGlzYWJsZVxuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgZm9yKHZhciBpPTA7IGk8ZXFzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZXFzW2ldLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5Db25zdHJhaW50LmlkQ291bnRlciA9IDA7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlQ29uc3RyYWludDtcblxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBDb250YWN0RXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XG5cbi8qKlxuICogQ29uc3RyYWlucyB0d28gYm9kaWVzIHRvIGJlIGF0IGEgY29uc3RhbnQgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVycyBjZW50ZXIgb2YgbWFzcy5cbiAqIEBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IFtkaXN0YW5jZV0gVGhlIGRpc3RhbmNlIHRvIGtlZXAuIElmIHVuZGVmaW5lZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiBib2R5QSBhbmQgYm9keUJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4Rm9yY2U9MWU2XVxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICovXG5mdW5jdGlvbiBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsYm9keUIsZGlzdGFuY2UsbWF4Rm9yY2Upe1xuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCKTtcblxuICAgIGlmKHR5cGVvZihkaXN0YW5jZSk9PT1cInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGRpc3RhbmNlID0gYm9keUEucG9zaXRpb24uZGlzdGFuY2VUbyhib2R5Qi5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mKG1heEZvcmNlKT09PVwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbWF4Rm9yY2UgPSAxZTY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRpc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0RXF1YXRpb259IGRpc3RhbmNlRXF1YXRpb25cbiAgICAgKi9cbiAgICB2YXIgZXEgPSB0aGlzLmRpc3RhbmNlRXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qik7XG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChlcSk7XG5cbiAgICAvLyBNYWtlIGl0IGJpZGlyZWN0aW9uYWxcbiAgICBlcS5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcbiAgICBlcS5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcbn1cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuXG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QTtcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xuICAgIHZhciBlcSA9IHRoaXMuZGlzdGFuY2VFcXVhdGlvbjtcbiAgICB2YXIgaGFsZkRpc3QgPSB0aGlzLmRpc3RhbmNlICogMC41O1xuICAgIHZhciBub3JtYWwgPSBlcS5uaTtcblxuICAgIGJvZHlCLnBvc2l0aW9uLnZzdWIoYm9keUEucG9zaXRpb24sIG5vcm1hbCk7XG4gICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgIG5vcm1hbC5tdWx0KGhhbGZEaXN0LCBlcS5yaSk7XG4gICAgbm9ybWFsLm11bHQoLWhhbGZEaXN0LCBlcS5yaik7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gSGluZ2VDb25zdHJhaW50O1xuXG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4vQ29uc3RyYWludCcpO1xudmFyIFBvaW50VG9Qb2ludENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL1BvaW50VG9Qb2ludENvbnN0cmFpbnQnKTtcbnZhciBSb3RhdGlvbmFsRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyk7XG52YXIgUm90YXRpb25hbE1vdG9yRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb24nKTtcbnZhciBDb250YWN0RXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xuXG4vKipcbiAqIEhpbmdlIGNvbnN0cmFpbnQuIFRoaW5rIG9mIGl0IGFzIGEgZG9vciBoaW5nZS4gSXQgdHJpZXMgdG8ga2VlcCB0aGUgZG9vciBpbiB0aGUgY29ycmVjdCBwbGFjZSBhbmQgd2l0aCB0aGUgY29ycmVjdCBvcmllbnRhdGlvbi5cbiAqIEBjbGFzcyBIaW5nZUNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5waXZvdEFdIEEgcG9pbnQgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLiBUaGlzIGRlZmluZXMgdGhlIG9mZnNldCBvZiBheGlzQS5cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0FdIEFuIGF4aXMgdGhhdCBib2R5QSBjYW4gcm90YXRlIGFyb3VuZCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLlxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5waXZvdEJdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNCXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlPTFlNl1cbiAqIEBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnRcbiAqL1xuZnVuY3Rpb24gSGluZ2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG4gICAgdmFyIHBpdm90QSA9IG9wdGlvbnMucGl2b3RBID8gb3B0aW9ucy5waXZvdEEuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG4gICAgdmFyIHBpdm90QiA9IG9wdGlvbnMucGl2b3RCID8gb3B0aW9ucy5waXZvdEIuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpO1xuXG4gICAgLyoqXG4gICAgICogUm90YXRpb24gYXhpcywgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0FcbiAgICAgKi9cbiAgICB2YXIgYXhpc0EgPSB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsMCwwKTtcbiAgICBheGlzQS5ub3JtYWxpemUoKTtcblxuICAgIC8qKlxuICAgICAqIFJvdGF0aW9uIGF4aXMsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5Qi5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGF4aXNCXG4gICAgICovXG4gICAgdmFyIGF4aXNCID0gdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygxLDAsMCk7XG4gICAgYXhpc0Iubm9ybWFsaXplKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMVxuICAgICAqL1xuICAgIHZhciByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMlxuICAgICAqL1xuICAgIHZhciByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMiA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxNb3RvckVxdWF0aW9ufSBtb3RvckVxdWF0aW9uXG4gICAgICovXG4gICAgdmFyIG1vdG9yID0gdGhpcy5tb3RvckVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uKGJvZHlBLGJvZHlCLG1heEZvcmNlKTtcbiAgICBtb3Rvci5lbmFibGVkID0gZmFsc2U7IC8vIE5vdCBlbmFibGVkIGJ5IGRlZmF1bHRcblxuICAgIC8vIEVxdWF0aW9ucyB0byBiZSBmZWQgdG8gdGhlIHNvbHZlclxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2goXG4gICAgICAgIHIxLCAvLyByb3RhdGlvbmFsMVxuICAgICAgICByMiwgLy8gcm90YXRpb25hbDJcbiAgICAgICAgbW90b3JcbiAgICApO1xufVxuSGluZ2VDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KCk7XG5IaW5nZUNvbnN0cmFpbnQuY29uc3RydWN0b3IgPSBIaW5nZUNvbnN0cmFpbnQ7XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVNb3RvclxuICovXG5IaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLmVuYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXG4gKi9cbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldE1vdG9yU3BlZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZFxuICovXG5IaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbihzcGVlZCl7XG4gICAgdGhpcy5tb3RvckVxdWF0aW9uLnRhcmdldFZlbG9jaXR5ID0gc3BlZWQ7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0TW90b3JNYXhGb3JjZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heEZvcmNlXG4gKi9cbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TW90b3JNYXhGb3JjZSA9IGZ1bmN0aW9uKG1heEZvcmNlKXtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWF4Rm9yY2UgPSBtYXhGb3JjZTtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG59O1xuXG52YXIgSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzIgPSBuZXcgVmVjMygpO1xuXG5IaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbixcbiAgICAgICAgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEsXG4gICAgICAgIHIyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yLFxuICAgICAgICB3b3JsZEF4aXNBID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxLFxuICAgICAgICB3b3JsZEF4aXNCID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyO1xuXG4gICAgdmFyIGF4aXNBID0gdGhpcy5heGlzQTtcbiAgICB2YXIgYXhpc0IgPSB0aGlzLmF4aXNCO1xuXG4gICAgUG9pbnRUb1BvaW50Q29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICAvLyBHZXQgd29ybGQgYXhlc1xuICAgIGJvZHlBLnF1YXRlcm5pb24udm11bHQoYXhpc0EsIHdvcmxkQXhpc0EpO1xuICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQoYXhpc0IsIHdvcmxkQXhpc0IpO1xuXG4gICAgd29ybGRBeGlzQS50YW5nZW50cyhyMS5heGlzQSwgcjIuYXhpc0EpO1xuICAgIHIxLmF4aXNCLmNvcHkod29ybGRBeGlzQik7XG4gICAgcjIuYXhpc0IuY29weSh3b3JsZEF4aXNCKTtcblxuICAgIGlmKHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkKXtcbiAgICAgICAgYm9keUEucXVhdGVybmlvbi52bXVsdCh0aGlzLmF4aXNBLCBtb3Rvci5heGlzQSk7XG4gICAgICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQiwgbW90b3IuYXhpc0IpO1xuICAgIH1cbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gTG9ja0NvbnN0cmFpbnQ7XG5cbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG52YXIgUG9pbnRUb1BvaW50Q29uc3RyYWludCA9IHJlcXVpcmUoJy4vUG9pbnRUb1BvaW50Q29uc3RyYWludCcpO1xudmFyIFJvdGF0aW9uYWxFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsRXF1YXRpb24nKTtcbnZhciBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbicpO1xudmFyIENvbnRhY3RFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG5cbi8qKlxuICogTG9jayBjb25zdHJhaW50LiBXaWxsIHJlbW92ZSBhbGwgZGVncmVlcyBvZiBmcmVlZG9tIGJldHdlZW4gdGhlIGJvZGllcy5cbiAqIEBjbGFzcyBMb2NrQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxuICogQGV4dGVuZHMgUG9pbnRUb1BvaW50Q29uc3RyYWludFxuICovXG5mdW5jdGlvbiBMb2NrQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBtYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2O1xuXG4gICAgLy8gU2V0IHBpdm90IHBvaW50IGluIGJldHdlZW5cbiAgICB2YXIgcGl2b3RBID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgcGl2b3RCID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgaGFsZldheSA9IG5ldyBWZWMzKCk7XG4gICAgYm9keUEucG9zaXRpb24udmFkZChib2R5Qi5wb3NpdGlvbiwgaGFsZldheSk7XG4gICAgaGFsZldheS5zY2FsZSgwLjUsIGhhbGZXYXkpO1xuICAgIGJvZHlCLnBvaW50VG9Mb2NhbEZyYW1lKGhhbGZXYXksIHBpdm90Qik7XG4gICAgYm9keUEucG9pbnRUb0xvY2FsRnJhbWUoaGFsZldheSwgcGl2b3RBKTtcblxuICAgIC8vIFRoZSBwb2ludC10by1wb2ludCBjb25zdHJhaW50IHdpbGwga2VlcCBhIHBvaW50IHNoYXJlZCBiZXR3ZWVuIHRoZSBib2RpZXNcbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpO1xuXG4gICAgLy8gU3RvcmUgaW5pdGlhbCByb3RhdGlvbiBvZiB0aGUgYm9kaWVzIGFzIHVuaXQgdmVjdG9ycyBpbiB0aGUgbG9jYWwgYm9keSBzcGFjZXNcbiAgICB0aGlzLnhBID0gYm9keUEudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9YKTtcbiAgICB0aGlzLnhCID0gYm9keUIudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9YKTtcbiAgICB0aGlzLnlBID0gYm9keUEudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9ZKTtcbiAgICB0aGlzLnlCID0gYm9keUIudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9ZKTtcbiAgICB0aGlzLnpBID0gYm9keUEudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9aKTtcbiAgICB0aGlzLnpCID0gYm9keUIudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9aKTtcblxuICAgIC8vIC4uLmFuZCB0aGUgZm9sbG93aW5nIHJvdGF0aW9uYWwgZXF1YXRpb25zIHdpbGwga2VlcCBhbGwgcm90YXRpb25hbCBET0YncyBpbiBwbGFjZVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjFcbiAgICAgKi9cbiAgICB2YXIgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjJcbiAgICAgKi9cbiAgICB2YXIgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjNcbiAgICAgKi9cbiAgICB2YXIgcjMgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjMgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xuXG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChyMSwgcjIsIHIzKTtcbn1cbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KCk7XG5Mb2NrQ29uc3RyYWludC5jb25zdHJ1Y3RvciA9IExvY2tDb25zdHJhaW50O1xuXG52YXIgTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpO1xudmFyIExvY2tDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyID0gbmV3IFZlYzMoKTtcblxuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbixcbiAgICAgICAgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEsXG4gICAgICAgIHIyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yLFxuICAgICAgICByMyA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMyxcbiAgICAgICAgd29ybGRBeGlzQSA9IExvY2tDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxLFxuICAgICAgICB3b3JsZEF4aXNCID0gTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzI7XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgIC8vIFRoZXNlIHZlY3RvciBwYWlycyBtdXN0IGJlIG9ydGhvZ29uYWxcbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy54QSwgcjEuYXhpc0EpO1xuICAgIGJvZHlCLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnlCLCByMS5heGlzQik7XG5cbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy55QSwgcjIuYXhpc0EpO1xuICAgIGJvZHlCLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnpCLCByMi5heGlzQik7XG5cbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy56QSwgcjMuYXhpc0EpO1xuICAgIGJvZHlCLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnhCLCByMy5heGlzQik7XG59O1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFBvaW50VG9Qb2ludENvbnN0cmFpbnQ7XG5cbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG52YXIgQ29udGFjdEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcblxuLyoqXG4gKiBDb25uZWN0cyB0d28gYm9kaWVzIGF0IGdpdmVuIG9mZnNldCBwb2ludHMuXG4gKiBAY2xhc3MgUG9pbnRUb1BvaW50Q29uc3RyYWludFxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge1ZlYzN9IHBpdm90QSBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzIG9mIGJvZHlBIHdoaWNoIGJvZHlBIGlzIGNvbnN0cmFpbmVkIHRvLlxuICogQHBhcmFtIHtCb2R5fSBib2R5QiBCb2R5IHRoYXQgd2lsbCBiZSBjb25zdHJhaW5lZCBpbiBhIHNpbWlsYXIgd2F5IHRvIHRoZSBzYW1lIHBvaW50IGFzIGJvZHlBLiBXZSB3aWxsIHRoZXJlZm9yZSBnZXQgYSBsaW5rIGJldHdlZW4gYm9keUEgYW5kIGJvZHlCLiBJZiBub3Qgc3BlY2lmaWVkLCBib2R5QSB3aWxsIGJlIGNvbnN0cmFpbmVkIHRvIGEgc3RhdGljIHBvaW50LlxuICogQHBhcmFtIHtWZWMzfSBwaXZvdEIgU2VlIHBpdm90QS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZSBUaGUgbWF4aW11bSBmb3JjZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGNvbnN0cmFpbiB0aGUgYm9kaWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGJvZHlBID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xuICogICAgIHZhciBib2R5QiA9IG5ldyBCb2R5KHsgbWFzczogMSB9KTtcbiAqICAgICBib2R5QS5wb3NpdGlvbi5zZXQoLTEsIDAsIDApO1xuICogICAgIGJvZHlCLnBvc2l0aW9uLnNldCgxLCAwLCAwKTtcbiAqICAgICBib2R5QS5hZGRTaGFwZShzaGFwZUEpO1xuICogICAgIGJvZHlCLmFkZFNoYXBlKHNoYXBlQik7XG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5QSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5Qik7XG4gKiAgICAgdmFyIGxvY2FsUGl2b3RBID0gbmV3IFZlYzMoMSwgMCwgMCk7XG4gKiAgICAgdmFyIGxvY2FsUGl2b3RCID0gbmV3IFZlYzMoLTEsIDAsIDApO1xuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFBvaW50VG9Qb2ludENvbnN0cmFpbnQoYm9keUEsIGxvY2FsUGl2b3RBLCBib2R5QiwgbG9jYWxQaXZvdEIpO1xuICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG4gKi9cbmZ1bmN0aW9uIFBvaW50VG9Qb2ludENvbnN0cmFpbnQoYm9keUEscGl2b3RBLGJvZHlCLHBpdm90QixtYXhGb3JjZSl7XG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIpO1xuXG4gICAgbWF4Rm9yY2UgPSB0eXBlb2YobWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG1heEZvcmNlIDogMWU2O1xuXG4gICAgLyoqXG4gICAgICogUGl2b3QsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QS5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHBpdm90QVxuICAgICAqL1xuICAgIHRoaXMucGl2b3RBID0gcGl2b3RBID8gcGl2b3RBLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogUGl2b3QsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5Qi5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHBpdm90QlxuICAgICAqL1xuICAgIHRoaXMucGl2b3RCID0gcGl2b3RCID8gcGl2b3RCLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0RXF1YXRpb259IGVxdWF0aW9uWFxuICAgICAqL1xuICAgIHZhciB4ID0gdGhpcy5lcXVhdGlvblggPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdEVxdWF0aW9ufSBlcXVhdGlvbllcbiAgICAgKi9cbiAgICB2YXIgeSA9IHRoaXMuZXF1YXRpb25ZID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0NvbnRhY3RFcXVhdGlvbn0gZXF1YXRpb25aXG4gICAgICovXG4gICAgdmFyIHogPSB0aGlzLmVxdWF0aW9uWiA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIpO1xuXG4gICAgLy8gRXF1YXRpb25zIHRvIGJlIGZlZCB0byB0aGUgc29sdmVyXG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaCh4LCB5LCB6KTtcblxuICAgIC8vIE1ha2UgdGhlIGVxdWF0aW9ucyBiaWRpcmVjdGlvbmFsXG4gICAgeC5taW5Gb3JjZSA9IHkubWluRm9yY2UgPSB6Lm1pbkZvcmNlID0gLW1heEZvcmNlO1xuICAgIHgubWF4Rm9yY2UgPSB5Lm1heEZvcmNlID0gei5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcblxuICAgIHgubmkuc2V0KDEsIDAsIDApO1xuICAgIHkubmkuc2V0KDAsIDEsIDApO1xuICAgIHoubmkuc2V0KDAsIDAsIDEpO1xufVxuUG9pbnRUb1BvaW50Q29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuXG5Qb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUE7XG4gICAgdmFyIGJvZHlCID0gdGhpcy5ib2R5QjtcbiAgICB2YXIgeCA9IHRoaXMuZXF1YXRpb25YO1xuICAgIHZhciB5ID0gdGhpcy5lcXVhdGlvblk7XG4gICAgdmFyIHogPSB0aGlzLmVxdWF0aW9uWjtcblxuICAgIC8vIFJvdGF0ZSB0aGUgcGl2b3RzIHRvIHdvcmxkIHNwYWNlXG4gICAgYm9keUEucXVhdGVybmlvbi52bXVsdCh0aGlzLnBpdm90QSx4LnJpKTtcbiAgICBib2R5Qi5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMucGl2b3RCLHgucmopO1xuXG4gICAgeS5yaS5jb3B5KHgucmkpO1xuICAgIHkucmouY29weSh4LnJqKTtcbiAgICB6LnJpLmNvcHkoeC5yaSk7XG4gICAgei5yai5jb3B5KHgucmopO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IENvbmVFcXVhdGlvbjtcblxudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBNYXQzID0gcmVxdWlyZSgnLi4vbWF0aC9NYXQzJyk7XG52YXIgRXF1YXRpb24gPSByZXF1aXJlKCcuL0VxdWF0aW9uJyk7XG5cbi8qKlxuICogQ29uZSBlcXVhdGlvbi4gV29ya3MgdG8ga2VlcCB0aGUgZ2l2ZW4gYm9keSB3b3JsZCB2ZWN0b3JzIGFsaWduZWQsIG9yIHRpbHRlZCB3aXRoaW4gYSBnaXZlbiBhbmdsZSBmcm9tIGVhY2ggb3RoZXIuXG4gKiBAY2xhc3MgQ29uZUVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0FdIExvY2FsIGF4aXMgaW4gQVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQl0gTG9jYWwgYXhpcyBpbiBCXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmFuZ2xlXSBUaGUgXCJjb25lIGFuZ2xlXCIgdG8ga2VlcFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlPTFlNl1cbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKi9cbmZ1bmN0aW9uIENvbmVFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBtYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2O1xuXG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLGJvZHlBLGJvZHlCLC1tYXhGb3JjZSwgbWF4Rm9yY2UpO1xuXG4gICAgdGhpcy5heGlzQSA9IG9wdGlvbnMuYXhpc0EgPyBvcHRpb25zLmF4aXNBLmNsb25lKCkgOiBuZXcgVmVjMygxLCAwLCAwKTtcbiAgICB0aGlzLmF4aXNCID0gb3B0aW9ucy5heGlzQiA/IG9wdGlvbnMuYXhpc0IuY2xvbmUoKSA6IG5ldyBWZWMzKDAsIDEsIDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmUgYW5nbGUgdG8ga2VlcFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSB0eXBlb2Yob3B0aW9ucy5hbmdsZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5hbmdsZSA6IDA7XG59XG5cbkNvbmVFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcbkNvbmVFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25lRXF1YXRpb247XG5cbnZhciB0bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciB0bXBWZWMyID0gbmV3IFZlYzMoKTtcblxuQ29uZUVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGgpe1xuICAgIHZhciBhID0gdGhpcy5hLFxuICAgICAgICBiID0gdGhpcy5iLFxuXG4gICAgICAgIG5pID0gdGhpcy5heGlzQSxcbiAgICAgICAgbmogPSB0aGlzLmF4aXNCLFxuXG4gICAgICAgIG5peG5qID0gdG1wVmVjMSxcbiAgICAgICAgbmp4bmkgPSB0bXBWZWMyLFxuXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIG5pLmNyb3NzKG5qLCBuaXhuaik7XG4gICAgbmouY3Jvc3MobmksIG5qeG5pKTtcblxuICAgIC8vIFRoZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3IgaXM6XG4gICAgLy8gY29zKHRoZXRhKSA9IGEgKiBiIC8gKGxlbmd0aChhKSAqIGxlbmd0aChiKSA9IHsgbGVuKGEpID0gbGVuKGIpID0gMSB9ID0gYSAqIGJcblxuICAgIC8vIGcgPSBhICogYlxuICAgIC8vIGdkb3QgPSAoYiB4IGEpICogd2kgKyAoYSB4IGIpICogd2pcbiAgICAvLyBHID0gWzAgYnhhIDAgYXhiXVxuICAgIC8vIFcgPSBbdmkgd2kgdmogd2pdXG4gICAgR0Eucm90YXRpb25hbC5jb3B5KG5qeG5pKTtcbiAgICBHQi5yb3RhdGlvbmFsLmNvcHkobml4bmopO1xuXG4gICAgdmFyIGcgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSAtIG5pLmRvdChuaiksXG4gICAgICAgIEdXID0gdGhpcy5jb21wdXRlR1coKSxcbiAgICAgICAgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcblxuICAgIHZhciBCID0gLSBnICogYSAtIEdXICogYiAtIGggKiBHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RFcXVhdGlvbjtcblxudmFyIEVxdWF0aW9uID0gcmVxdWlyZSgnLi9FcXVhdGlvbicpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBNYXQzID0gcmVxdWlyZSgnLi4vbWF0aC9NYXQzJyk7XG5cbi8qKlxuICogQ29udGFjdC9ub24tcGVuZXRyYXRpb24gY29uc3RyYWludCBlcXVhdGlvblxuICogQGNsYXNzIENvbnRhY3RFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCLCBtYXhGb3JjZSl7XG4gICAgbWF4Rm9yY2UgPSB0eXBlb2YobWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG1heEZvcmNlIDogMWU2O1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAwLCBtYXhGb3JjZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSAwLjA7IC8vIFwiYm91bmNpbmVzc1wiOiB1MSA9IC1lKnUwXG5cbiAgICAvKipcbiAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgdGhhdCBnb2VzIGZyb20gdGhlIGNlbnRlciBvZiBiaSB0byB0aGUgY29udGFjdCBwb2ludC5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHJpXG4gICAgICovXG4gICAgdGhpcy5yaSA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgdGhhdCBzdGFydHMgaW4gYm9keSBqIHBvc2l0aW9uIGFuZCBnb2VzIHRvIHRoZSBjb250YWN0IHBvaW50LlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcmpcbiAgICAgKi9cbiAgICB0aGlzLnJqID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhY3Qgbm9ybWFsLCBwb2ludGluZyBvdXQgb2YgYm9keSBpLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gbmlcbiAgICAgKi9cbiAgICB0aGlzLm5pID0gbmV3IFZlYzMoKTtcbn1cblxuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhY3RFcXVhdGlvbjtcblxudmFyIENvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMSA9IG5ldyBWZWMzKCk7IC8vIFRlbXAgdmVjdG9yc1xudmFyIENvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMiA9IG5ldyBWZWMzKCk7XG52YXIgQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAzID0gbmV3IFZlYzMoKTtcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIHJpID0gdGhpcy5yaSxcbiAgICAgICAgcmogPSB0aGlzLnJqLFxuICAgICAgICByaXhuID0gQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAxLFxuICAgICAgICByanhuID0gQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyLFxuXG4gICAgICAgIHZpID0gYmkudmVsb2NpdHksXG4gICAgICAgIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICBmaSA9IGJpLmZvcmNlLFxuICAgICAgICB0YXVpID0gYmkudG9ycXVlLFxuXG4gICAgICAgIHZqID0gYmoudmVsb2NpdHksXG4gICAgICAgIHdqID0gYmouYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICBmaiA9IGJqLmZvcmNlLFxuICAgICAgICB0YXVqID0gYmoudG9ycXVlLFxuXG4gICAgICAgIHBlbmV0cmF0aW9uVmVjID0gQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAzLFxuXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcblxuICAgICAgICBuID0gdGhpcy5uaTtcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIHJpLmNyb3NzKG4scml4bik7XG4gICAgcmouY3Jvc3MobixyanhuKTtcblxuICAgIC8vIGcgPSB4aityaiAtKHhpK3JpKVxuICAgIC8vIEcgPSBbIC1uaSAgLXJpeG4gIG5pICByanhuIF1cbiAgICBuLm5lZ2F0ZShHQS5zcGF0aWFsKTtcbiAgICByaXhuLm5lZ2F0ZShHQS5yb3RhdGlvbmFsKTtcbiAgICBHQi5zcGF0aWFsLmNvcHkobik7XG4gICAgR0Iucm90YXRpb25hbC5jb3B5KHJqeG4pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwZW5ldHJhdGlvbiB2ZWN0b3JcbiAgICBwZW5ldHJhdGlvblZlYy5jb3B5KGJqLnBvc2l0aW9uKTtcbiAgICBwZW5ldHJhdGlvblZlYy52YWRkKHJqLHBlbmV0cmF0aW9uVmVjKTtcbiAgICBwZW5ldHJhdGlvblZlYy52c3ViKGJpLnBvc2l0aW9uLHBlbmV0cmF0aW9uVmVjKTtcbiAgICBwZW5ldHJhdGlvblZlYy52c3ViKHJpLHBlbmV0cmF0aW9uVmVjKTtcblxuICAgIHZhciBnID0gbi5kb3QocGVuZXRyYXRpb25WZWMpO1xuXG4gICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cbiAgICB2YXIgZVBsdXNPbmUgPSB0aGlzLnJlc3RpdHV0aW9uICsgMTtcbiAgICB2YXIgR1cgPSBlUGx1c09uZSAqIHZqLmRvdChuKSAtIGVQbHVzT25lICogdmkuZG90KG4pICsgd2ouZG90KHJqeG4pIC0gd2kuZG90KHJpeG4pO1xuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuXG4gICAgdmFyIEIgPSAtIGcgKiBhIC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG52YXIgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmkgPSBuZXcgVmVjMygpO1xudmFyIENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3ZqID0gbmV3IFZlYzMoKTtcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aSA9IG5ldyBWZWMzKCk7XG52YXIgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGogPSBuZXcgVmVjMygpO1xudmFyIENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3JlbFZlbCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHJlbGF0aXZlIHZlbG9jaXR5IGluIHRoZSBjb250YWN0IHBvaW50LlxuICogQG1ldGhvZCBnZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZpID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmk7XG4gICAgdmFyIHZqID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmo7XG4gICAgdmFyIHhpID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGk7XG4gICAgdmFyIHhqID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGo7XG4gICAgdmFyIHJlbFZlbCA9IENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3JlbFZlbDtcblxuICAgIHRoaXMuYmkucG9zaXRpb24udmFkZCh0aGlzLnJpLCB4aSk7XG4gICAgdGhpcy5iai5wb3NpdGlvbi52YWRkKHRoaXMucmosIHhqKTtcblxuICAgIHRoaXMuYmkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoeGksIHZpKTtcbiAgICB0aGlzLmJqLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHhqLCB2aik7XG5cbiAgICB2aS52c3ViKHZqLCByZWxWZWwpO1xuXG4gICAgcmV0dXJuIHRoaXMubmkuZG90KHJlbFZlbCk7XG59O1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IEVxdWF0aW9uO1xuXG52YXIgSmFjb2JpYW5FbGVtZW50ID0gcmVxdWlyZSgnLi4vbWF0aC9KYWNvYmlhbkVsZW1lbnQnKSxcbiAgICBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG5cbi8qKlxuICogRXF1YXRpb24gYmFzZSBjbGFzc1xuICogQGNsYXNzIEVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYmlcbiAqIEBwYXJhbSB7Qm9keX0gYmpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5Gb3JjZSBNaW5pbXVtIChyZWFkOiBuZWdhdGl2ZSBtYXgpIGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4Rm9yY2UgTWF4aW11bSAocmVhZDogcG9zaXRpdmUgbWF4KSBmb3JjZSB0byBiZSBhcHBsaWVkIGJ5IHRoZSBjb25zdHJhaW50LlxuICovXG5mdW5jdGlvbiBFcXVhdGlvbihiaSxiaixtaW5Gb3JjZSxtYXhGb3JjZSl7XG4gICAgdGhpcy5pZCA9IEVxdWF0aW9uLmlkKys7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluRm9yY2VcbiAgICAgKi9cbiAgICB0aGlzLm1pbkZvcmNlID0gdHlwZW9mKG1pbkZvcmNlKT09PVwidW5kZWZpbmVkXCIgPyAtMWU2IDogbWluRm9yY2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4Rm9yY2VcbiAgICAgKi9cbiAgICB0aGlzLm1heEZvcmNlID0gdHlwZW9mKG1heEZvcmNlKT09PVwidW5kZWZpbmVkXCIgPyAxZTYgOiBtYXhGb3JjZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBiaVxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYmkgPSBiaTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBialxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYmogPSBiajtcblxuICAgIC8qKlxuICAgICAqIFNQT09LIHBhcmFtZXRlclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhXG4gICAgICovXG4gICAgdGhpcy5hID0gMC4wO1xuXG4gICAgLyoqXG4gICAgICogU1BPT0sgcGFyYW1ldGVyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJcbiAgICAgKi9cbiAgICB0aGlzLmIgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBTUE9PSyBwYXJhbWV0ZXJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZXBzXG4gICAgICovXG4gICAgdGhpcy5lcHMgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0phY29iaWFuRWxlbWVudH0gamFjb2JpYW5FbGVtZW50QVxuICAgICAqL1xuICAgIHRoaXMuamFjb2JpYW5FbGVtZW50QSA9IG5ldyBKYWNvYmlhbkVsZW1lbnQoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7SmFjb2JpYW5FbGVtZW50fSBqYWNvYmlhbkVsZW1lbnRCXG4gICAgICovXG4gICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRCID0gbmV3IEphY29iaWFuRWxlbWVudCgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBlbmFibGVkXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBBIG51bWJlciwgcHJvcG9ydGlvbmFsIHRvIHRoZSBmb3JjZSBhZGRlZCB0byB0aGUgYm9kaWVzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtdWx0aXBsaWVyXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5tdWx0aXBsaWVyID0gMDtcblxuICAgIC8vIFNldCB0eXBpY2FsIHNwb29rIHBhcmFtc1xuICAgIHRoaXMuc2V0U3Bvb2tQYXJhbXMoMWU3LDQsMS82MCk7XG59XG5FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcXVhdGlvbjtcblxuRXF1YXRpb24uaWQgPSAwO1xuXG4vKipcbiAqIFJlY2FsY3VsYXRlcyBhLGIsZXBzLlxuICogQG1ldGhvZCBzZXRTcG9va1BhcmFtc1xuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuc2V0U3Bvb2tQYXJhbXMgPSBmdW5jdGlvbihzdGlmZm5lc3MscmVsYXhhdGlvbix0aW1lU3RlcCl7XG4gICAgdmFyIGQgPSByZWxheGF0aW9uLFxuICAgICAgICBrID0gc3RpZmZuZXNzLFxuICAgICAgICBoID0gdGltZVN0ZXA7XG4gICAgdGhpcy5hID0gNC4wIC8gKGggKiAoMSArIDQgKiBkKSk7XG4gICAgdGhpcy5iID0gKDQuMCAqIGQpIC8gKDEgKyA0ICogZCk7XG4gICAgdGhpcy5lcHMgPSA0LjAgLyAoaCAqIGggKiBrICogKDEgKyA0ICogZCkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUkhTIG9mIHRoZSBTUE9PSyBlcXVhdGlvblxuICogQG1ldGhvZCBjb21wdXRlQlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKSxcbiAgICAgICAgR3EgPSB0aGlzLmNvbXB1dGVHcSgpLFxuICAgICAgICBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIHJldHVybiAtIEdxICogYSAtIEdXICogYiAtIEdpTWYqaDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgRypxLCB3aGVyZSBxIGFyZSB0aGUgZ2VuZXJhbGl6ZWQgYm9keSBjb29yZGluYXRlc1xuICogQG1ldGhvZCBjb21wdXRlR3FcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIHhpID0gYmkucG9zaXRpb24sXG4gICAgICAgIHhqID0gYmoucG9zaXRpb247XG4gICAgcmV0dXJuIEdBLnNwYXRpYWwuZG90KHhpKSArIEdCLnNwYXRpYWwuZG90KHhqKTtcbn07XG5cbnZhciB6ZXJvID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBDb21wdXRlcyBHKlcsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdXXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1cgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXG4gICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgYmogPSB0aGlzLmJqLFxuICAgICAgICB2aSA9IGJpLnZlbG9jaXR5LFxuICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxuICAgICAgICB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgd2ogPSBiai5hbmd1bGFyVmVsb2NpdHk7XG4gICAgcmV0dXJuIEdBLm11bHRpcGx5VmVjdG9ycyh2aSx3aSkgKyBHQi5tdWx0aXBseVZlY3RvcnModmosd2opO1xufTtcblxuXG4vKipcbiAqIENvbXB1dGVzIEcqV2xhbWJkYSwgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllc1xuICogQG1ldGhvZCBjb21wdXRlR1dsYW1iZGFcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHV2xhbWJkYSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIHZpID0gYmkudmxhbWJkYSxcbiAgICAgICAgdmogPSBiai52bGFtYmRhLFxuICAgICAgICB3aSA9IGJpLndsYW1iZGEsXG4gICAgICAgIHdqID0gYmoud2xhbWJkYTtcbiAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKHZpLHdpKSArIEdCLm11bHRpcGx5VmVjdG9ycyh2aix3aik7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEcqaW52KE0pKmYsIHdoZXJlIE0gaXMgdGhlIG1hc3MgbWF0cml4IHdpdGggZGlhZ29uYWwgYmxvY2tzIGZvciBlYWNoIGJvZHksIGFuZCBmIGFyZSB0aGUgZm9yY2VzIG9uIHRoZSBib2RpZXMuXG4gKiBAbWV0aG9kIGNvbXB1dGVHaU1mXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZhciBpTWZpID0gbmV3IFZlYzMoKSxcbiAgICBpTWZqID0gbmV3IFZlYzMoKSxcbiAgICBpbnZJaV92bXVsdF90YXVpID0gbmV3IFZlYzMoKSxcbiAgICBpbnZJal92bXVsdF90YXVqID0gbmV3IFZlYzMoKTtcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNZiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIGZpID0gYmkuZm9yY2UsXG4gICAgICAgIHRpID0gYmkudG9ycXVlLFxuICAgICAgICBmaiA9IGJqLmZvcmNlLFxuICAgICAgICB0aiA9IGJqLnRvcnF1ZSxcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlO1xuXG4gICAgZmkuc2NhbGUoaW52TWFzc2ksaU1maSk7XG4gICAgZmouc2NhbGUoaW52TWFzc2osaU1maik7XG5cbiAgICBiaS5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdCh0aSxpbnZJaV92bXVsdF90YXVpKTtcbiAgICBiai5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdCh0aixpbnZJal92bXVsdF90YXVqKTtcblxuICAgIHJldHVybiBHQS5tdWx0aXBseVZlY3RvcnMoaU1maSxpbnZJaV92bXVsdF90YXVpKSArIEdCLm11bHRpcGx5VmVjdG9ycyhpTWZqLGludklqX3ZtdWx0X3RhdWopO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHKmludihNKSpHJ1xuICogQG1ldGhvZCBjb21wdXRlR2lNR3RcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIHRtcCA9IG5ldyBWZWMzKCk7XG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdpTUd0ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxuICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgIGJqID0gdGhpcy5iaixcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZJaSA9IGJpLmludkluZXJ0aWFXb3JsZFNvbHZlLFxuICAgICAgICBpbnZJaiA9IGJqLmludkluZXJ0aWFXb3JsZFNvbHZlLFxuICAgICAgICByZXN1bHQgPSBpbnZNYXNzaSArIGludk1hc3NqO1xuXG4gICAgaW52SWkudm11bHQoR0Eucm90YXRpb25hbCx0bXApO1xuICAgIHJlc3VsdCArPSB0bXAuZG90KEdBLnJvdGF0aW9uYWwpO1xuXG4gICAgaW52SWoudm11bHQoR0Iucm90YXRpb25hbCx0bXApO1xuICAgIHJlc3VsdCArPSB0bXAuZG90KEdCLnJvdGF0aW9uYWwpO1xuXG4gICAgcmV0dXJuICByZXN1bHQ7XG59O1xuXG52YXIgYWRkVG9XbGFtYmRhX3RlbXAgPSBuZXcgVmVjMygpLFxuICAgIGFkZFRvV2xhbWJkYV9HaSA9IG5ldyBWZWMzKCksXG4gICAgYWRkVG9XbGFtYmRhX0dqID0gbmV3IFZlYzMoKSxcbiAgICBhZGRUb1dsYW1iZGFfcmkgPSBuZXcgVmVjMygpLFxuICAgIGFkZFRvV2xhbWJkYV9yaiA9IG5ldyBWZWMzKCksXG4gICAgYWRkVG9XbGFtYmRhX01kaWFnID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBBZGQgY29uc3RyYWludCB2ZWxvY2l0eSB0byB0aGUgYm9kaWVzLlxuICogQG1ldGhvZCBhZGRUb1dsYW1iZGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YWxhbWJkYVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuYWRkVG9XbGFtYmRhID0gZnVuY3Rpb24oZGVsdGFsYW1iZGEpe1xuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXG4gICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgYmogPSB0aGlzLmJqLFxuICAgICAgICB0ZW1wID0gYWRkVG9XbGFtYmRhX3RlbXA7XG5cbiAgICAvLyBBZGQgdG8gbGluZWFyIHZlbG9jaXR5XG4gICAgLy8gdl9sYW1iZGEgKz0gaW52KE0pICogZGVsdGFfbGFtYmEgKiBHXG4gICAgYmkudmxhbWJkYS5hZGRTY2FsZWRWZWN0b3IoYmkuaW52TWFzc1NvbHZlICogZGVsdGFsYW1iZGEsIEdBLnNwYXRpYWwsIGJpLnZsYW1iZGEpO1xuICAgIGJqLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGJqLmludk1hc3NTb2x2ZSAqIGRlbHRhbGFtYmRhLCBHQi5zcGF0aWFsLCBiai52bGFtYmRhKTtcblxuICAgIC8vIEFkZCB0byBhbmd1bGFyIHZlbG9jaXR5XG4gICAgYmkuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQoR0Eucm90YXRpb25hbCx0ZW1wKTtcbiAgICBiaS53bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihkZWx0YWxhbWJkYSwgdGVtcCwgYmkud2xhbWJkYSk7XG5cbiAgICBiai5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdChHQi5yb3RhdGlvbmFsLHRlbXApO1xuICAgIGJqLndsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGRlbHRhbGFtYmRhLCB0ZW1wLCBiai53bGFtYmRhKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgZGVub21pbmF0b3IgcGFydCBvZiB0aGUgU1BPT0sgZXF1YXRpb246IEMgPSBHKmludihNKSpHJyArIGVwc1xuICogQG1ldGhvZCBjb21wdXRlSW52Q1xuICogQHBhcmFtICB7TnVtYmVyfSBlcHNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVDID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlR2lNR3QoKSArIHRoaXMuZXBzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gRnJpY3Rpb25FcXVhdGlvbjtcblxudmFyIEVxdWF0aW9uID0gcmVxdWlyZSgnLi9FcXVhdGlvbicpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBNYXQzID0gcmVxdWlyZSgnLi4vbWF0aC9NYXQzJyk7XG5cbi8qKlxuICogQ29uc3RyYWlucyB0aGUgc2xpcHBpbmcgaW4gYSBjb250YWN0IGFsb25nIGEgdGFuZ2VudFxuICogQGNsYXNzIEZyaWN0aW9uRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IHNsaXBGb3JjZSBzaG91bGQgYmUgKy1GX2ZyaWN0aW9uID0gKy1tdSAqIEZfbm9ybWFsID0gKy1tdSAqIG0gKiBnXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKXtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsYm9keUEsIGJvZHlCLCAtc2xpcEZvcmNlLCBzbGlwRm9yY2UpO1xuICAgIHRoaXMucmkgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMucmogPSBuZXcgVmVjMygpO1xuICAgIHRoaXMudCA9IG5ldyBWZWMzKCk7IC8vIHRhbmdlbnRcbn1cblxuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJpY3Rpb25FcXVhdGlvbjtcblxudmFyIEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpO1xudmFyIEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDIgPSBuZXcgVmVjMygpO1xuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIHJpID0gdGhpcy5yaSxcbiAgICAgICAgcmogPSB0aGlzLnJqLFxuICAgICAgICByaXh0ID0gRnJpY3Rpb25FcXVhdGlvbl9jb21wdXRlQl90ZW1wMSxcbiAgICAgICAgcmp4dCA9IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDIsXG4gICAgICAgIHQgPSB0aGlzLnQ7XG5cbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICByaS5jcm9zcyh0LHJpeHQpO1xuICAgIHJqLmNyb3NzKHQscmp4dCk7XG5cbiAgICAvLyBHID0gWy10IC1yaXh0IHQgcmp4dF1cbiAgICAvLyBBbmQgcmVtZW1iZXIsIHRoaXMgaXMgYSBwdXJlIHZlbG9jaXR5IGNvbnN0cmFpbnQsIGcgaXMgYWx3YXlzIHplcm8hXG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcbiAgICB0Lm5lZ2F0ZShHQS5zcGF0aWFsKTtcbiAgICByaXh0Lm5lZ2F0ZShHQS5yb3RhdGlvbmFsKTtcbiAgICBHQi5zcGF0aWFsLmNvcHkodCk7XG4gICAgR0Iucm90YXRpb25hbC5jb3B5KHJqeHQpO1xuXG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcblxuICAgIHZhciBCID0gLSBHVyAqIGIgLSBoICogR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gUm90YXRpb25hbEVxdWF0aW9uO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIE1hdDMgPSByZXF1aXJlKCcuLi9tYXRoL01hdDMnKTtcbnZhciBFcXVhdGlvbiA9IHJlcXVpcmUoJy4vRXF1YXRpb24nKTtcblxuLyoqXG4gKiBSb3RhdGlvbmFsIGNvbnN0cmFpbnQuIFdvcmtzIHRvIGtlZXAgdGhlIGxvY2FsIHZlY3RvcnMgb3J0aG9nb25hbCB0byBlYWNoIG90aGVyIGluIHdvcmxkIHNwYWNlLlxuICogQGNsYXNzIFJvdGF0aW9uYWxFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNBXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZV1cbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKi9cbmZ1bmN0aW9uIFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBtYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2O1xuXG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLGJvZHlBLGJvZHlCLC1tYXhGb3JjZSwgbWF4Rm9yY2UpO1xuXG4gICAgdGhpcy5heGlzQSA9IG9wdGlvbnMuYXhpc0EgPyBvcHRpb25zLmF4aXNBLmNsb25lKCkgOiBuZXcgVmVjMygxLCAwLCAwKTtcbiAgICB0aGlzLmF4aXNCID0gb3B0aW9ucy5heGlzQiA/IG9wdGlvbnMuYXhpc0IuY2xvbmUoKSA6IG5ldyBWZWMzKDAsIDEsIDApO1xuXG4gICAgdGhpcy5tYXhBbmdsZSA9IE1hdGguUEkgLyAyO1xufVxuXG5Sb3RhdGlvbmFsRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Sb3RhdGlvbmFsRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbEVxdWF0aW9uO1xuXG52YXIgdG1wVmVjMSA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XG5cblJvdGF0aW9uYWxFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcblxuICAgICAgICBuaSA9IHRoaXMuYXhpc0EsXG4gICAgICAgIG5qID0gdGhpcy5heGlzQixcblxuICAgICAgICBuaXhuaiA9IHRtcFZlYzEsXG4gICAgICAgIG5qeG5pID0gdG1wVmVjMixcblxuICAgICAgICBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7XG5cbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICBuaS5jcm9zcyhuaiwgbml4bmopO1xuICAgIG5qLmNyb3NzKG5pLCBuanhuaSk7XG5cbiAgICAvLyBnID0gbmkgKiBualxuICAgIC8vIGdkb3QgPSAobmogeCBuaSkgKiB3aSArIChuaSB4IG5qKSAqIHdqXG4gICAgLy8gRyA9IFswIG5qeG5pIDAgbml4bmpdXG4gICAgLy8gVyA9IFt2aSB3aSB2aiB3al1cbiAgICBHQS5yb3RhdGlvbmFsLmNvcHkobmp4bmkpO1xuICAgIEdCLnJvdGF0aW9uYWwuY29weShuaXhuaik7XG5cbiAgICB2YXIgZyA9IE1hdGguY29zKHRoaXMubWF4QW5nbGUpIC0gbmkuZG90KG5qKSxcbiAgICAgICAgR1cgPSB0aGlzLmNvbXB1dGVHVygpLFxuICAgICAgICBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuXG4gICAgdmFyIEIgPSAtIGcgKiBhIC0gR1cgKiBiIC0gaCAqIEdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gUm90YXRpb25hbE1vdG9yRXF1YXRpb247XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgTWF0MyA9IHJlcXVpcmUoJy4uL21hdGgvTWF0MycpO1xudmFyIEVxdWF0aW9uID0gcmVxdWlyZSgnLi9FcXVhdGlvbicpO1xuXG4vKipcbiAqIFJvdGF0aW9uYWwgbW90b3IgY29uc3RyYWludC4gVHJpZXMgdG8ga2VlcCB0aGUgcmVsYXRpdmUgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgYm9kaWVzIHRvIGEgZ2l2ZW4gdmFsdWUuXG4gKiBAY2xhc3MgUm90YXRpb25hbE1vdG9yRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEZvcmNlXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbihib2R5QSwgYm9keUIsIG1heEZvcmNlKXtcbiAgICBtYXhGb3JjZSA9IHR5cGVvZihtYXhGb3JjZSkhPT0ndW5kZWZpbmVkJyA/IG1heEZvcmNlIDogMWU2O1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcyxib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpO1xuXG4gICAgLyoqXG4gICAgICogV29ybGQgb3JpZW50ZWQgcm90YXRpb25hbCBheGlzXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBheGlzQVxuICAgICAqL1xuICAgIHRoaXMuYXhpc0EgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogV29ybGQgb3JpZW50ZWQgcm90YXRpb25hbCBheGlzXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBheGlzQlxuICAgICAqL1xuICAgIHRoaXMuYXhpc0IgPSBuZXcgVmVjMygpOyAvLyBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXNcblxuICAgIC8qKlxuICAgICAqIE1vdG9yIHZlbG9jaXR5XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRhcmdldFZlbG9jaXR5XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRWZWxvY2l0eSA9IDA7XG59XG5cblJvdGF0aW9uYWxNb3RvckVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuUm90YXRpb25hbE1vdG9yRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbE1vdG9yRXF1YXRpb247XG5cblJvdGF0aW9uYWxNb3RvckVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGgpe1xuICAgIHZhciBhID0gdGhpcy5hLFxuICAgICAgICBiID0gdGhpcy5iLFxuICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgIGJqID0gdGhpcy5iaixcblxuICAgICAgICBheGlzQSA9IHRoaXMuYXhpc0EsXG4gICAgICAgIGF4aXNCID0gdGhpcy5heGlzQixcblxuICAgICAgICBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7XG5cbiAgICAvLyBnID0gMFxuICAgIC8vIGdkb3QgPSBheGlzQSAqIHdpIC0gYXhpc0IgKiB3alxuICAgIC8vIGdkb3QgPSBHICogVyA9IEcgKiBbdmkgd2kgdmogd2pdXG4gICAgLy8gPT5cbiAgICAvLyBHID0gWzAgYXhpc0EgMCAtYXhpc0JdXG5cbiAgICBHQS5yb3RhdGlvbmFsLmNvcHkoYXhpc0EpO1xuICAgIGF4aXNCLm5lZ2F0ZShHQi5yb3RhdGlvbmFsKTtcblxuICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCkgLSB0aGlzLnRhcmdldFZlbG9jaXR5LFxuICAgICAgICBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuXG4gICAgdmFyIEIgPSAtIEdXICogYiAtIGggKiBHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuIiwidmFyIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWN0TWF0ZXJpYWw7XG5cbi8qKlxuICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB0d28gbWF0ZXJpYWxzIG1lZXQuXG4gKiBAY2xhc3MgQ29udGFjdE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG0xXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtMlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZyaWN0aW9uPTAuM11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXN0aXR1dGlvbj0wLjNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzPTFlN11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uPTNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcz0xZTddXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb249M11cbiAqL1xuZnVuY3Rpb24gQ29udGFjdE1hdGVyaWFsKG0xLCBtMiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgZnJpY3Rpb246IDAuMyxcbiAgICAgICAgcmVzdGl0dXRpb246IDAuMyxcbiAgICAgICAgY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzOiAxZTcsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb246IDMsXG4gICAgICAgIGZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M6IDFlNyxcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb246IDNcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXIgb2YgdGhpcyBtYXRlcmlhbFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZFxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBQYXJ0aWNpcGF0aW5nIG1hdGVyaWFsc1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG1hdGVyaWFsc1xuICAgICAqIEB0b2RvICBTaG91bGQgYmUgLm1hdGVyaWFsQSBhbmQgLm1hdGVyaWFsQiBpbnN0ZWFkXG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbHMgPSBbbTEsIG0yXTtcblxuICAgIC8qKlxuICAgICAqIEZyaWN0aW9uIGNvZWZmaWNpZW50XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBSZXN0aXR1dGlvbiBjb2VmZmljaWVudFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZXN0aXR1dGlvblxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSBvcHRpb25zLnJlc3RpdHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSBwcm9kdWNlZCBjb250YWN0IGVxdWF0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0RXF1YXRpb25TdGlmZm5lc3NcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXhhdGlvbiB0aW1lIG9mIHRoZSBwcm9kdWNlZCBjb250YWN0IGVxdWF0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0RXF1YXRpb25SZWxheGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uID0gb3B0aW9ucy5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSBwcm9kdWNlZCBmcmljdGlvbiBlcXVhdGlvbnNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzc1xuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcztcblxuICAgIC8qKlxuICAgICAqIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb247XG59XG5cbkNvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBNYXRlcmlhbDtcblxuLyoqXG4gKiBEZWZpbmVzIGEgcGh5c2ljcyBtYXRlcmlhbC5cbiAqIEBjbGFzcyBNYXRlcmlhbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIE1hdGVyaWFsKG9wdGlvbnMpe1xuICAgIHZhciBuYW1lID0gJyc7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmaXhcbiAgICBpZih0eXBlb2Yob3B0aW9ucykgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgbmFtZSA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9IGVsc2UgaWYodHlwZW9mKG9wdGlvbnMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBuYW1lID0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG5hbWVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBtYXRlcmlhbCBpZC5cbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBNYXRlcmlhbC5pZENvdW50ZXIrKztcblxuICAgIC8qKlxuICAgICAqIEZyaWN0aW9uIGZvciB0aGlzIG1hdGVyaWFsLiBJZiBub24tbmVnYXRpdmUsIGl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBmcmljdGlvbiBnaXZlbiBieSBDb250YWN0TWF0ZXJpYWxzLiBJZiB0aGVyZSdzIG5vIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgdGhlIHZhbHVlIGZyb20gLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwgaW4gdGhlIFdvcmxkIHdpbGwgYmUgdXNlZC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZnJpY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uID0gdHlwZW9mKG9wdGlvbnMuZnJpY3Rpb24pICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuZnJpY3Rpb24gOiAtMTtcblxuICAgIC8qKlxuICAgICAqIFJlc3RpdHV0aW9uIGZvciB0aGlzIG1hdGVyaWFsLiBJZiBub24tbmVnYXRpdmUsIGl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSByZXN0aXR1dGlvbiBnaXZlbiBieSBDb250YWN0TWF0ZXJpYWxzLiBJZiB0aGVyZSdzIG5vIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgdGhlIHZhbHVlIGZyb20gLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwgaW4gdGhlIFdvcmxkIHdpbGwgYmUgdXNlZC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcmVzdGl0dXRpb25cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gdHlwZW9mKG9wdGlvbnMucmVzdGl0dXRpb24pICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMucmVzdGl0dXRpb24gOiAtMTtcbn1cblxuTWF0ZXJpYWwuaWRDb3VudGVyID0gMDtcbiIsIm1vZHVsZS5leHBvcnRzID0gSmFjb2JpYW5FbGVtZW50O1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoJy4vVmVjMycpO1xuXG4vKipcbiAqIEFuIGVsZW1lbnQgY29udGFpbmluZyA2IGVudHJpZXMsIDMgc3BhdGlhbCBhbmQgMyByb3RhdGlvbmFsIGRlZ3JlZXMgb2YgZnJlZWRvbS5cbiAqIEBjbGFzcyBKYWNvYmlhbkVsZW1lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBKYWNvYmlhbkVsZW1lbnQoKXtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gc3BhdGlhbFxuICAgICAqL1xuICAgIHRoaXMuc3BhdGlhbCA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHJvdGF0aW9uYWxcbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uYWwgPSBuZXcgVmVjMygpO1xufVxuXG4vKipcbiAqIE11bHRpcGx5IHdpdGggb3RoZXIgSmFjb2JpYW5FbGVtZW50XG4gKiBAbWV0aG9kIG11bHRpcGx5RWxlbWVudFxuICogQHBhcmFtICB7SmFjb2JpYW5FbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkphY29iaWFuRWxlbWVudC5wcm90b3R5cGUubXVsdGlwbHlFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCl7XG4gICAgcmV0dXJuIGVsZW1lbnQuc3BhdGlhbC5kb3QodGhpcy5zcGF0aWFsKSArIGVsZW1lbnQucm90YXRpb25hbC5kb3QodGhpcy5yb3RhdGlvbmFsKTtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgd2l0aCB0d28gdmVjdG9yc1xuICogQG1ldGhvZCBtdWx0aXBseVZlY3RvcnNcbiAqIEBwYXJhbSAge1ZlYzN9IHNwYXRpYWxcbiAqIEBwYXJhbSAge1ZlYzN9IHJvdGF0aW9uYWxcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuSmFjb2JpYW5FbGVtZW50LnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcnMgPSBmdW5jdGlvbihzcGF0aWFsLHJvdGF0aW9uYWwpe1xuICAgIHJldHVybiBzcGF0aWFsLmRvdCh0aGlzLnNwYXRpYWwpICsgcm90YXRpb25hbC5kb3QodGhpcy5yb3RhdGlvbmFsKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IE1hdDM7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnLi9WZWMzJyk7XG5cbi8qKlxuICogQSAzeDMgbWF0cml4LlxuICogQGNsYXNzIE1hdDNcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGFycmF5IGVsZW1lbnRzIEFycmF5IG9mIG5pbmUgZWxlbWVudHMuIE9wdGlvbmFsLlxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHA6Ly9naXRodWIuY29tL3NjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIE1hdDMoZWxlbWVudHMpe1xuICAgIC8qKlxuICAgICAqIEEgdmVjdG9yIG9mIGxlbmd0aCA5LCBjb250YWluaW5nIGFsbCBtYXRyaXggZWxlbWVudHNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBlbGVtZW50c1xuICAgICAqL1xuICAgIGlmKGVsZW1lbnRzKXtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbMCwwLDAsMCwwLDAsMCwwLDBdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXRyaXggdG8gaWRlbnRpdHlcbiAqIEBtZXRob2QgaWRlbnRpdHlcbiAqIEB0b2RvIFNob3VsZCBwZXJoYXBzIGJlIHJlbmFtZWQgdG8gc2V0SWRlbnRpdHkoKSB0byBiZSBtb3JlIGNsZWFyLlxuICogQHRvZG8gQ3JlYXRlIGFub3RoZXIgZnVuY3Rpb24gdGhhdCBpbW1lZGlhdGVseSBjcmVhdGVzIGFuIGlkZW50aXR5IG1hdHJpeCBlZy4gZXllKClcbiAqL1xuTWF0My5wcm90b3R5cGUuaWRlbnRpdHkgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcbiAgICBlWzBdID0gMTtcbiAgICBlWzFdID0gMDtcbiAgICBlWzJdID0gMDtcblxuICAgIGVbM10gPSAwO1xuICAgIGVbNF0gPSAxO1xuICAgIGVbNV0gPSAwO1xuXG4gICAgZVs2XSA9IDA7XG4gICAgZVs3XSA9IDA7XG4gICAgZVs4XSA9IDE7XG59O1xuXG4vKipcbiAqIFNldCBhbGwgZWxlbWVudHMgdG8gemVyb1xuICogQG1ldGhvZCBzZXRaZXJvXG4gKi9cbk1hdDMucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbigpe1xuICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcbiAgICBlWzBdID0gMDtcbiAgICBlWzFdID0gMDtcbiAgICBlWzJdID0gMDtcbiAgICBlWzNdID0gMDtcbiAgICBlWzRdID0gMDtcbiAgICBlWzVdID0gMDtcbiAgICBlWzZdID0gMDtcbiAgICBlWzddID0gMDtcbiAgICBlWzhdID0gMDtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF0cml4IGRpYWdvbmFsIGVsZW1lbnRzIGZyb20gYSBWZWMzXG4gKiBAbWV0aG9kIHNldFRyYWNlXG4gKiBAcGFyYW0ge1ZlYzN9IHZlYzNcbiAqL1xuTWF0My5wcm90b3R5cGUuc2V0VHJhY2UgPSBmdW5jdGlvbih2ZWMzKXtcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgZVswXSA9IHZlYzMueDtcbiAgICBlWzRdID0gdmVjMy55O1xuICAgIGVbOF0gPSB2ZWMzLno7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG1hdHJpeCBkaWFnb25hbCBlbGVtZW50c1xuICogQG1ldGhvZCBnZXRUcmFjZVxuICogQHJldHVybiB7VmVjM31cbiAqL1xuTWF0My5wcm90b3R5cGUuZ2V0VHJhY2UgPSBmdW5jdGlvbih0YXJnZXQpe1xuICAgIHZhciB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgdGFyZ2V0LnggPSBlWzBdO1xuICAgIHRhcmdldC55ID0gZVs0XTtcbiAgICB0YXJnZXQueiA9IGVbOF07XG59O1xuXG4vKipcbiAqIE1hdHJpeC1WZWN0b3IgbXVsdGlwbGljYXRpb25cbiAqIEBtZXRob2Qgdm11bHRcbiAqIEBwYXJhbSB7VmVjM30gdiBUaGUgdmVjdG9yIHRvIG11bHRpcGx5IHdpdGhcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLCB0YXJnZXQgdG8gc2F2ZSB0aGUgcmVzdWx0IGluLlxuICovXG5NYXQzLnByb3RvdHlwZS52bXVsdCA9IGZ1bmN0aW9uKHYsdGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcblxuICAgIHZhciBlID0gdGhpcy5lbGVtZW50cyxcbiAgICAgICAgeCA9IHYueCxcbiAgICAgICAgeSA9IHYueSxcbiAgICAgICAgeiA9IHYuejtcbiAgICB0YXJnZXQueCA9IGVbMF0qeCArIGVbMV0qeSArIGVbMl0qejtcbiAgICB0YXJnZXQueSA9IGVbM10qeCArIGVbNF0qeSArIGVbNV0qejtcbiAgICB0YXJnZXQueiA9IGVbNl0qeCArIGVbN10qeSArIGVbOF0qejtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIE1hdHJpeC1zY2FsYXIgbXVsdGlwbGljYXRpb25cbiAqIEBtZXRob2Qgc211bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzXG4gKi9cbk1hdDMucHJvdG90eXBlLnNtdWx0ID0gZnVuY3Rpb24ocyl7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5lbGVtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0gKj0gcztcbiAgICB9XG59O1xuXG4vKipcbiAqIE1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICogQG1ldGhvZCBtbXVsdFxuICogQHBhcmFtIHtNYXQzfSBtIE1hdHJpeCB0byBtdWx0aXBseSB3aXRoIGZyb20gbGVmdCBzaWRlLlxuICogQHJldHVybiB7TWF0M30gVGhlIHJlc3VsdC5cbiAqL1xuTWF0My5wcm90b3R5cGUubW11bHQgPSBmdW5jdGlvbihtLHRhcmdldCl7XG4gICAgdmFyIHIgPSB0YXJnZXQgfHwgbmV3IE1hdDMoKTtcbiAgICBmb3IodmFyIGk9MDsgaTwzOyBpKyspe1xuICAgICAgICBmb3IodmFyIGo9MDsgajwzOyBqKyspe1xuICAgICAgICAgICAgdmFyIHN1bSA9IDAuMDtcbiAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrPDM7IGsrKyl7XG4gICAgICAgICAgICAgICAgc3VtICs9IG0uZWxlbWVudHNbaStrKjNdICogdGhpcy5lbGVtZW50c1trK2oqM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByLmVsZW1lbnRzW2kraiozXSA9IHN1bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogU2NhbGUgZWFjaCBjb2x1bW4gb2YgdGhlIG1hdHJpeFxuICogQG1ldGhvZCBzY2FsZVxuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcmV0dXJuIHtNYXQzfSBUaGUgcmVzdWx0LlxuICovXG5NYXQzLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHYsdGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IE1hdDMoKTtcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHMsXG4gICAgICAgIHQgPSB0YXJnZXQuZWxlbWVudHM7XG4gICAgZm9yKHZhciBpPTA7IGkhPT0zOyBpKyspe1xuICAgICAgICB0WzMqaSArIDBdID0gdi54ICogZVszKmkgKyAwXTtcbiAgICAgICAgdFszKmkgKyAxXSA9IHYueSAqIGVbMyppICsgMV07XG4gICAgICAgIHRbMyppICsgMl0gPSB2LnogKiBlWzMqaSArIDJdO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBTb2x2ZSBBeD1iXG4gKiBAbWV0aG9kIHNvbHZlXG4gKiBAcGFyYW0ge1ZlYzN9IGIgVGhlIHJpZ2h0IGhhbmQgc2lkZVxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwuIFRhcmdldCB2ZWN0b3IgdG8gc2F2ZSBpbi5cbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBzb2x1dGlvbiB4XG4gKiBAdG9kbyBzaG91bGQgcmV1c2UgYXJyYXlzXG4gKi9cbk1hdDMucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oYix0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuXG4gICAgLy8gQ29uc3RydWN0IGVxdWF0aW9uc1xuICAgIHZhciBuciA9IDM7IC8vIG51bSByb3dzXG4gICAgdmFyIG5jID0gNDsgLy8gbnVtIGNvbHNcbiAgICB2YXIgZXFucyA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPG5yKm5jOyBpKyspe1xuICAgICAgICBlcW5zLnB1c2goMCk7XG4gICAgfVxuICAgIHZhciBpLGo7XG4gICAgZm9yKGk9MDsgaTwzOyBpKyspe1xuICAgICAgICBmb3Ioaj0wOyBqPDM7IGorKyl7XG4gICAgICAgICAgICBlcW5zW2krbmMqal0gPSB0aGlzLmVsZW1lbnRzW2krMypqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcW5zWzMrNCowXSA9IGIueDtcbiAgICBlcW5zWzMrNCoxXSA9IGIueTtcbiAgICBlcW5zWzMrNCoyXSA9IGIuejtcblxuICAgIC8vIENvbXB1dGUgcmlnaHQgdXBwZXIgdHJpYW5ndWxhciB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggLSBHYXVzcyBlbGltaW5hdGlvblxuICAgIHZhciBuID0gMywgayA9IG4sIG5wO1xuICAgIHZhciBrcCA9IDQ7IC8vIG51bSByb3dzXG4gICAgdmFyIHAsIGVscztcbiAgICBkbyB7XG4gICAgICAgIGkgPSBrIC0gbjtcbiAgICAgICAgaWYgKGVxbnNbaStuYyppXSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gdGhlIHBpdm90IGlzIG51bGwsIHN3YXAgbGluZXNcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVxbnNbaStuYypqXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBucCA9IGtwO1xuICAgICAgICAgICAgICAgICAgICBkbyB7ICAvLyBkbyBsaWduZSggaSApID0gbGlnbmUoIGkgKSArIGxpZ25lKCBrIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBrcCAtIG5wO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXFuc1twK25jKmldICs9IGVxbnNbcCtuYypqXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXFuc1tpK25jKmldICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gZXFuc1tpK25jKmpdIC8gZXFuc1tpK25jKmldO1xuICAgICAgICAgICAgICAgIG5wID0ga3A7XG4gICAgICAgICAgICAgICAgZG8geyAgLy8gZG8gbGlnbmUoIGsgKSA9IGxpZ25lKCBrICkgLSBtdWx0aXBsaWVyICogbGlnbmUoIGkgKVxuICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcbiAgICAgICAgICAgICAgICAgICAgZXFuc1twK25jKmpdID0gcCA8PSBpID8gMCA6IGVxbnNbcCtuYypqXSAtIGVxbnNbcCtuYyppXSAqIG11bHRpcGxpZXIgO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIC8vIEdldCB0aGUgc29sdXRpb25cbiAgICB0YXJnZXQueiA9IGVxbnNbMipuYyszXSAvIGVxbnNbMipuYysyXTtcbiAgICB0YXJnZXQueSA9IChlcW5zWzEqbmMrM10gLSBlcW5zWzEqbmMrMl0qdGFyZ2V0LnopIC8gZXFuc1sxKm5jKzFdO1xuICAgIHRhcmdldC54ID0gKGVxbnNbMCpuYyszXSAtIGVxbnNbMCpuYysyXSp0YXJnZXQueiAtIGVxbnNbMCpuYysxXSp0YXJnZXQueSkgLyBlcW5zWzAqbmMrMF07XG5cbiAgICBpZihpc05hTih0YXJnZXQueCkgfHwgaXNOYU4odGFyZ2V0LnkpIHx8IGlzTmFOKHRhcmdldC56KSB8fCB0YXJnZXQueD09PUluZmluaXR5IHx8IHRhcmdldC55PT09SW5maW5pdHkgfHwgdGFyZ2V0Lno9PT1JbmZpbml0eSl7XG4gICAgICAgIHRocm93IFwiQ291bGQgbm90IHNvbHZlIGVxdWF0aW9uISBHb3QgeD1bXCIrdGFyZ2V0LnRvU3RyaW5nKCkrXCJdLCBiPVtcIitiLnRvU3RyaW5nKCkrXCJdLCBBPVtcIit0aGlzLnRvU3RyaW5nKCkrXCJdXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2V0IGFuIGVsZW1lbnQgaW4gdGhlIG1hdHJpeCBieSBpbmRleC4gSW5kZXggc3RhcnRzIGF0IDAsIG5vdCAxISEhXG4gKiBAbWV0aG9kIGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByb3dcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW5cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBPcHRpb25hbC4gSWYgcHJvdmlkZWQsIHRoZSBtYXRyaXggZWxlbWVudCB3aWxsIGJlIHNldCB0byB0aGlzIHZhbHVlLlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5NYXQzLnByb3RvdHlwZS5lID0gZnVuY3Rpb24oIHJvdyAsIGNvbHVtbiAsdmFsdWUpe1xuICAgIGlmKHZhbHVlPT09dW5kZWZpbmVkKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbY29sdW1uKzMqcm93XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXQgdmFsdWVcbiAgICAgICAgdGhpcy5lbGVtZW50c1tjb2x1bW4rMypyb3ddID0gdmFsdWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb3B5IGFub3RoZXIgbWF0cml4IGludG8gdGhpcyBtYXRyaXggb2JqZWN0LlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge01hdDN9IHNvdXJjZVxuICogQHJldHVybiB7TWF0M30gdGhpc1xuICovXG5NYXQzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oc291cmNlKXtcbiAgICBmb3IodmFyIGk9MDsgaSA8IHNvdXJjZS5lbGVtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0gPSBzb3VyY2UuZWxlbWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXguXG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAcmV0dXJuIHN0cmluZ1xuICovXG5NYXQzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHIgPSBcIlwiO1xuICAgIHZhciBzZXAgPSBcIixcIjtcbiAgICBmb3IodmFyIGk9MDsgaTw5OyBpKyspe1xuICAgICAgICByICs9IHRoaXMuZWxlbWVudHNbaV0gKyBzZXA7XG4gICAgfVxuICAgIHJldHVybiByO1xufTtcblxuLyoqXG4gKiByZXZlcnNlIHRoZSBtYXRyaXhcbiAqIEBtZXRob2QgcmV2ZXJzZVxuICogQHBhcmFtIHtNYXQzfSB0YXJnZXQgT3B0aW9uYWwuIFRhcmdldCBtYXRyaXggdG8gc2F2ZSBpbi5cbiAqIEByZXR1cm4ge01hdDN9IFRoZSBzb2x1dGlvbiB4XG4gKi9cbk1hdDMucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbih0YXJnZXQpe1xuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBNYXQzKCk7XG5cbiAgICAvLyBDb25zdHJ1Y3QgZXF1YXRpb25zXG4gICAgdmFyIG5yID0gMzsgLy8gbnVtIHJvd3NcbiAgICB2YXIgbmMgPSA2OyAvLyBudW0gY29sc1xuICAgIHZhciBlcW5zID0gW107XG4gICAgZm9yKHZhciBpPTA7IGk8bnIqbmM7IGkrKyl7XG4gICAgICAgIGVxbnMucHVzaCgwKTtcbiAgICB9XG4gICAgdmFyIGksajtcbiAgICBmb3IoaT0wOyBpPDM7IGkrKyl7XG4gICAgICAgIGZvcihqPTA7IGo8MzsgaisrKXtcbiAgICAgICAgICAgIGVxbnNbaStuYypqXSA9IHRoaXMuZWxlbWVudHNbaSszKmpdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVxbnNbMys2KjBdID0gMTtcbiAgICBlcW5zWzMrNioxXSA9IDA7XG4gICAgZXFuc1szKzYqMl0gPSAwO1xuICAgIGVxbnNbNCs2KjBdID0gMDtcbiAgICBlcW5zWzQrNioxXSA9IDE7XG4gICAgZXFuc1s0KzYqMl0gPSAwO1xuICAgIGVxbnNbNSs2KjBdID0gMDtcbiAgICBlcW5zWzUrNioxXSA9IDA7XG4gICAgZXFuc1s1KzYqMl0gPSAxO1xuXG4gICAgLy8gQ29tcHV0ZSByaWdodCB1cHBlciB0cmlhbmd1bGFyIHZlcnNpb24gb2YgdGhlIG1hdHJpeCAtIEdhdXNzIGVsaW1pbmF0aW9uXG4gICAgdmFyIG4gPSAzLCBrID0gbiwgbnA7XG4gICAgdmFyIGtwID0gbmM7IC8vIG51bSByb3dzXG4gICAgdmFyIHA7XG4gICAgZG8ge1xuICAgICAgICBpID0gayAtIG47XG4gICAgICAgIGlmIChlcW5zW2krbmMqaV0gPT09IDApIHtcbiAgICAgICAgICAgIC8vIHRoZSBwaXZvdCBpcyBudWxsLCBzd2FwIGxpbmVzXG4gICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChlcW5zW2krbmMqal0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbnAgPSBrcDtcbiAgICAgICAgICAgICAgICAgICAgZG8geyAvLyBkbyBsaW5lKCBpICkgPSBsaW5lKCBpICkgKyBsaW5lKCBrIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBrcCAtIG5wO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXFuc1twK25jKmldICs9IGVxbnNbcCtuYypqXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXFuc1tpK25jKmldICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gZXFuc1tpK25jKmpdIC8gZXFuc1tpK25jKmldO1xuICAgICAgICAgICAgICAgIG5wID0ga3A7XG4gICAgICAgICAgICAgICAgZG8geyAvLyBkbyBsaW5lKCBrICkgPSBsaW5lKCBrICkgLSBtdWx0aXBsaWVyICogbGluZSggaSApXG4gICAgICAgICAgICAgICAgICAgIHAgPSBrcCAtIG5wO1xuICAgICAgICAgICAgICAgICAgICBlcW5zW3ArbmMqal0gPSBwIDw9IGkgPyAwIDogZXFuc1twK25jKmpdIC0gZXFuc1twK25jKmldICogbXVsdGlwbGllciA7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgLy8gZWxpbWluYXRlIHRoZSB1cHBlciBsZWZ0IHRyaWFuZ2xlIG9mIHRoZSBtYXRyaXhcbiAgICBpID0gMjtcbiAgICBkbyB7XG4gICAgICAgIGogPSBpLTE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gZXFuc1tpK25jKmpdIC8gZXFuc1tpK25jKmldO1xuICAgICAgICAgICAgbnAgPSBuYztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBwID0gbmMgLSBucDtcbiAgICAgICAgICAgICAgICBlcW5zW3ArbmMqal0gPSAgZXFuc1twK25jKmpdIC0gZXFuc1twK25jKmldICogbXVsdGlwbGllciA7XG4gICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcbiAgICAgICAgfSB3aGlsZSAoai0tKTtcbiAgICB9IHdoaWxlICgtLWkpO1xuXG4gICAgLy8gb3BlcmF0aW9ucyBvbiB0aGUgZGlhZ29uYWxcbiAgICBpID0gMjtcbiAgICBkbyB7XG4gICAgICAgIHZhciBtdWx0aXBsaWVyID0gMSAvIGVxbnNbaStuYyppXTtcbiAgICAgICAgbnAgPSBuYztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcCA9IG5jIC0gbnA7XG4gICAgICAgICAgICBlcW5zW3ArbmMqaV0gPSBlcW5zW3ArbmMqaV0gKiBtdWx0aXBsaWVyIDtcbiAgICAgICAgfSB3aGlsZSAoLS1ucCk7XG4gICAgfSB3aGlsZSAoaS0tKTtcblxuICAgIGkgPSAyO1xuICAgIGRvIHtcbiAgICAgICAgaiA9IDI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHAgPSBlcW5zW25yK2orbmMqaV07XG4gICAgICAgICAgICBpZiggaXNOYU4oIHAgKSB8fCBwID09PUluZmluaXR5ICl7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJDb3VsZCBub3QgcmV2ZXJzZSEgQT1bXCIrdGhpcy50b1N0cmluZygpK1wiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LmUoIGkgLCBqICwgcCApO1xuICAgICAgICB9IHdoaWxlIChqLS0pO1xuICAgIH0gd2hpbGUgKGktLSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1hdHJpeCBmcm9tIGEgcXVhdGVyaW9uXG4gKiBAbWV0aG9kIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcVxuICovXG5NYXQzLnByb3RvdHlwZS5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uID0gZnVuY3Rpb24oIHEgKSB7XG4gICAgdmFyIHggPSBxLngsIHkgPSBxLnksIHogPSBxLnosIHcgPSBxLncsXG4gICAgICAgIHgyID0geCArIHgsIHkyID0geSArIHksIHoyID0geiArIHosXG4gICAgICAgIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejIsXG4gICAgICAgIGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgZVszKjAgKyAwXSA9IDEgLSAoIHl5ICsgenogKTtcbiAgICBlWzMqMCArIDFdID0geHkgLSB3ejtcbiAgICBlWzMqMCArIDJdID0geHogKyB3eTtcblxuICAgIGVbMyoxICsgMF0gPSB4eSArIHd6O1xuICAgIGVbMyoxICsgMV0gPSAxIC0gKCB4eCArIHp6ICk7XG4gICAgZVszKjEgKyAyXSA9IHl6IC0gd3g7XG5cbiAgICBlWzMqMiArIDBdID0geHogLSB3eTtcbiAgICBlWzMqMiArIDFdID0geXogKyB3eDtcbiAgICBlWzMqMiArIDJdID0gMSAtICggeHggKyB5eSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgbWF0cml4XG4gKiBAbWV0aG9kIHRyYW5zcG9zZVxuICogQHBhcmFtICB7TWF0M30gdGFyZ2V0IFdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtNYXQzfSBUaGUgdGFyZ2V0IE1hdDMsIG9yIGEgbmV3IE1hdDMgaWYgdGFyZ2V0IHdhcyBvbWl0dGVkLlxuICovXG5NYXQzLnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgTWF0MygpO1xuXG4gICAgdmFyIE10ID0gdGFyZ2V0LmVsZW1lbnRzLFxuICAgICAgICBNID0gdGhpcy5lbGVtZW50cztcblxuICAgIGZvcih2YXIgaT0wOyBpIT09MzsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT0zOyBqKyspe1xuICAgICAgICAgICAgTXRbMyppICsgal0gPSBNWzMqaiArIGldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFF1YXRlcm5pb247XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnLi9WZWMzJyk7XG5cbi8qKlxuICogQSBRdWF0ZXJuaW9uIGRlc2NyaWJlcyBhIHJvdGF0aW9uIGluIDNEIHNwYWNlLiBUaGUgUXVhdGVybmlvbiBpcyBtYXRoZW1hdGljYWxseSBkZWZpbmVkIGFzIFEgPSB4KmkgKyB5KmogKyB6KmsgKyB3LCB3aGVyZSAoaSxqLGspIGFyZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9ycy4gKHgseSx6KSBjYW4gYmUgc2VlbiBhcyBhIHZlY3RvciByZWxhdGVkIHRvIHRoZSBheGlzIG9mIHJvdGF0aW9uLCB3aGlsZSB0aGUgcmVhbCBtdWx0aXBsaWVyLCB3LCBpcyByZWxhdGVkIHRvIHRoZSBhbW91bnQgb2Ygcm90YXRpb24uXG4gKiBAY2xhc3MgUXVhdGVybmlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGkuXG4gKiBAcGFyYW0ge051bWJlcn0geSBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGouXG4gKiBAcGFyYW0ge051bWJlcn0geiBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGsuXG4gKiBAcGFyYW0ge051bWJlcn0gdyBNdWx0aXBsaWVyIG9mIHRoZSByZWFsIHBhcnQuXG4gKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhdGVybmlvblxuICovXG5mdW5jdGlvbiBRdWF0ZXJuaW9uKHgseSx6LHcpe1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB4XG4gICAgICovXG4gICAgdGhpcy54ID0geCE9PXVuZGVmaW5lZCA/IHggOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHlcbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5IT09dW5kZWZpbmVkID8geSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gelxuICAgICAqL1xuICAgIHRoaXMueiA9IHohPT11bmRlZmluZWQgPyB6IDogMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtdWx0aXBsaWVyIG9mIHRoZSByZWFsIHF1YXRlcm5pb24gYmFzaXMgdmVjdG9yLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB3XG4gICAgICovXG4gICAgdGhpcy53ID0gdyE9PXVuZGVmaW5lZCA/IHcgOiAxO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIHF1YXRlcm5pb24uXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gelxuICogQHBhcmFtIHtOdW1iZXJ9IHdcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeCx5LHosdyl7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG4gICAgdGhpcy53ID0gdztcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydCB0byBhIHJlYWRhYmxlIGZvcm1hdFxuICogQG1ldGhvZCB0b1N0cmluZ1xuICogQHJldHVybiBzdHJpbmdcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLngrXCIsXCIrdGhpcy55K1wiLFwiK3RoaXMueitcIixcIit0aGlzLnc7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdG8gYW4gQXJyYXlcbiAqIEBtZXRob2QgdG9BcnJheVxuICogQHJldHVybiBBcnJheVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMud107XG59O1xuXG4vKipcbiAqIFNldCB0aGUgcXVhdGVybmlvbiBjb21wb25lbnRzIGdpdmVuIGFuIGF4aXMgYW5kIGFuIGFuZ2xlLlxuICogQG1ldGhvZCBzZXRGcm9tQXhpc0FuZ2xlXG4gKiBAcGFyYW0ge1ZlYzN9IGF4aXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnNldEZyb21BeGlzQW5nbGUgPSBmdW5jdGlvbihheGlzLGFuZ2xlKXtcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKjAuNSk7XG4gICAgdGhpcy54ID0gYXhpcy54ICogcztcbiAgICB0aGlzLnkgPSBheGlzLnkgKiBzO1xuICAgIHRoaXMueiA9IGF4aXMueiAqIHM7XG4gICAgdGhpcy53ID0gTWF0aC5jb3MoYW5nbGUqMC41KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHF1YXRlcm5pb24gdG8gYXhpcy9hbmdsZSByZXByZXNlbnRhdGlvbi5cbiAqIEBtZXRob2QgdG9BeGlzQW5nbGVcbiAqIEBwYXJhbSB7VmVjM30gW3RhcmdldEF4aXNdIEEgdmVjdG9yIG9iamVjdCB0byByZXVzZSBmb3Igc3RvcmluZyB0aGUgYXhpcy5cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSwgZmlyc3QgZWxlbW50IGlzIHRoZSBheGlzIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS50b0F4aXNBbmdsZSA9IGZ1bmN0aW9uKHRhcmdldEF4aXMpe1xuICAgIHRhcmdldEF4aXMgPSB0YXJnZXRBeGlzIHx8IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5ub3JtYWxpemUoKTsgLy8gaWYgdz4xIGFjb3MgYW5kIHNxcnQgd2lsbCBwcm9kdWNlIGVycm9ycywgdGhpcyBjYW50IGhhcHBlbiBpZiBxdWF0ZXJuaW9uIGlzIG5vcm1hbGlzZWRcbiAgICB2YXIgYW5nbGUgPSAyICogTWF0aC5hY29zKHRoaXMudyk7XG4gICAgdmFyIHMgPSBNYXRoLnNxcnQoMS10aGlzLncqdGhpcy53KTsgLy8gYXNzdW1pbmcgcXVhdGVybmlvbiBub3JtYWxpc2VkIHRoZW4gdyBpcyBsZXNzIHRoYW4gMSwgc28gdGVybSBhbHdheXMgcG9zaXRpdmUuXG4gICAgaWYgKHMgPCAwLjAwMSkgeyAvLyB0ZXN0IHRvIGF2b2lkIGRpdmlkZSBieSB6ZXJvLCBzIGlzIGFsd2F5cyBwb3NpdGl2ZSBkdWUgdG8gc3FydFxuICAgICAgICAvLyBpZiBzIGNsb3NlIHRvIHplcm8gdGhlbiBkaXJlY3Rpb24gb2YgYXhpcyBub3QgaW1wb3J0YW50XG4gICAgICAgIHRhcmdldEF4aXMueCA9IHRoaXMueDsgLy8gaWYgaXQgaXMgaW1wb3J0YW50IHRoYXQgYXhpcyBpcyBub3JtYWxpc2VkIHRoZW4gcmVwbGFjZSB3aXRoIHg9MTsgeT16PTA7XG4gICAgICAgIHRhcmdldEF4aXMueSA9IHRoaXMueTtcbiAgICAgICAgdGFyZ2V0QXhpcy56ID0gdGhpcy56O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEF4aXMueCA9IHRoaXMueCAvIHM7IC8vIG5vcm1hbGlzZSBheGlzXG4gICAgICAgIHRhcmdldEF4aXMueSA9IHRoaXMueSAvIHM7XG4gICAgICAgIHRhcmdldEF4aXMueiA9IHRoaXMueiAvIHM7XG4gICAgfVxuICAgIHJldHVybiBbdGFyZ2V0QXhpcyxhbmdsZV07XG59O1xuXG52YXIgc2Z2X3QxID0gbmV3IFZlYzMoKSxcbiAgICBzZnZfdDIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFNldCB0aGUgcXVhdGVybmlvbiB2YWx1ZSBnaXZlbiB0d28gdmVjdG9ycy4gVGhlIHJlc3VsdGluZyByb3RhdGlvbiB3aWxsIGJlIHRoZSBuZWVkZWQgcm90YXRpb24gdG8gcm90YXRlIHUgdG8gdi5cbiAqIEBtZXRob2Qgc2V0RnJvbVZlY3RvcnNcbiAqIEBwYXJhbSB7VmVjM30gdVxuICogQHBhcmFtIHtWZWMzfSB2XG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnNldEZyb21WZWN0b3JzID0gZnVuY3Rpb24odSx2KXtcbiAgICBpZih1LmlzQW50aXBhcmFsbGVsVG8odikpe1xuICAgICAgICB2YXIgdDEgPSBzZnZfdDE7XG4gICAgICAgIHZhciB0MiA9IHNmdl90MjtcblxuICAgICAgICB1LnRhbmdlbnRzKHQxLHQyKTtcbiAgICAgICAgdGhpcy5zZXRGcm9tQXhpc0FuZ2xlKHQxLE1hdGguUEkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhID0gdS5jcm9zcyh2KTtcbiAgICAgICAgdGhpcy54ID0gYS54O1xuICAgICAgICB0aGlzLnkgPSBhLnk7XG4gICAgICAgIHRoaXMueiA9IGEuejtcbiAgICAgICAgdGhpcy53ID0gTWF0aC5zcXJ0KE1hdGgucG93KHUubm9ybSgpLDIpICogTWF0aC5wb3codi5ub3JtKCksMikpICsgdS5kb3Qodik7XG4gICAgICAgIHRoaXMubm9ybWFsaXplKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBRdWF0ZXJuaW9uIG11bHRpcGxpY2F0aW9uXG4gKiBAbWV0aG9kIG11bHRcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSB0YXJnZXQgT3B0aW9uYWwuXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufVxuICovXG52YXIgUXVhdGVybmlvbl9tdWx0X3ZhID0gbmV3IFZlYzMoKTtcbnZhciBRdWF0ZXJuaW9uX211bHRfdmIgPSBuZXcgVmVjMygpO1xudmFyIFF1YXRlcm5pb25fbXVsdF92YXh2YiA9IG5ldyBWZWMzKCk7XG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5tdWx0ID0gZnVuY3Rpb24ocSx0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgdmFyIGF4ID0gdGhpcy54LCBheSA9IHRoaXMueSwgYXogPSB0aGlzLnosIGF3ID0gdGhpcy53LFxuICAgICAgICBieCA9IHEueCwgYnkgPSBxLnksIGJ6ID0gcS56LCBidyA9IHEudztcblxuICAgIHRhcmdldC54ID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgICB0YXJnZXQueSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gICAgdGFyZ2V0LnogPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIHRhcmdldC53ID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaW52ZXJzZSBxdWF0ZXJuaW9uIHJvdGF0aW9uLlxuICogQG1ldGhvZCBpbnZlcnNlXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHRhcmdldFxuICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uKHRhcmdldCl7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZSh0YXJnZXQpO1xuICAgIHZhciBpbm9ybTIgPSAxLyh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xuICAgIHRhcmdldC54ICo9IGlub3JtMjtcbiAgICB0YXJnZXQueSAqPSBpbm9ybTI7XG4gICAgdGFyZ2V0LnogKj0gaW5vcm0yO1xuICAgIHRhcmdldC53ICo9IGlub3JtMjtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcXVhdGVybmlvbiBjb25qdWdhdGVcbiAqIEBtZXRob2QgY29uanVnYXRlXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHRhcmdldFxuICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIHRhcmdldC54ID0gLXRoaXMueDtcbiAgICB0YXJnZXQueSA9IC10aGlzLnk7XG4gICAgdGFyZ2V0LnogPSAtdGhpcy56O1xuICAgIHRhcmdldC53ID0gdGhpcy53O1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uLiBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIHF1YXRlcm5pb24uXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLncpO1xuICAgIGlmICggbCA9PT0gMCApIHtcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgdGhpcy56ID0gMDtcbiAgICAgICAgdGhpcy53ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsID0gMSAvIGw7XG4gICAgICAgIHRoaXMueCAqPSBsO1xuICAgICAgICB0aGlzLnkgKj0gbDtcbiAgICAgICAgdGhpcy56ICo9IGw7XG4gICAgICAgIHRoaXMudyAqPSBsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwcm94aW1hdGlvbiBvZiBxdWF0ZXJuaW9uIG5vcm1hbGl6YXRpb24uIFdvcmtzIGJlc3Qgd2hlbiBxdWF0IGlzIGFscmVhZHkgYWxtb3N0LW5vcm1hbGl6ZWQuXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZUZhc3RcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vZmFzdC1xdWF0ZXJuaW9uLW5vcm1hbGl6YXRpb25cbiAqIEBhdXRob3IgdW5waGFzZWQsIGh0dHBzOi8vZ2l0aHViLmNvbS91bnBoYXNlZFxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5ub3JtYWxpemVGYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmID0gKDMuMC0odGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMudykpLzIuMDtcbiAgICBpZiAoIGYgPT09IDAgKSB7XG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgIHRoaXMueiA9IDA7XG4gICAgICAgIHRoaXMudyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy54ICo9IGY7XG4gICAgICAgIHRoaXMueSAqPSBmO1xuICAgICAgICB0aGlzLnogKj0gZjtcbiAgICAgICAgdGhpcy53ICo9IGY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgcXVhdGVybmlvbiBieSBhIHZlY3RvclxuICogQG1ldGhvZCB2bXVsdFxuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUudm11bHQgPSBmdW5jdGlvbih2LHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG5cbiAgICB2YXIgeCA9IHYueCxcbiAgICAgICAgeSA9IHYueSxcbiAgICAgICAgeiA9IHYuejtcblxuICAgIHZhciBxeCA9IHRoaXMueCxcbiAgICAgICAgcXkgPSB0aGlzLnksXG4gICAgICAgIHF6ID0gdGhpcy56LFxuICAgICAgICBxdyA9IHRoaXMudztcblxuICAgIC8vIHEqdlxuICAgIHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgaXkgPSAgcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgIGl6ID0gIHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICB0YXJnZXQueCA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgdGFyZ2V0LnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIHRhcmdldC56ID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHNvdXJjZVxuICogQHJldHVybiB7UXVhdGVybmlvbn0gdGhpc1xuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oc291cmNlKXtcbiAgICB0aGlzLnggPSBzb3VyY2UueDtcbiAgICB0aGlzLnkgPSBzb3VyY2UueTtcbiAgICB0aGlzLnogPSBzb3VyY2UuejtcbiAgICB0aGlzLncgPSBzb3VyY2UudztcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgcXVhdGVybmlvbiB0byBldWxlciBhbmdsZSByZXByZXNlbnRhdGlvbi4gT3JkZXI6IFlaWCwgYXMgdGhpcyBwYWdlIGRlc2NyaWJlczogaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvc3RhbmRhcmRzL2luZGV4Lmh0bVxuICogQG1ldGhvZCB0b0V1bGVyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICogQHBhcmFtIHN0cmluZyBvcmRlciBUaHJlZS1jaGFyYWN0ZXIgc3RyaW5nIGUuZy4gXCJZWlhcIiwgd2hpY2ggYWxzbyBpcyBkZWZhdWx0LlxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS50b0V1bGVyID0gZnVuY3Rpb24odGFyZ2V0LG9yZGVyKXtcbiAgICBvcmRlciA9IG9yZGVyIHx8IFwiWVpYXCI7XG5cbiAgICB2YXIgaGVhZGluZywgYXR0aXR1ZGUsIGJhbms7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG5cbiAgICBzd2l0Y2gob3JkZXIpe1xuICAgIGNhc2UgXCJZWlhcIjpcbiAgICAgICAgdmFyIHRlc3QgPSB4KnkgKyB6Knc7XG4gICAgICAgIGlmICh0ZXN0ID4gMC40OTkpIHsgLy8gc2luZ3VsYXJpdHkgYXQgbm9ydGggcG9sZVxuICAgICAgICAgICAgaGVhZGluZyA9IDIgKiBNYXRoLmF0YW4yKHgsdyk7XG4gICAgICAgICAgICBhdHRpdHVkZSA9IE1hdGguUEkvMjtcbiAgICAgICAgICAgIGJhbmsgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXN0IDwgLTAuNDk5KSB7IC8vIHNpbmd1bGFyaXR5IGF0IHNvdXRoIHBvbGVcbiAgICAgICAgICAgIGhlYWRpbmcgPSAtMiAqIE1hdGguYXRhbjIoeCx3KTtcbiAgICAgICAgICAgIGF0dGl0dWRlID0gLSBNYXRoLlBJLzI7XG4gICAgICAgICAgICBiYW5rID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZihpc05hTihoZWFkaW5nKSl7XG4gICAgICAgICAgICB2YXIgc3F4ID0geCp4O1xuICAgICAgICAgICAgdmFyIHNxeSA9IHkqeTtcbiAgICAgICAgICAgIHZhciBzcXogPSB6Kno7XG4gICAgICAgICAgICBoZWFkaW5nID0gTWF0aC5hdGFuMigyKnkqdyAtIDIqeCp6ICwgMSAtIDIqc3F5IC0gMipzcXopOyAvLyBIZWFkaW5nXG4gICAgICAgICAgICBhdHRpdHVkZSA9IE1hdGguYXNpbigyKnRlc3QpOyAvLyBhdHRpdHVkZVxuICAgICAgICAgICAgYmFuayA9IE1hdGguYXRhbjIoMip4KncgLSAyKnkqeiAsIDEgLSAyKnNxeCAtIDIqc3F6KTsgLy8gYmFua1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV1bGVyIG9yZGVyIFwiK29yZGVyK1wiIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQueSA9IGhlYWRpbmc7XG4gICAgdGFyZ2V0LnogPSBhdHRpdHVkZTtcbiAgICB0YXJnZXQueCA9IGJhbms7XG59O1xuXG4vKipcbiAqIFNlZSBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvMjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvY29udGVudC9TcGluQ2FsYy5tXG4gKiBAbWV0aG9kIHNldEZyb21FdWxlclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gelxuICogQHBhcmFtIHtTdHJpbmd9IG9yZGVyIFRoZSBvcmRlciB0byBhcHBseSBhbmdsZXM6ICdYWVonIG9yICdZWFonIG9yIGFueSBvdGhlciBjb21iaW5hdGlvblxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zZXRGcm9tRXVsZXIgPSBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuICAgIG9yZGVyID0gb3JkZXIgfHwgXCJYWVpcIjtcblxuICAgIHZhciBjMSA9IE1hdGguY29zKCB4IC8gMiApO1xuICAgIHZhciBjMiA9IE1hdGguY29zKCB5IC8gMiApO1xuICAgIHZhciBjMyA9IE1hdGguY29zKCB6IC8gMiApO1xuICAgIHZhciBzMSA9IE1hdGguc2luKCB4IC8gMiApO1xuICAgIHZhciBzMiA9IE1hdGguc2luKCB5IC8gMiApO1xuICAgIHZhciBzMyA9IE1hdGguc2luKCB6IC8gMiApO1xuXG4gICAgaWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XG4gKlxuICogQG1ldGhvZCBzbGVycFxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSB0b1F1YXQgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHNlbGYgcXVhdGVybmlvbiBhbmQgdG9RdWF0XG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IFt0YXJnZXRdIEEgcXVhdGVybmlvbiB0byBzdG9yZSB0aGUgcmVzdWx0IGluLiBJZiBub3QgcHJvdmlkZWQsIGEgbmV3IG9uZSB3aWxsIGJlIGNyZWF0ZWQuXG4gKiBAcmV0dXJucyB7UXVhdGVybmlvbn0gVGhlIFwidGFyZ2V0XCIgb2JqZWN0XG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnNsZXJwID0gZnVuY3Rpb24gKHRvUXVhdCwgdCwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICB2YXIgYXggPSB0aGlzLngsXG4gICAgICAgIGF5ID0gdGhpcy55LFxuICAgICAgICBheiA9IHRoaXMueixcbiAgICAgICAgYXcgPSB0aGlzLncsXG4gICAgICAgIGJ4ID0gdG9RdWF0LngsXG4gICAgICAgIGJ5ID0gdG9RdWF0LnksXG4gICAgICAgIGJ6ID0gdG9RdWF0LnosXG4gICAgICAgIGJ3ID0gdG9RdWF0Lnc7XG5cbiAgICB2YXIgb21lZ2EsIGNvc29tLCBzaW5vbSwgc2NhbGUwLCBzY2FsZTE7XG5cbiAgICAvLyBjYWxjIGNvc2luZVxuICAgIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcblxuICAgIC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuICAgIGlmICggY29zb20gPCAwLjAgKSB7XG4gICAgICAgIGNvc29tID0gLWNvc29tO1xuICAgICAgICBieCA9IC0gYng7XG4gICAgICAgIGJ5ID0gLSBieTtcbiAgICAgICAgYnogPSAtIGJ6O1xuICAgICAgICBidyA9IC0gYnc7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuICAgIGlmICggKDEuMCAtIGNvc29tKSA+IDAuMDAwMDAxICkge1xuICAgICAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICAgICAgb21lZ2EgID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgICAgc2lub20gID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2VcbiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgICAgICBzY2FsZTEgPSB0O1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcbiAgICB0YXJnZXQueCA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gICAgdGFyZ2V0LnkgPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICAgIHRhcmdldC56ID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgICB0YXJnZXQudyA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYW4gYWJzb2x1dGUgb3JpZW50YXRpb24gcXVhdGVybmlvbiBnaXZlbiBhbiBhbmd1bGFyIHZlbG9jaXR5IGFuZCBhIHRpbWUgc3RlcC5cbiAqIEBwYXJhbSAge1ZlYzN9IGFuZ3VsYXJWZWxvY2l0eVxuICogQHBhcmFtICB7bnVtYmVyfSBkdFxuICogQHBhcmFtICB7VmVjM30gYW5ndWxhckZhY3RvclxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBUaGUgXCJ0YXJnZXRcIiBvYmplY3RcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuaW50ZWdyYXRlID0gZnVuY3Rpb24oYW5ndWxhclZlbG9jaXR5LCBkdCwgYW5ndWxhckZhY3RvciwgdGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIHZhciBheCA9IGFuZ3VsYXJWZWxvY2l0eS54ICogYW5ndWxhckZhY3Rvci54LFxuICAgICAgICBheSA9IGFuZ3VsYXJWZWxvY2l0eS55ICogYW5ndWxhckZhY3Rvci55LFxuICAgICAgICBheiA9IGFuZ3VsYXJWZWxvY2l0eS56ICogYW5ndWxhckZhY3Rvci56LFxuICAgICAgICBieCA9IHRoaXMueCxcbiAgICAgICAgYnkgPSB0aGlzLnksXG4gICAgICAgIGJ6ID0gdGhpcy56LFxuICAgICAgICBidyA9IHRoaXMudztcblxuICAgIHZhciBoYWxmX2R0ID0gZHQgKiAwLjU7XG5cbiAgICB0YXJnZXQueCArPSBoYWxmX2R0ICogKGF4ICogYncgKyBheSAqIGJ6IC0gYXogKiBieSk7XG4gICAgdGFyZ2V0LnkgKz0gaGFsZl9kdCAqIChheSAqIGJ3ICsgYXogKiBieCAtIGF4ICogYnopO1xuICAgIHRhcmdldC56ICs9IGhhbGZfZHQgKiAoYXogKiBidyArIGF4ICogYnkgLSBheSAqIGJ4KTtcbiAgICB0YXJnZXQudyArPSBoYWxmX2R0ICogKC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6KTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59OyIsInZhciBWZWMzID0gcmVxdWlyZSgnLi9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJy4vUXVhdGVybmlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxuLyoqXG4gKiBAY2xhc3MgVHJhbnNmb3JtXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHtWZWMzfSBwb3NpdGlvblxuXHQgKi9cblx0dGhpcy5wb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG4gICAgaWYob3B0aW9ucy5wb3NpdGlvbil7XG4gICAgICAgIHRoaXMucG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7UXVhdGVybmlvbn0gcXVhdGVybmlvblxuXHQgKi9cblx0dGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICBpZihvcHRpb25zLnF1YXRlcm5pb24pe1xuICAgICAgICB0aGlzLnF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pO1xuICAgIH1cbn1cblxudmFyIHRtcFF1YXQgPSBuZXcgUXVhdGVybmlvbigpO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgcG9pbnRUb0xvY2FGcmFtZVxuICogQHBhcmFtIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1ZlYzN9IHdvcmxkUG9pbnRcbiAqIEBwYXJhbSB7VmVjM30gcmVzdWx0XG4gKi9cblRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCB3b3JsZFBvaW50LCByZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICB3b3JsZFBvaW50LnZzdWIocG9zaXRpb24sIHJlc3VsdCk7XG4gICAgcXVhdGVybmlvbi5jb25qdWdhdGUodG1wUXVhdCk7XG4gICAgdG1wUXVhdC52bXVsdChyZXN1bHQsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IGEgZ2xvYmFsIHBvaW50IGluIGxvY2FsIHRyYW5zZm9ybSBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgcG9pbnRUb0xvY2FsXG4gKiBAcGFyYW0gIHtWZWMzfSBwb2ludFxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJyZXN1bHRcIiB2ZWN0b3Igb2JqZWN0XG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUucG9pbnRUb0xvY2FsID0gZnVuY3Rpb24od29ybGRQb2ludCwgcmVzdWx0KXtcbiAgICByZXR1cm4gVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgd29ybGRQb2ludCwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBwb2ludFRvV29ybGRGcmFtZVxuICogQHBhcmFtIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtIHtWZWMzfSBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1ZlYzN9IGxvY2FsUG9pbnRcbiAqIEBwYXJhbSB7VmVjM30gcmVzdWx0XG4gKi9cblRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBsb2NhbFBvaW50LCByZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICBxdWF0ZXJuaW9uLnZtdWx0KGxvY2FsUG9pbnQsIHJlc3VsdCk7XG4gICAgcmVzdWx0LnZhZGQocG9zaXRpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IGEgbG9jYWwgcG9pbnQgaW4gZ2xvYmFsIHRyYW5zZm9ybSBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgcG9pbnRUb1dvcmxkXG4gKiBAcGFyYW0gIHtWZWMzfSBwb2ludFxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJyZXN1bHRcIiB2ZWN0b3Igb2JqZWN0XG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUucG9pbnRUb1dvcmxkID0gZnVuY3Rpb24obG9jYWxQb2ludCwgcmVzdWx0KXtcbiAgICByZXR1cm4gVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgbG9jYWxQb2ludCwgcmVzdWx0KTtcbn07XG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS52ZWN0b3JUb1dvcmxkRnJhbWUgPSBmdW5jdGlvbihsb2NhbFZlY3RvciwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnZtdWx0KGxvY2FsVmVjdG9yLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5UcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24ocXVhdGVybmlvbiwgbG9jYWxWZWN0b3IsIHJlc3VsdCl7XG4gICAgcXVhdGVybmlvbi52bXVsdChsb2NhbFZlY3RvciwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuVHJhbnNmb3JtLnZlY3RvclRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCB3b3JsZFZlY3RvciwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgcXVhdGVybmlvbi53ICo9IC0xO1xuICAgIHF1YXRlcm5pb24udm11bHQod29ybGRWZWN0b3IsIHJlc3VsdCk7XG4gICAgcXVhdGVybmlvbi53ICo9IC0xO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBWZWMzO1xuXG52YXIgTWF0MyA9IHJlcXVpcmUoJy4vTWF0MycpO1xuXG4vKipcbiAqIDMtZGltZW5zaW9uYWwgdmVjdG9yXG4gKiBAY2xhc3MgVmVjM1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciB2ID0gbmV3IFZlYzMoMSwgMiwgMyk7XG4gKiAgICAgY29uc29sZS5sb2coJ3g9JyArIHYueCk7IC8vIHg9MVxuICovXG5mdW5jdGlvbiBWZWMzKHgseSx6KXtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgeFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy54ID0geHx8MC4wO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHlcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMueSA9IHl8fDAuMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB6XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnogPSB6fHwwLjA7XG59XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtWZWMzfSBaRVJPXG4gKi9cblZlYzMuWkVSTyA9IG5ldyBWZWMzKDAsIDAsIDApO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7VmVjM30gVU5JVF9YXG4gKi9cblZlYzMuVU5JVF9YID0gbmV3IFZlYzMoMSwgMCwgMCk7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtWZWMzfSBVTklUX1lcbiAqL1xuVmVjMy5VTklUX1kgPSBuZXcgVmVjMygwLCAxLCAwKTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge1ZlYzN9IFVOSVRfWlxuICovXG5WZWMzLlVOSVRfWiA9IG5ldyBWZWMzKDAsIDAsIDEpO1xuXG4vKipcbiAqIFZlY3RvciBjcm9zcyBwcm9kdWN0XG4gKiBAbWV0aG9kIGNyb3NzXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdG8gc2F2ZSBpbi5cbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24odix0YXJnZXQpe1xuICAgIHZhciB2eD12LngsIHZ5PXYueSwgdno9di56LCB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuXG4gICAgdGFyZ2V0LnggPSAoeSAqIHZ6KSAtICh6ICogdnkpO1xuICAgIHRhcmdldC55ID0gKHogKiB2eCkgLSAoeCAqIHZ6KTtcbiAgICB0YXJnZXQueiA9ICh4ICogdnkpIC0gKHkgKiB2eCk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHZlY3RvcnMnIDMgZWxlbWVudHNcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKiBAcmV0dXJuIFZlYzNcbiAqL1xuVmVjMy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeCx5LHope1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgYWxsIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciB0byB6ZXJvLlxuICogQG1ldGhvZCBzZXRaZXJvXG4gKi9cblZlYzMucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbigpe1xuICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMueiA9IDA7XG59O1xuXG4vKipcbiAqIFZlY3RvciBhZGRpdGlvblxuICogQG1ldGhvZCB2YWRkXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLlxuICogQHJldHVybiB7VmVjM31cbiAqL1xuVmVjMy5wcm90b3R5cGUudmFkZCA9IGZ1bmN0aW9uKHYsdGFyZ2V0KXtcbiAgICBpZih0YXJnZXQpe1xuICAgICAgICB0YXJnZXQueCA9IHYueCArIHRoaXMueDtcbiAgICAgICAgdGFyZ2V0LnkgPSB2LnkgKyB0aGlzLnk7XG4gICAgICAgIHRhcmdldC56ID0gdi56ICsgdGhpcy56O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggKyB2LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ICsgdi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueiArIHYueik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBWZWN0b3Igc3VidHJhY3Rpb25cbiAqIEBtZXRob2QgdnN1YlxuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbC4gVGFyZ2V0IHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzLnByb3RvdHlwZS52c3ViID0gZnVuY3Rpb24odix0YXJnZXQpe1xuICAgIGlmKHRhcmdldCl7XG4gICAgICAgIHRhcmdldC54ID0gdGhpcy54IC0gdi54O1xuICAgICAgICB0YXJnZXQueSA9IHRoaXMueSAtIHYueTtcbiAgICAgICAgdGFyZ2V0LnogPSB0aGlzLnogLSB2Lno7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueC12LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55LXYueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnotdi56KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3Jvc3MgcHJvZHVjdCBtYXRyaXggYV9jcm9zcyBmcm9tIGEgdmVjdG9yLCBzdWNoIHRoYXQgYSB4IGIgPSBhX2Nyb3NzICogYiA9IGNcbiAqIEBtZXRob2QgY3Jvc3NtYXRcbiAqIEBzZWUgaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci9UREJEMjQvVlQwNi9sZWN0dXJlcy9MZWN0dXJlNi5wZGZcbiAqIEByZXR1cm4ge01hdDN9XG4gKi9cblZlYzMucHJvdG90eXBlLmNyb3NzbWF0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IE1hdDMoWyAgICAgMCwgIC10aGlzLnosICAgdGhpcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueiwgICAgICAgIDAsICAtdGhpcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLXRoaXMueSwgICB0aGlzLngsICAgICAgICAwXSk7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgdmVjdG9yLiBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIHRoZSB2YWx1ZXMgaW4gdGhlIHZlY3Rvci5cbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIG5vcm0gb2YgdGhlIHZlY3RvclxuICovXG5WZWMzLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbigpe1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHZhciBuID0gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG4gICAgaWYobj4wLjApe1xuICAgICAgICB2YXIgaW52TiA9IDEvbjtcbiAgICAgICAgdGhpcy54ICo9IGludk47XG4gICAgICAgIHRoaXMueSAqPSBpbnZOO1xuICAgICAgICB0aGlzLnogKj0gaW52TjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNYWtlIHNvbWV0aGluZyB1cFxuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICB0aGlzLnogPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2ZXJzaW9uIG9mIHRoaXMgdmVjdG9yIHRoYXQgaXMgb2YgbGVuZ3RoIDEuXG4gKiBAbWV0aG9kIHVuaXRcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsIHRhcmdldCB0byBzYXZlIGluXG4gKiBAcmV0dXJuIHtWZWMzfSBSZXR1cm5zIHRoZSB1bml0IHZlY3RvclxuICovXG5WZWMzLnByb3RvdHlwZS51bml0ID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcbiAgICB2YXIgeD10aGlzLngsIHk9dGhpcy55LCB6PXRoaXMuejtcbiAgICB2YXIgbmludiA9IE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xuICAgIGlmKG5pbnY+MC4wKXtcbiAgICAgICAgbmludiA9IDEuMC9uaW52O1xuICAgICAgICB0YXJnZXQueCA9IHggKiBuaW52O1xuICAgICAgICB0YXJnZXQueSA9IHkgKiBuaW52O1xuICAgICAgICB0YXJnZXQueiA9IHogKiBuaW52O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC54ID0gMTtcbiAgICAgICAgdGFyZ2V0LnkgPSAwO1xuICAgICAgICB0YXJnZXQueiA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcbiAqIEBtZXRob2Qgbm9ybVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGRlcHJlY2F0ZWQgVXNlIC5sZW5ndGgoKSBpbnN0ZWFkXG4gKi9cblZlYzMucHJvdG90eXBlLm5vcm0gPSBmdW5jdGlvbigpe1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxuICogQG1ldGhvZCBsZW5ndGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVmVjMy5wcm90b3R5cGUubGVuZ3RoID0gVmVjMy5wcm90b3R5cGUubm9ybTtcblxuLyoqXG4gKiBHZXQgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcbiAqIEBtZXRob2Qgbm9ybTJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBkZXByZWNhdGVkIFVzZSAubGVuZ3RoU3F1YXJlZCgpIGluc3RlYWQuXG4gKi9cblZlYzMucHJvdG90eXBlLm5vcm0yID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5kb3QodGhpcyk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3F1YXJlZCBsZW5ndGggb2YgdGhlIHZlY3Rvci5cbiAqIEBtZXRob2QgbGVuZ3RoU3F1YXJlZFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5WZWMzLnByb3RvdHlwZS5sZW5ndGhTcXVhcmVkID0gVmVjMy5wcm90b3R5cGUubm9ybTI7XG5cbi8qKlxuICogR2V0IGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50XG4gKiBAbWV0aG9kIGRpc3RhbmNlVG9cbiAqIEBwYXJhbSAge1ZlYzN9IHBcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVmVjMy5wcm90b3R5cGUuZGlzdGFuY2VUbyA9IGZ1bmN0aW9uKHApe1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHZhciBweD1wLngsIHB5PXAueSwgcHo9cC56O1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHB4LXgpKihweC14KStcbiAgICAgICAgICAgICAgICAgICAgIChweS15KSoocHkteSkrXG4gICAgICAgICAgICAgICAgICAgICAocHoteikqKHB6LXopKTtcbn07XG5cbi8qKlxuICogR2V0IHNxdWFyZWQgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIGFub3RoZXIgcG9pbnRcbiAqIEBtZXRob2QgZGlzdGFuY2VTcXVhcmVkXG4gKiBAcGFyYW0gIHtWZWMzfSBwXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblZlYzMucHJvdG90eXBlLmRpc3RhbmNlU3F1YXJlZCA9IGZ1bmN0aW9uKHApe1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHZhciBweD1wLngsIHB5PXAueSwgcHo9cC56O1xuICAgIHJldHVybiAocHgteCkqKHB4LXgpICsgKHB5LXkpKihweS15KSArIChwei16KSoocHoteik7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGFsbCB0aGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yIHdpdGggYSBzY2FsYXIuXG4gKiBAZGVwcmVjYXRlZCBVc2UgLnNjYWxlIGluc3RlYWRcbiAqIEBtZXRob2QgbXVsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgVGhlIHZlY3RvciB0byBzYXZlIHRoZSByZXN1bHQgaW4uXG4gKiBAcmV0dXJuIHtWZWMzfVxuICogQGRlcHJlY2F0ZWQgVXNlIC5zY2FsZSgpIGluc3RlYWRcbiAqL1xuVmVjMy5wcm90b3R5cGUubXVsdCA9IGZ1bmN0aW9uKHNjYWxhcix0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICB5ID0gdGhpcy55LFxuICAgICAgICB6ID0gdGhpcy56O1xuICAgIHRhcmdldC54ID0gc2NhbGFyICogeDtcbiAgICB0YXJnZXQueSA9IHNjYWxhciAqIHk7XG4gICAgdGFyZ2V0LnogPSBzY2FsYXIgKiB6O1xuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoZSB2ZWN0b3Igd2l0aCBhbiBvdGhlciB2ZWN0b3IsIGNvbXBvbmVudC13aXNlLlxuICogQG1ldGhvZCBtdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gdmVjdG9yXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBUaGUgdmVjdG9yIHRvIHNhdmUgdGhlIHJlc3VsdCBpbi5cbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMucHJvdG90eXBlLnZtdWwgPSBmdW5jdGlvbih2ZWN0b3IsIHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGFyZ2V0LnggPSB2ZWN0b3IueCAqIHRoaXMueDtcbiAgICB0YXJnZXQueSA9IHZlY3Rvci55ICogdGhpcy55O1xuICAgIHRhcmdldC56ID0gdmVjdG9yLnogKiB0aGlzLno7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgdGhlIHZlY3RvciB3aXRoIGEgc2NhbGFyLlxuICogQG1ldGhvZCBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMucHJvdG90eXBlLnNjYWxlID0gVmVjMy5wcm90b3R5cGUubXVsdDtcblxuLyoqXG4gKiBTY2FsZSBhIHZlY3RvciBhbmQgYWRkIGl0IHRvIHRoaXMgdmVjdG9yLiBTYXZlIHRoZSByZXN1bHQgaW4gXCJ0YXJnZXRcIi4gKHRhcmdldCA9IHRoaXMgKyB2ZWN0b3IgKiBzY2FsYXIpXG4gKiBAbWV0aG9kIGFkZFNjYWxlZFZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICogQHBhcmFtIHtWZWMzfSB2ZWN0b3JcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IFRoZSB2ZWN0b3IgdG8gc2F2ZSB0aGUgcmVzdWx0IGluLlxuICogQHJldHVybiB7VmVjM31cbiAqL1xuVmVjMy5wcm90b3R5cGUuYWRkU2NhbGVkVmVjdG9yID0gZnVuY3Rpb24oc2NhbGFyLCB2ZWN0b3IsIHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGFyZ2V0LnggPSB0aGlzLnggKyBzY2FsYXIgKiB2ZWN0b3IueDtcbiAgICB0YXJnZXQueSA9IHRoaXMueSArIHNjYWxhciAqIHZlY3Rvci55O1xuICAgIHRhcmdldC56ID0gdGhpcy56ICsgc2NhbGFyICogdmVjdG9yLno7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRvdCBwcm9kdWN0XG4gKiBAbWV0aG9kIGRvdFxuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblZlYzMucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKHYpe1xuICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgaXNaZXJvXG4gKiBAcmV0dXJuIGJvb2xcbiAqL1xuVmVjMy5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy54PT09MCAmJiB0aGlzLnk9PT0wICYmIHRoaXMuej09PTA7XG59O1xuXG4vKipcbiAqIE1ha2UgdGhlIHZlY3RvciBwb2ludCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLlxuICogQG1ldGhvZCBuZWdhdGVcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsIHRhcmdldCB0byBzYXZlIGluXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbih0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHRhcmdldC54ID0gLXRoaXMueDtcbiAgICB0YXJnZXQueSA9IC10aGlzLnk7XG4gICAgdGFyZ2V0LnogPSAtdGhpcy56O1xuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdHdvIGFydGlmaWNpYWwgdGFuZ2VudHMgdG8gdGhlIHZlY3RvclxuICogQG1ldGhvZCB0YW5nZW50c1xuICogQHBhcmFtIHtWZWMzfSB0MSBWZWN0b3Igb2JqZWN0IHRvIHNhdmUgdGhlIGZpcnN0IHRhbmdlbnQgaW5cbiAqIEBwYXJhbSB7VmVjM30gdDIgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBzZWNvbmQgdGFuZ2VudCBpblxuICovXG52YXIgVmVjM190YW5nZW50c19uID0gbmV3IFZlYzMoKTtcbnZhciBWZWMzX3RhbmdlbnRzX3JhbmRWZWMgPSBuZXcgVmVjMygpO1xuVmVjMy5wcm90b3R5cGUudGFuZ2VudHMgPSBmdW5jdGlvbih0MSx0Mil7XG4gICAgdmFyIG5vcm0gPSB0aGlzLm5vcm0oKTtcbiAgICBpZihub3JtPjAuMCl7XG4gICAgICAgIHZhciBuID0gVmVjM190YW5nZW50c19uO1xuICAgICAgICB2YXIgaW5vcm0gPSAxL25vcm07XG4gICAgICAgIG4uc2V0KHRoaXMueCppbm9ybSx0aGlzLnkqaW5vcm0sdGhpcy56Kmlub3JtKTtcbiAgICAgICAgdmFyIHJhbmRWZWMgPSBWZWMzX3RhbmdlbnRzX3JhbmRWZWM7XG4gICAgICAgIGlmKE1hdGguYWJzKG4ueCkgPCAwLjkpe1xuICAgICAgICAgICAgcmFuZFZlYy5zZXQoMSwwLDApO1xuICAgICAgICAgICAgbi5jcm9zcyhyYW5kVmVjLHQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmRWZWMuc2V0KDAsMSwwKTtcbiAgICAgICAgICAgIG4uY3Jvc3MocmFuZFZlYyx0MSk7XG4gICAgICAgIH1cbiAgICAgICAgbi5jcm9zcyh0MSx0Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIG5vcm1hbCBsZW5ndGggaXMgemVybywgbWFrZSBzb21ldGhpbmcgdXBcbiAgICAgICAgdDEuc2V0KDEsIDAsIDApO1xuICAgICAgICB0Mi5zZXQoMCwgMSwgMCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIG1vcmUgcmVhZGFibGUgZm9ybWF0XG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAcmV0dXJuIHN0cmluZ1xuICovXG5WZWMzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMueCtcIixcIit0aGlzLnkrXCIsXCIrdGhpcy56O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhbiBhcnJheVxuICogQG1ldGhvZCB0b0FycmF5XG4gKiBAcmV0dXJuIEFycmF5XG4gKi9cblZlYzMucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07XG59O1xuXG4vKipcbiAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyB2ZWN0b3IuXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7VmVjM30gc291cmNlXG4gKiBAcmV0dXJuIHtWZWMzfSB0aGlzXG4gKi9cblZlYzMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihzb3VyY2Upe1xuICAgIHRoaXMueCA9IHNvdXJjZS54O1xuICAgIHRoaXMueSA9IHNvdXJjZS55O1xuICAgIHRoaXMueiA9IHNvdXJjZS56O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIERvIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjdG9yc1xuICogQG1ldGhvZCBsZXJwXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS4gMCB3aWxsIG1ha2UgdGhpcyBmdW5jdGlvbiByZXR1cm4gdSwgYW5kIDEgd2lsbCBtYWtlIGl0IHJldHVybiB2LiBOdW1iZXJzIGluIGJldHdlZW4gd2lsbCBnZW5lcmF0ZSBhIHZlY3RvciBpbiBiZXR3ZWVuIHRoZW0uXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICovXG5WZWMzLnByb3RvdHlwZS5sZXJwID0gZnVuY3Rpb24odix0LHRhcmdldCl7XG4gICAgdmFyIHg9dGhpcy54LCB5PXRoaXMueSwgej10aGlzLno7XG4gICAgdGFyZ2V0LnggPSB4ICsgKHYueC14KSp0O1xuICAgIHRhcmdldC55ID0geSArICh2LnkteSkqdDtcbiAgICB0YXJnZXQueiA9IHogKyAodi56LXopKnQ7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdmVjdG9yIGVxdWFscyBpcyBhbG1vc3QgZXF1YWwgdG8gYW5vdGhlciBvbmUuXG4gKiBAbWV0aG9kIGFsbW9zdEVxdWFsc1xuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uXG4gKiBAcmV0dXJuIGJvb2xcbiAqL1xuVmVjMy5wcm90b3R5cGUuYWxtb3N0RXF1YWxzID0gZnVuY3Rpb24odixwcmVjaXNpb24pe1xuICAgIGlmKHByZWNpc2lvbj09PXVuZGVmaW5lZCl7XG4gICAgICAgIHByZWNpc2lvbiA9IDFlLTY7XG4gICAgfVxuICAgIGlmKCBNYXRoLmFicyh0aGlzLngtdi54KT5wcmVjaXNpb24gfHxcbiAgICAgICAgTWF0aC5hYnModGhpcy55LXYueSk+cHJlY2lzaW9uIHx8XG4gICAgICAgIE1hdGguYWJzKHRoaXMuei12LnopPnByZWNpc2lvbil7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdmVjdG9yIGlzIGFsbW9zdCB6ZXJvXG4gKiBAbWV0aG9kIGFsbW9zdFplcm9cbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmVjaXNpb25cbiAqL1xuVmVjMy5wcm90b3R5cGUuYWxtb3N0WmVybyA9IGZ1bmN0aW9uKHByZWNpc2lvbil7XG4gICAgaWYocHJlY2lzaW9uPT09dW5kZWZpbmVkKXtcbiAgICAgICAgcHJlY2lzaW9uID0gMWUtNjtcbiAgICB9XG4gICAgaWYoIE1hdGguYWJzKHRoaXMueCk+cHJlY2lzaW9uIHx8XG4gICAgICAgIE1hdGguYWJzKHRoaXMueSk+cHJlY2lzaW9uIHx8XG4gICAgICAgIE1hdGguYWJzKHRoaXMueik+cHJlY2lzaW9uKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBhbnRpcF9uZWcgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2ZWN0b3IgaXMgYW50aS1wYXJhbGxlbCB0byBhbm90aGVyIHZlY3Rvci5cbiAqIEBtZXRob2QgaXNBbnRpcGFyYWxsZWxUb1xuICogQHBhcmFtICB7VmVjM30gIHZcbiAqIEBwYXJhbSAge051bWJlcn0gIHByZWNpc2lvbiBTZXQgdG8gemVybyBmb3IgZXhhY3QgY29tcGFyaXNvbnNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblZlYzMucHJvdG90eXBlLmlzQW50aXBhcmFsbGVsVG8gPSBmdW5jdGlvbih2LHByZWNpc2lvbil7XG4gICAgdGhpcy5uZWdhdGUoYW50aXBfbmVnKTtcbiAgICByZXR1cm4gYW50aXBfbmVnLmFsbW9zdEVxdWFscyh2LHByZWNpc2lvbik7XG59O1xuXG4vKipcbiAqIENsb25lIHRoZSB2ZWN0b3JcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFZlYzModGhpcy54LCB0aGlzLnksIHRoaXMueik7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gQm9keTtcblxudmFyIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi4vdXRpbHMvRXZlbnRUYXJnZXQnKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9TaGFwZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBNYXQzID0gcmVxdWlyZSgnLi4vbWF0aC9NYXQzJyk7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIE1hdGVyaWFsID0gcmVxdWlyZSgnLi4vbWF0ZXJpYWwvTWF0ZXJpYWwnKTtcbnZhciBBQUJCID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL0FBQkInKTtcbnZhciBCb3ggPSByZXF1aXJlKCcuLi9zaGFwZXMvQm94Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGJvZHkgdHlwZXMuXG4gKiBAY2xhc3MgQm9keVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5wb3NpdGlvbl1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMudmVsb2NpdHldXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmFuZ3VsYXJWZWxvY2l0eV1cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gW29wdGlvbnMucXVhdGVybmlvbl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXNzXVxuICogQHBhcmFtIHtNYXRlcmlhbH0gW29wdGlvbnMubWF0ZXJpYWxdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHlwZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW5lYXJEYW1waW5nPTAuMDFdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYW5ndWxhckRhbXBpbmc9MC4wMV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWxsb3dTbGVlcD10cnVlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNsZWVwU3BlZWRMaW1pdD0wLjFdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2xlZXBUaW1lTGltaXQ9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cD0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9LTFdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZpeGVkUm90YXRpb249ZmFsc2VdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmxpbmVhckZhY3Rvcl1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYW5ndWxhckZhY3Rvcl1cbiAqIEBwYXJhbSB7U2hhcGV9IFtvcHRpb25zLnNoYXBlXVxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHtcbiAqICAgICAgICAgbWFzczogMVxuICogICAgIH0pO1xuICogICAgIHZhciBzaGFwZSA9IG5ldyBTcGhlcmUoMSk7XG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcbiAqL1xuZnVuY3Rpb24gQm9keShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIEV2ZW50VGFyZ2V0LmFwcGx5KHRoaXMpO1xuXG4gICAgdGhpcy5pZCA9IEJvZHkuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHdvcmxkIHRoZSBib2R5IGlzIGxpdmluZyBpblxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxuICAgICAqIEB0eXBlIHtXb3JsZH1cbiAgICAgKi9cbiAgICB0aGlzLndvcmxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCBCRUZPUkUgc3RlcHBpbmcgdGhlIHN5c3RlbS4gVXNlIGl0IHRvIGFwcGx5IGZvcmNlcywgZm9yIGV4YW1wbGUuIEluc2lkZSB0aGUgZnVuY3Rpb24sIFwidGhpc1wiIHdpbGwgcmVmZXIgdG8gdGhpcyBCb2R5IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkgcHJlU3RlcFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgV29ybGQgZXZlbnRzIGluc3RlYWRcbiAgICAgKi9cbiAgICB0aGlzLnByZVN0ZXAgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIEFGVEVSIHN0ZXBwaW5nIHRoZSBzeXN0ZW0uIEluc2lkZSB0aGUgZnVuY3Rpb24sIFwidGhpc1wiIHdpbGwgcmVmZXIgdG8gdGhpcyBCb2R5IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkgcG9zdFN0ZXBcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFdvcmxkIGV2ZW50cyBpbnN0ZWFkXG4gICAgICovXG4gICAgdGhpcy5wb3N0U3RlcCA9IG51bGw7XG5cbiAgICB0aGlzLnZsYW1iZGEgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbGxpc2lvbkZpbHRlckdyb3VwXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwKSA9PT0gJ251bWJlcicgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJNYXNrXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gdHlwZW9mKG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09ICdudW1iZXInID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrIDogLTE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG5cdHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV29ybGQgc3BhY2UgcG9zaXRpb24gb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHByZXZpb3VzUG9zaXRpb25cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24gPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJwb2xhdGVkIHBvc2l0aW9uIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaW50ZXJwb2xhdGVkUG9zaXRpb25cbiAgICAgKi9cbiAgICB0aGlzLmludGVycG9sYXRlZFBvc2l0aW9uID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWwgcG9zaXRpb24gb2YgdGhlIGJvZHlcbiAgICAgKiBAcHJvcGVydHkgaW5pdFBvc2l0aW9uXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5pbml0UG9zaXRpb24gPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy5wb3NpdGlvbil7XG4gICAgICAgIHRoaXMucG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1Bvc2l0aW9uLmNvcHkob3B0aW9ucy5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5pbml0UG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZCBzcGFjZSB2ZWxvY2l0eSBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgdmVsb2NpdHlcbiAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgKi9cbiAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IFZlYzMoKTtcblxuICAgIGlmKG9wdGlvbnMudmVsb2NpdHkpe1xuICAgICAgICB0aGlzLnZlbG9jaXR5LmNvcHkob3B0aW9ucy52ZWxvY2l0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluaXRWZWxvY2l0eVxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMuaW5pdFZlbG9jaXR5ID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIExpbmVhciBmb3JjZSBvbiB0aGUgYm9keSBpbiB3b3JsZCBzcGFjZS5cbiAgICAgKiBAcHJvcGVydHkgZm9yY2VcbiAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgKi9cbiAgICB0aGlzLmZvcmNlID0gbmV3IFZlYzMoKTtcblxuICAgIHZhciBtYXNzID0gdHlwZW9mKG9wdGlvbnMubWFzcykgPT09ICdudW1iZXInID8gb3B0aW9ucy5tYXNzIDogMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBtYXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5tYXNzID0gbWFzcztcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbnZNYXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludk1hc3MgPSBtYXNzID4gMCA/IDEuMCAvIG1hc3MgOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG1hdGVyaWFsXG4gICAgICogQHR5cGUge01hdGVyaWFsfVxuICAgICAqL1xuICAgIHRoaXMubWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbGluZWFyRGFtcGluZ1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5saW5lYXJEYW1waW5nID0gdHlwZW9mKG9wdGlvbnMubGluZWFyRGFtcGluZykgPT09ICdudW1iZXInID8gb3B0aW9ucy5saW5lYXJEYW1waW5nIDogMC4wMTtcblxuICAgIC8qKlxuICAgICAqIE9uZSBvZjogQm9keS5EWU5BTUlDLCBCb2R5LlNUQVRJQyBhbmQgQm9keS5LSU5FTUFUSUMuXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IChtYXNzIDw9IDAuMCA/IEJvZHkuU1RBVElDIDogQm9keS5EWU5BTUlDKTtcbiAgICBpZih0eXBlb2Yob3B0aW9ucy50eXBlKSA9PT0gdHlwZW9mKEJvZHkuU1RBVElDKSl7XG4gICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYm9keSB3aWxsIGF1dG9tYXRpY2FsbHkgZmFsbCB0byBzbGVlcC5cbiAgICAgKiBAcHJvcGVydHkgYWxsb3dTbGVlcFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmFsbG93U2xlZXAgPSB0eXBlb2Yob3B0aW9ucy5hbGxvd1NsZWVwKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFsbG93U2xlZXAgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzbGVlcCBzdGF0ZS5cbiAgICAgKiBAcHJvcGVydHkgc2xlZXBTdGF0ZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zbGVlcFN0YXRlID0gMDtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzcGVlZCAodGhlIG5vcm0gb2YgdGhlIHZlbG9jaXR5KSBpcyBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGJvZHkgaXMgY29uc2lkZXJlZCBzbGVlcHkuXG4gICAgICogQHByb3BlcnR5IHNsZWVwU3BlZWRMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4xXG4gICAgICovXG4gICAgdGhpcy5zbGVlcFNwZWVkTGltaXQgPSB0eXBlb2Yob3B0aW9ucy5zbGVlcFNwZWVkTGltaXQpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuc2xlZXBTcGVlZExpbWl0IDogMC4xO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGJvZHkgaGFzIGJlZW4gc2xlZXB5IGZvciB0aGlzIHNsZWVwVGltZUxpbWl0IHNlY29uZHMsIGl0IGlzIGNvbnNpZGVyZWQgc2xlZXBpbmcuXG4gICAgICogQHByb3BlcnR5IHNsZWVwVGltZUxpbWl0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5zbGVlcFRpbWVMaW1pdCA9IHR5cGVvZihvcHRpb25zLnNsZWVwVGltZUxpbWl0KSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnNsZWVwVGltZUxpbWl0IDogMTtcblxuICAgIHRoaXMudGltZUxhc3RTbGVlcHkgPSAwO1xuXG4gICAgdGhpcy5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV29ybGQgc3BhY2Ugcm90YXRpb25hbCBmb3JjZSBvbiB0aGUgYm9keSwgYXJvdW5kIGNlbnRlciBvZiBtYXNzLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gdG9ycXVlXG4gICAgICovXG4gICAgdGhpcy50b3JxdWUgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogV29ybGQgc3BhY2Ugb3JpZW50YXRpb24gb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IHF1YXRlcm5pb25cbiAgICAgKiBAdHlwZSB7UXVhdGVybmlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluaXRRdWF0ZXJuaW9uXG4gICAgICogQHR5cGUge1F1YXRlcm5pb259XG4gICAgICovXG4gICAgdGhpcy5pbml0UXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1F1YXRlcm5pb259IHByZXZpb3VzUXVhdGVybmlvblxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIC8qKlxuICAgICAqIEludGVycG9sYXRlZCBvcmllbnRhdGlvbiBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkge1F1YXRlcm5pb259IGludGVycG9sYXRlZFF1YXRlcm5pb25cbiAgICAgKi9cbiAgICB0aGlzLmludGVycG9sYXRlZFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgaWYob3B0aW9ucy5xdWF0ZXJuaW9uKXtcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkob3B0aW9ucy5xdWF0ZXJuaW9uKTtcbiAgICAgICAgdGhpcy5pbml0UXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XG4gICAgICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uLmNvcHkob3B0aW9ucy5xdWF0ZXJuaW9uKTtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uLmNvcHkob3B0aW9ucy5xdWF0ZXJuaW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSBib2R5LCBpbiB3b3JsZCBzcGFjZS4gVGhpbmsgb2YgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgYXMgYSB2ZWN0b3IsIHdoaWNoIHRoZSBib2R5IHJvdGF0ZXMgYXJvdW5kLiBUaGUgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yIGRldGVybWluZXMgaG93IGZhc3QgKGluIHJhZGlhbnMgcGVyIHNlY29uZCkgdGhlIGJvZHkgcm90YXRlcy5cbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclZlbG9jaXR5XG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy5hbmd1bGFyVmVsb2NpdHkpe1xuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5pdEFuZ3VsYXJWZWxvY2l0eVxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMuaW5pdEFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgc2hhcGVzXG4gICAgICogQHR5cGUge2FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiBvZiBlYWNoIFNoYXBlIGluIHRoZSBib2R5LCBnaXZlbiBpbiBsb2NhbCBCb2R5IHNwYWNlLlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZU9mZnNldHNcbiAgICAgKiBAdHlwZSB7YXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zaGFwZU9mZnNldHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIE9yaWVudGF0aW9uIG9mIGVhY2ggU2hhcGUsIGdpdmVuIGluIGxvY2FsIEJvZHkgc3BhY2UuXG4gICAgICogQHByb3BlcnR5IHNoYXBlT3JpZW50YXRpb25zXG4gICAgICogQHR5cGUge2FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVPcmllbnRhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbmVydGlhXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5pbmVydGlhID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaW52SW5lcnRpYVxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYSA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge01hdDN9IGludkluZXJ0aWFXb3JsZFxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkID0gbmV3IE1hdDMoKTtcblxuICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaW52SW5lcnRpYVNvbHZlXG4gICAgICovXG4gICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtNYXQzfSBpbnZJbmVydGlhV29ybGRTb2x2ZVxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUgPSBuZXcgTWF0MygpO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IGRvbid0IHdhbnQgdGhlIGJvZHkgdG8gcm90YXRlLiBNYWtlIHN1cmUgdG8gcnVuIC51cGRhdGVNYXNzUHJvcGVydGllcygpIGFmdGVyIGNoYW5naW5nIHRoaXMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmaXhlZFJvdGF0aW9uXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB0aGlzLmZpeGVkUm90YXRpb24gPSB0eXBlb2Yob3B0aW9ucy5maXhlZFJvdGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMuZml4ZWRSb3RhdGlvbiA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGFuZ3VsYXJEYW1waW5nXG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmFuZ3VsYXJEYW1waW5nKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ3VsYXJEYW1waW5nIDogMC4wMTtcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHByb3BlcnR5IHRvIGxpbWl0IHRoZSBtb3Rpb24gYWxvbmcgYW55IHdvcmxkIGF4aXMuICgxLDEsMSkgd2lsbCBhbGxvdyBtb3Rpb24gYWxvbmcgYWxsIGF4ZXMgd2hpbGUgKDAsMCwwKSBhbGxvd3Mgbm9uZS5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGxpbmVhckZhY3RvclxuICAgICAqL1xuICAgIHRoaXMubGluZWFyRmFjdG9yID0gbmV3IFZlYzMoMSwxLDEpO1xuICAgIGlmKG9wdGlvbnMubGluZWFyRmFjdG9yKXtcbiAgICAgICAgdGhpcy5saW5lYXJGYWN0b3IuY29weShvcHRpb25zLmxpbmVhckZhY3Rvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcHJvcGVydHkgdG8gbGltaXQgdGhlIHJvdGF0aW9uYWwgbW90aW9uIGFsb25nIGFueSB3b3JsZCBheGlzLiAoMSwxLDEpIHdpbGwgYWxsb3cgcm90YXRpb24gYWxvbmcgYWxsIGF4ZXMgd2hpbGUgKDAsMCwwKSBhbGxvd3Mgbm9uZS5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGFuZ3VsYXJGYWN0b3JcbiAgICAgKi9cbiAgICB0aGlzLmFuZ3VsYXJGYWN0b3IgPSBuZXcgVmVjMygxLDEsMSk7XG4gICAgaWYob3B0aW9ucy5hbmd1bGFyRmFjdG9yKXtcbiAgICAgICAgdGhpcy5hbmd1bGFyRmFjdG9yLmNvcHkob3B0aW9ucy5hbmd1bGFyRmFjdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZCBzcGFjZSBib3VuZGluZyBib3ggb2YgdGhlIGJvZHkgYW5kIGl0cyBzaGFwZXMuXG4gICAgICogQHByb3BlcnR5IGFhYmJcbiAgICAgKiBAdHlwZSB7QUFCQn1cbiAgICAgKi9cbiAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBBQUJCIG5lZWRzIHRvIGJlIHVwZGF0ZWQgYmVmb3JlIHVzZS5cbiAgICAgKiBAcHJvcGVydHkgYWFiYk5lZWRzVXBkYXRlXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVG90YWwgYm91bmRpbmcgcmFkaXVzIG9mIHRoZSBCb2R5IGluY2x1ZGluZyBpdHMgc2hhcGVzLCByZWxhdGl2ZSB0byBib2R5LnBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG5cbiAgICB0aGlzLndsYW1iZGEgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy5zaGFwZSl7XG4gICAgICAgIHRoaXMuYWRkU2hhcGUob3B0aW9ucy5zaGFwZSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xufVxuQm9keS5wcm90b3R5cGUgPSBuZXcgRXZlbnRUYXJnZXQoKTtcbkJvZHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm9keTtcblxuLyoqXG4gKiBEaXNwYXRjaGVkIGFmdGVyIHR3byBib2RpZXMgY29sbGlkZS4gVGhpcyBldmVudCBpcyBkaXNwYXRjaGVkIG9uIGVhY2hcbiAqIG9mIHRoZSB0d28gYm9kaWVzIGludm9sdmVkIGluIHRoZSBjb2xsaXNpb24uXG4gKiBAZXZlbnQgY29sbGlkZVxuICogQHBhcmFtIHtCb2R5fSBib2R5IFRoZSBib2R5IHRoYXQgd2FzIGludm9sdmVkIGluIHRoZSBjb2xsaXNpb24uXG4gKiBAcGFyYW0ge0NvbnRhY3RFcXVhdGlvbn0gY29udGFjdCBUaGUgZGV0YWlscyBvZiB0aGUgY29sbGlzaW9uLlxuICovXG5Cb2R5LkNPTExJREVfRVZFTlRfTkFNRSA9IFwiY29sbGlkZVwiO1xuXG4vKipcbiAqIEEgZHluYW1pYyBib2R5IGlzIGZ1bGx5IHNpbXVsYXRlZC4gQ2FuIGJlIG1vdmVkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLCBidXQgbm9ybWFsbHkgdGhleSBtb3ZlIGFjY29yZGluZyB0byBmb3JjZXMuIEEgZHluYW1pYyBib2R5IGNhbiBjb2xsaWRlIHdpdGggYWxsIGJvZHkgdHlwZXMuIEEgZHluYW1pYyBib2R5IGFsd2F5cyBoYXMgZmluaXRlLCBub24temVybyBtYXNzLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IERZTkFNSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkJvZHkuRFlOQU1JQyA9IDE7XG5cbi8qKlxuICogQSBzdGF0aWMgYm9keSBkb2VzIG5vdCBtb3ZlIGR1cmluZyBzaW11bGF0aW9uIGFuZCBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBTdGF0aWMgYm9kaWVzIGNhbiBiZSBtb3ZlZCBtYW51YWxseSBieSBzZXR0aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keS4gVGhlIHZlbG9jaXR5IG9mIGEgc3RhdGljIGJvZHkgaXMgYWx3YXlzIHplcm8uIFN0YXRpYyBib2RpZXMgZG8gbm90IGNvbGxpZGUgd2l0aCBvdGhlciBzdGF0aWMgb3Iga2luZW1hdGljIGJvZGllcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBTVEFUSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkJvZHkuU1RBVElDID0gMjtcblxuLyoqXG4gKiBBIGtpbmVtYXRpYyBib2R5IG1vdmVzIHVuZGVyIHNpbXVsYXRpb24gYWNjb3JkaW5nIHRvIGl0cyB2ZWxvY2l0eS4gVGhleSBkbyBub3QgcmVzcG9uZCB0byBmb3JjZXMuIFRoZXkgY2FuIGJlIG1vdmVkIG1hbnVhbGx5LCBidXQgbm9ybWFsbHkgYSBraW5lbWF0aWMgYm9keSBpcyBtb3ZlZCBieSBzZXR0aW5nIGl0cyB2ZWxvY2l0eS4gQSBraW5lbWF0aWMgYm9keSBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBLaW5lbWF0aWMgYm9kaWVzIGRvIG5vdCBjb2xsaWRlIHdpdGggb3RoZXIgc3RhdGljIG9yIGtpbmVtYXRpYyBib2RpZXMuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkgS0lORU1BVElDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5Cb2R5LktJTkVNQVRJQyA9IDQ7XG5cblxuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBBV0FLRVxuICogQHR5cGUge251bWJlcn1cbiAqL1xuQm9keS5BV0FLRSA9IDA7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IFNMRUVQWVxuICogQHR5cGUge251bWJlcn1cbiAqL1xuQm9keS5TTEVFUFkgPSAxO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBTTEVFUElOR1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuQm9keS5TTEVFUElORyA9IDI7XG5cbkJvZHkuaWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBEaXNwYXRjaGVkIGFmdGVyIGEgc2xlZXBpbmcgYm9keSBoYXMgd29rZW4gdXAuXG4gKiBAZXZlbnQgd2FrZXVwXG4gKi9cbkJvZHkud2FrZXVwRXZlbnQgPSB7XG4gICAgdHlwZTogXCJ3YWtldXBcIlxufTtcblxuLyoqXG4gKiBXYWtlIHRoZSBib2R5IHVwLlxuICogQG1ldGhvZCB3YWtlVXBcbiAqL1xuQm9keS5wcm90b3R5cGUud2FrZVVwID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcyA9IHRoaXMuc2xlZXBTdGF0ZTtcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSAwO1xuICAgIHRoaXMuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcbiAgICBpZihzID09PSBCb2R5LlNMRUVQSU5HKXtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEJvZHkud2FrZXVwRXZlbnQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRm9yY2UgYm9keSBzbGVlcFxuICogQG1ldGhvZCBzbGVlcFxuICovXG5Cb2R5LnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUElORztcbiAgICB0aGlzLnZlbG9jaXR5LnNldCgwLDAsMCk7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuc2V0KDAsMCwwKTtcbiAgICB0aGlzLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBnb25lIGluIHRvIHRoZSBzbGVlcHkgc3RhdGUuXG4gKiBAZXZlbnQgc2xlZXB5XG4gKi9cbkJvZHkuc2xlZXB5RXZlbnQgPSB7XG4gICAgdHlwZTogXCJzbGVlcHlcIlxufTtcblxuLyoqXG4gKiBEaXNwYXRjaGVkIGFmdGVyIGEgYm9keSBoYXMgZmFsbGVuIGFzbGVlcC5cbiAqIEBldmVudCBzbGVlcFxuICovXG5Cb2R5LnNsZWVwRXZlbnQgPSB7XG4gICAgdHlwZTogXCJzbGVlcFwiXG59O1xuXG4vKipcbiAqIENhbGxlZCBldmVyeSB0aW1lc3RlcCB0byB1cGRhdGUgaW50ZXJuYWwgc2xlZXAgdGltZXIgYW5kIGNoYW5nZSBzbGVlcCBzdGF0ZSBpZiBuZWVkZWQuXG4gKiBAbWV0aG9kIHNsZWVwVGlja1xuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIHdvcmxkIHRpbWUgaW4gc2Vjb25kc1xuICovXG5Cb2R5LnByb3RvdHlwZS5zbGVlcFRpY2sgPSBmdW5jdGlvbih0aW1lKXtcbiAgICBpZih0aGlzLmFsbG93U2xlZXApe1xuICAgICAgICB2YXIgc2xlZXBTdGF0ZSA9IHRoaXMuc2xlZXBTdGF0ZTtcbiAgICAgICAgdmFyIHNwZWVkU3F1YXJlZCA9IHRoaXMudmVsb2NpdHkubm9ybTIoKSArIHRoaXMuYW5ndWxhclZlbG9jaXR5Lm5vcm0yKCk7XG4gICAgICAgIHZhciBzcGVlZExpbWl0U3F1YXJlZCA9IE1hdGgucG93KHRoaXMuc2xlZXBTcGVlZExpbWl0LDIpO1xuICAgICAgICBpZihzbGVlcFN0YXRlPT09Qm9keS5BV0FLRSAmJiBzcGVlZFNxdWFyZWQgPCBzcGVlZExpbWl0U3F1YXJlZCl7XG4gICAgICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQWTsgLy8gU2xlZXB5XG4gICAgICAgICAgICB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gdGltZTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChCb2R5LnNsZWVweUV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmKHNsZWVwU3RhdGU9PT1Cb2R5LlNMRUVQWSAmJiBzcGVlZFNxdWFyZWQgPiBzcGVlZExpbWl0U3F1YXJlZCl7XG4gICAgICAgICAgICB0aGlzLndha2VVcCgpOyAvLyBXYWtlIHVwXG4gICAgICAgIH0gZWxzZSBpZihzbGVlcFN0YXRlPT09Qm9keS5TTEVFUFkgJiYgKHRpbWUgLSB0aGlzLnRpbWVMYXN0U2xlZXB5ICkgPiB0aGlzLnNsZWVwVGltZUxpbWl0KXtcbiAgICAgICAgICAgIHRoaXMuc2xlZXAoKTsgLy8gU2xlZXBpbmdcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChCb2R5LnNsZWVwRXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBJZiB0aGUgYm9keSBpcyBzbGVlcGluZywgaXQgc2hvdWxkIGJlIGltbW92YWJsZSAvIGhhdmUgaW5maW5pdGUgbWFzcyBkdXJpbmcgc29sdmUuIFdlIHNvbHZlIGl0IGJ5IGhhdmluZyBhIHNlcGFyYXRlIFwic29sdmUgbWFzc1wiLlxuICogQG1ldGhvZCB1cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzXG4gKi9cbkJvZHkucHJvdG90eXBlLnVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyB8fCB0aGlzLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKXtcbiAgICAgICAgdGhpcy5pbnZNYXNzU29sdmUgPSAwO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZS5zZXRaZXJvKCk7XG4gICAgICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUuc2V0WmVybygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gdGhpcy5pbnZNYXNzO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZS5jb3B5KHRoaXMuaW52SW5lcnRpYSk7XG4gICAgICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUuY29weSh0aGlzLmludkluZXJ0aWFXb3JsZCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgd29ybGQgcG9pbnQgdG8gbG9jYWwgYm9keSBmcmFtZS5cbiAqIEBtZXRob2QgcG9pbnRUb0xvY2FsRnJhbWVcbiAqIEBwYXJhbSAge1ZlYzN9IHdvcmxkUG9pbnRcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuQm9keS5wcm90b3R5cGUucG9pbnRUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbih3b3JsZFBvaW50LHJlc3VsdCl7XG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xuICAgIHdvcmxkUG9pbnQudnN1Yih0aGlzLnBvc2l0aW9uLHJlc3VsdCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KHJlc3VsdCxyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSB3b3JsZCB2ZWN0b3IgdG8gbG9jYWwgYm9keSBmcmFtZS5cbiAqIEBtZXRob2QgdmVjdG9yVG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtWZWMzfSB3b3JsZFBvaW50XG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cbkJvZHkucHJvdG90eXBlLnZlY3RvclRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uKHdvcmxkVmVjdG9yLCByZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24uY29uanVnYXRlKCkudm11bHQod29ybGRWZWN0b3IscmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgbG9jYWwgYm9keSBwb2ludCB0byB3b3JsZCBmcmFtZS5cbiAqIEBtZXRob2QgcG9pbnRUb1dvcmxkRnJhbWVcbiAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsUG9pbnRcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuQm9keS5wcm90b3R5cGUucG9pbnRUb1dvcmxkRnJhbWUgPSBmdW5jdGlvbihsb2NhbFBvaW50LHJlc3VsdCl7XG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xuICAgIHRoaXMucXVhdGVybmlvbi52bXVsdChsb2NhbFBvaW50LHJlc3VsdCk7XG4gICAgcmVzdWx0LnZhZGQodGhpcy5wb3NpdGlvbixyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBsb2NhbCBib2R5IHBvaW50IHRvIHdvcmxkIGZyYW1lLlxuICogQG1ldGhvZCB2ZWN0b3JUb1dvcmxkRnJhbWVcbiAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsVmVjdG9yXG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cbkJvZHkucHJvdG90eXBlLnZlY3RvclRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uKGxvY2FsVmVjdG9yLCByZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciB0bXBWZWMgPSBuZXcgVmVjMygpO1xudmFyIHRtcFF1YXQgPSBuZXcgUXVhdGVybmlvbigpO1xuXG4vKipcbiAqIEFkZCBhIHNoYXBlIHRvIHRoZSBib2R5IHdpdGggYSBsb2NhbCBvZmZzZXQgYW5kIG9yaWVudGF0aW9uLlxuICogQG1ldGhvZCBhZGRTaGFwZVxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7VmVjM30gW19vZmZzZXRdXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IFtfb3JpZW50YXRpb25dXG4gKiBAcmV0dXJuIHtCb2R5fSBUaGUgYm9keSBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gKi9cbkJvZHkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIF9vZmZzZXQsIF9vcmllbnRhdGlvbil7XG4gICAgdmFyIG9mZnNldCA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIG9yaWVudGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIGlmKF9vZmZzZXQpe1xuICAgICAgICBvZmZzZXQuY29weShfb2Zmc2V0KTtcbiAgICB9XG4gICAgaWYoX29yaWVudGF0aW9uKXtcbiAgICAgICAgb3JpZW50YXRpb24uY29weShfb3JpZW50YXRpb24pO1xuICAgIH1cblxuICAgIHRoaXMuc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgIHRoaXMuc2hhcGVPZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICB0aGlzLnNoYXBlT3JpZW50YXRpb25zLnB1c2gob3JpZW50YXRpb24pO1xuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBzaGFwZS5ib2R5ID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgYm9keS4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBzaGFwZXMgYXJlIGNoYW5nZWQuXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKi9cbkJvZHkucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgc2hhcGVzID0gdGhpcy5zaGFwZXMsXG4gICAgICAgIHNoYXBlT2Zmc2V0cyA9IHRoaXMuc2hhcGVPZmZzZXRzLFxuICAgICAgICBOID0gc2hhcGVzLmxlbmd0aCxcbiAgICAgICAgcmFkaXVzID0gMDtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2ldO1xuICAgICAgICBzaGFwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gc2hhcGVPZmZzZXRzW2ldLm5vcm0oKSxcbiAgICAgICAgICAgIHIgPSBzaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cztcbiAgICAgICAgaWYob2Zmc2V0ICsgciA+IHJhZGl1cyl7XG4gICAgICAgICAgICByYWRpdXMgPSBvZmZzZXQgKyByO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHJhZGl1cztcbn07XG5cbnZhciBjb21wdXRlQUFCQl9zaGFwZUFBQkIgPSBuZXcgQUFCQigpO1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIC5hYWJiXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAdG9kbyByZW5hbWUgdG8gdXBkYXRlQUFCQigpXG4gKi9cbkJvZHkucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgc2hhcGVzID0gdGhpcy5zaGFwZXMsXG4gICAgICAgIHNoYXBlT2Zmc2V0cyA9IHRoaXMuc2hhcGVPZmZzZXRzLFxuICAgICAgICBzaGFwZU9yaWVudGF0aW9ucyA9IHRoaXMuc2hhcGVPcmllbnRhdGlvbnMsXG4gICAgICAgIE4gPSBzaGFwZXMubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSB0bXBWZWMsXG4gICAgICAgIG9yaWVudGF0aW9uID0gdG1wUXVhdCxcbiAgICAgICAgYm9keVF1YXQgPSB0aGlzLnF1YXRlcm5pb24sXG4gICAgICAgIGFhYmIgPSB0aGlzLmFhYmIsXG4gICAgICAgIHNoYXBlQUFCQiA9IGNvbXB1dGVBQUJCX3NoYXBlQUFCQjtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2ldO1xuXG4gICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBwb3NpdGlvblxuICAgICAgICBib2R5UXVhdC52bXVsdChzaGFwZU9mZnNldHNbaV0sIG9mZnNldCk7XG4gICAgICAgIG9mZnNldC52YWRkKHRoaXMucG9zaXRpb24sIG9mZnNldCk7XG5cbiAgICAgICAgLy8gR2V0IHNoYXBlIHdvcmxkIHF1YXRlcm5pb25cbiAgICAgICAgc2hhcGVPcmllbnRhdGlvbnNbaV0ubXVsdChib2R5UXVhdCwgb3JpZW50YXRpb24pO1xuXG4gICAgICAgIC8vIEdldCBzaGFwZSBBQUJCXG4gICAgICAgIHNoYXBlLmNhbGN1bGF0ZVdvcmxkQUFCQihvZmZzZXQsIG9yaWVudGF0aW9uLCBzaGFwZUFBQkIubG93ZXJCb3VuZCwgc2hhcGVBQUJCLnVwcGVyQm91bmQpO1xuXG4gICAgICAgIGlmKGkgPT09IDApe1xuICAgICAgICAgICAgYWFiYi5jb3B5KHNoYXBlQUFCQik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhYWJiLmV4dGVuZChzaGFwZUFBQkIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cbnZhciB1aXdfbTEgPSBuZXcgTWF0MygpLFxuICAgIHVpd19tMiA9IG5ldyBNYXQzKCksXG4gICAgdWl3X20zID0gbmV3IE1hdDMoKTtcblxuLyoqXG4gKiBVcGRhdGUgLmluZXJ0aWFXb3JsZCBhbmQgLmludkluZXJ0aWFXb3JsZFxuICogQG1ldGhvZCB1cGRhdGVJbmVydGlhV29ybGRcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlSW5lcnRpYVdvcmxkID0gZnVuY3Rpb24oZm9yY2Upe1xuICAgIHZhciBJID0gdGhpcy5pbnZJbmVydGlhO1xuICAgIGlmIChJLnggPT09IEkueSAmJiBJLnkgPT09IEkueiAmJiAhZm9yY2UpIHtcbiAgICAgICAgLy8gSWYgaW5lcnRpYSBNID0gcypJLCB3aGVyZSBJIGlzIGlkZW50aXR5IGFuZCBzIGEgc2NhbGFyLCB0aGVuXG4gICAgICAgIC8vICAgIFIqTSpSJyA9IFIqKHMqSSkqUicgPSBzKlIqSSpSJyA9IHMqUipSJyA9IHMqSSA9IE1cbiAgICAgICAgLy8gd2hlcmUgUiBpcyB0aGUgcm90YXRpb24gbWF0cml4LlxuICAgICAgICAvLyBJbiBvdGhlciB3b3Jkcywgd2UgZG9uJ3QgaGF2ZSB0byB0cmFuc2Zvcm0gdGhlIGluZXJ0aWEgaWYgYWxsXG4gICAgICAgIC8vIGluZXJ0aWEgZGlhZ29uYWwgZW50cmllcyBhcmUgZXF1YWwuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG0xID0gdWl3X20xLFxuICAgICAgICAgICAgbTIgPSB1aXdfbTIsXG4gICAgICAgICAgICBtMyA9IHVpd19tMztcbiAgICAgICAgbTEuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgICAgICBtMS50cmFuc3Bvc2UobTIpO1xuICAgICAgICBtMS5zY2FsZShJLG0xKTtcbiAgICAgICAgbTEubW11bHQobTIsdGhpcy5pbnZJbmVydGlhV29ybGQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQXBwbHkgZm9yY2UgdG8gYSB3b3JsZCBwb2ludC4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuIEFwcGx5aW5nIGZvcmNlIHRoaXMgd2F5IHdpbGwgYWRkIHRvIEJvZHkuZm9yY2UgYW5kIEJvZHkudG9ycXVlLlxuICogQG1ldGhvZCBhcHBseUZvcmNlXG4gKiBAcGFyYW0gIHtWZWMzfSBmb3JjZSBUaGUgYW1vdW50IG9mIGZvcmNlIHRvIGFkZC5cbiAqIEBwYXJhbSAge1ZlYzN9IHJlbGF0aXZlUG9pbnQgQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3MgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLlxuICovXG52YXIgQm9keV9hcHBseUZvcmNlX3IgPSBuZXcgVmVjMygpO1xudmFyIEJvZHlfYXBwbHlGb3JjZV9yb3RGb3JjZSA9IG5ldyBWZWMzKCk7XG5Cb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oZm9yY2UscmVsYXRpdmVQb2ludCl7XG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpeyAvLyBOZWVkZWQ/XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgZm9yY2VcbiAgICB2YXIgcm90Rm9yY2UgPSBCb2R5X2FwcGx5Rm9yY2Vfcm90Rm9yY2U7XG4gICAgcmVsYXRpdmVQb2ludC5jcm9zcyhmb3JjZSxyb3RGb3JjZSk7XG5cbiAgICAvLyBBZGQgbGluZWFyIGZvcmNlXG4gICAgdGhpcy5mb3JjZS52YWRkKGZvcmNlLHRoaXMuZm9yY2UpO1xuXG4gICAgLy8gQWRkIHJvdGF0aW9uYWwgZm9yY2VcbiAgICB0aGlzLnRvcnF1ZS52YWRkKHJvdEZvcmNlLHRoaXMudG9ycXVlKTtcbn07XG5cbi8qKlxuICogQXBwbHkgZm9yY2UgdG8gYSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keS5cbiAqIEBtZXRob2QgYXBwbHlMb2NhbEZvcmNlXG4gKiBAcGFyYW0gIHtWZWMzfSBmb3JjZSBUaGUgZm9yY2UgdmVjdG9yIHRvIGFwcGx5LCBkZWZpbmVkIGxvY2FsbHkgaW4gdGhlIGJvZHkgZnJhbWUuXG4gKiBAcGFyYW0gIHtWZWMzfSBsb2NhbFBvaW50IEEgbG9jYWwgcG9pbnQgaW4gdGhlIGJvZHkgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLlxuICovXG52YXIgQm9keV9hcHBseUxvY2FsRm9yY2Vfd29ybGRGb3JjZSA9IG5ldyBWZWMzKCk7XG52YXIgQm9keV9hcHBseUxvY2FsRm9yY2VfcmVsYXRpdmVQb2ludFdvcmxkID0gbmV3IFZlYzMoKTtcbkJvZHkucHJvdG90eXBlLmFwcGx5TG9jYWxGb3JjZSA9IGZ1bmN0aW9uKGxvY2FsRm9yY2UsIGxvY2FsUG9pbnQpe1xuICAgIGlmKHRoaXMudHlwZSAhPT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3b3JsZEZvcmNlID0gQm9keV9hcHBseUxvY2FsRm9yY2Vfd29ybGRGb3JjZTtcbiAgICB2YXIgcmVsYXRpdmVQb2ludFdvcmxkID0gQm9keV9hcHBseUxvY2FsRm9yY2VfcmVsYXRpdmVQb2ludFdvcmxkO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZSBmb3JjZSB2ZWN0b3IgdG8gd29ybGQgc3BhY2VcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbEZvcmNlLCB3b3JsZEZvcmNlKTtcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbFBvaW50LCByZWxhdGl2ZVBvaW50V29ybGQpO1xuXG4gICAgdGhpcy5hcHBseUZvcmNlKHdvcmxkRm9yY2UsIHJlbGF0aXZlUG9pbnRXb3JsZCk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGltcHVsc2UgdG8gYSB3b3JsZCBwb2ludC4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuIEFuIGltcHVsc2UgaXMgYSBmb3JjZSBhZGRlZCB0byBhIGJvZHkgZHVyaW5nIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgKGltcHVsc2UgPSBmb3JjZSAqIHRpbWUpLiBJbXB1bHNlcyB3aWxsIGJlIGFkZGVkIHRvIEJvZHkudmVsb2NpdHkgYW5kIEJvZHkuYW5ndWxhclZlbG9jaXR5LlxuICogQG1ldGhvZCBhcHBseUltcHVsc2VcbiAqIEBwYXJhbSAge1ZlYzN9IGltcHVsc2UgVGhlIGFtb3VudCBvZiBpbXB1bHNlIHRvIGFkZC5cbiAqIEBwYXJhbSAge1ZlYzN9IHJlbGF0aXZlUG9pbnQgQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3MgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLlxuICovXG52YXIgQm9keV9hcHBseUltcHVsc2VfciA9IG5ldyBWZWMzKCk7XG52YXIgQm9keV9hcHBseUltcHVsc2VfdmVsbyA9IG5ldyBWZWMzKCk7XG52YXIgQm9keV9hcHBseUltcHVsc2Vfcm90VmVsbyA9IG5ldyBWZWMzKCk7XG5Cb2R5LnByb3RvdHlwZS5hcHBseUltcHVsc2UgPSBmdW5jdGlvbihpbXB1bHNlLCByZWxhdGl2ZVBvaW50KXtcbiAgICBpZih0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQyl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHBvaW50IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBib2R5IGNlbnRlclxuICAgIHZhciByID0gcmVsYXRpdmVQb2ludDtcblxuICAgIC8vIENvbXB1dGUgcHJvZHVjZWQgY2VudHJhbCBpbXB1bHNlIHZlbG9jaXR5XG4gICAgdmFyIHZlbG8gPSBCb2R5X2FwcGx5SW1wdWxzZV92ZWxvO1xuICAgIHZlbG8uY29weShpbXB1bHNlKTtcbiAgICB2ZWxvLm11bHQodGhpcy5pbnZNYXNzLHZlbG8pO1xuXG4gICAgLy8gQWRkIGxpbmVhciBpbXB1bHNlXG4gICAgdGhpcy52ZWxvY2l0eS52YWRkKHZlbG8sIHRoaXMudmVsb2NpdHkpO1xuXG4gICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCByb3RhdGlvbmFsIGltcHVsc2UgdmVsb2NpdHlcbiAgICB2YXIgcm90VmVsbyA9IEJvZHlfYXBwbHlJbXB1bHNlX3JvdFZlbG87XG4gICAgci5jcm9zcyhpbXB1bHNlLHJvdFZlbG8pO1xuXG4gICAgLypcbiAgICByb3RWZWxvLnggKj0gdGhpcy5pbnZJbmVydGlhLng7XG4gICAgcm90VmVsby55ICo9IHRoaXMuaW52SW5lcnRpYS55O1xuICAgIHJvdFZlbG8ueiAqPSB0aGlzLmludkluZXJ0aWEuejtcbiAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkLnZtdWx0KHJvdFZlbG8scm90VmVsbyk7XG5cbiAgICAvLyBBZGQgcm90YXRpb25hbCBJbXB1bHNlXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkudmFkZChyb3RWZWxvLCB0aGlzLmFuZ3VsYXJWZWxvY2l0eSk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGxvY2FsbHktZGVmaW5lZCBpbXB1bHNlIHRvIGEgbG9jYWwgcG9pbnQgaW4gdGhlIGJvZHkuXG4gKiBAbWV0aG9kIGFwcGx5TG9jYWxJbXB1bHNlXG4gKiBAcGFyYW0gIHtWZWMzfSBmb3JjZSBUaGUgZm9yY2UgdmVjdG9yIHRvIGFwcGx5LCBkZWZpbmVkIGxvY2FsbHkgaW4gdGhlIGJvZHkgZnJhbWUuXG4gKiBAcGFyYW0gIHtWZWMzfSBsb2NhbFBvaW50IEEgbG9jYWwgcG9pbnQgaW4gdGhlIGJvZHkgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLlxuICovXG52YXIgQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZEltcHVsc2UgPSBuZXcgVmVjMygpO1xudmFyIEJvZHlfYXBwbHlMb2NhbEltcHVsc2VfcmVsYXRpdmVQb2ludCA9IG5ldyBWZWMzKCk7XG5Cb2R5LnByb3RvdHlwZS5hcHBseUxvY2FsSW1wdWxzZSA9IGZ1bmN0aW9uKGxvY2FsSW1wdWxzZSwgbG9jYWxQb2ludCl7XG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdvcmxkSW1wdWxzZSA9IEJvZHlfYXBwbHlMb2NhbEltcHVsc2Vfd29ybGRJbXB1bHNlO1xuICAgIHZhciByZWxhdGl2ZVBvaW50V29ybGQgPSBCb2R5X2FwcGx5TG9jYWxJbXB1bHNlX3JlbGF0aXZlUG9pbnQ7XG5cbiAgICAvLyBUcmFuc2Zvcm0gdGhlIGZvcmNlIHZlY3RvciB0byB3b3JsZCBzcGFjZVxuICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKGxvY2FsSW1wdWxzZSwgd29ybGRJbXB1bHNlKTtcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbFBvaW50LCByZWxhdGl2ZVBvaW50V29ybGQpO1xuXG4gICAgdGhpcy5hcHBseUltcHVsc2Uod29ybGRJbXB1bHNlLCByZWxhdGl2ZVBvaW50V29ybGQpO1xufTtcblxudmFyIEJvZHlfdXBkYXRlTWFzc1Byb3BlcnRpZXNfaGFsZkV4dGVudHMgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgeW91IGNoYW5nZSB0aGUgYm9keSBzaGFwZSBvciBtYXNzLlxuICogQG1ldGhvZCB1cGRhdGVNYXNzUHJvcGVydGllc1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVNYXNzUHJvcGVydGllcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbGZFeHRlbnRzID0gQm9keV91cGRhdGVNYXNzUHJvcGVydGllc19oYWxmRXh0ZW50cztcblxuICAgIHRoaXMuaW52TWFzcyA9IHRoaXMubWFzcyA+IDAgPyAxLjAgLyB0aGlzLm1hc3MgOiAwO1xuICAgIHZhciBJID0gdGhpcy5pbmVydGlhO1xuICAgIHZhciBmaXhlZCA9IHRoaXMuZml4ZWRSb3RhdGlvbjtcblxuICAgIC8vIEFwcHJveGltYXRlIHdpdGggQUFCQiBib3hcbiAgICB0aGlzLmNvbXB1dGVBQUJCKCk7XG4gICAgaGFsZkV4dGVudHMuc2V0KFxuICAgICAgICAodGhpcy5hYWJiLnVwcGVyQm91bmQueC10aGlzLmFhYmIubG93ZXJCb3VuZC54KSAvIDIsXG4gICAgICAgICh0aGlzLmFhYmIudXBwZXJCb3VuZC55LXRoaXMuYWFiYi5sb3dlckJvdW5kLnkpIC8gMixcbiAgICAgICAgKHRoaXMuYWFiYi51cHBlckJvdW5kLnotdGhpcy5hYWJiLmxvd2VyQm91bmQueikgLyAyXG4gICAgKTtcbiAgICBCb3guY2FsY3VsYXRlSW5lcnRpYShoYWxmRXh0ZW50cywgdGhpcy5tYXNzLCBJKTtcblxuICAgIHRoaXMuaW52SW5lcnRpYS5zZXQoXG4gICAgICAgIEkueCA+IDAgJiYgIWZpeGVkID8gMS4wIC8gSS54IDogMCxcbiAgICAgICAgSS55ID4gMCAmJiAhZml4ZWQgPyAxLjAgLyBJLnkgOiAwLFxuICAgICAgICBJLnogPiAwICYmICFmaXhlZCA/IDEuMCAvIEkueiA6IDBcbiAgICApO1xuICAgIHRoaXMudXBkYXRlSW5lcnRpYVdvcmxkKHRydWUpO1xufTtcblxuLyoqXG4gKiBHZXQgd29ybGQgdmVsb2NpdHkgb2YgYSBwb2ludCBpbiB0aGUgYm9keS5cbiAqIEBtZXRob2QgZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnRcbiAqIEBwYXJhbSAge1ZlYzN9IHdvcmxkUG9pbnRcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICogQHJldHVybiB7VmVjM30gVGhlIHJlc3VsdCB2ZWN0b3IuXG4gKi9cbkJvZHkucHJvdG90eXBlLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50ID0gZnVuY3Rpb24od29ybGRQb2ludCwgcmVzdWx0KXtcbiAgICB2YXIgciA9IG5ldyBWZWMzKCk7XG4gICAgd29ybGRQb2ludC52c3ViKHRoaXMucG9zaXRpb24sIHIpO1xuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHIsIHJlc3VsdCk7XG4gICAgdGhpcy52ZWxvY2l0eS52YWRkKHJlc3VsdCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHRvcnF1ZSA9IG5ldyBWZWMzKCk7XG52YXIgaW52SV90YXVfZHQgPSBuZXcgVmVjMygpO1xudmFyIHcgPSBuZXcgUXVhdGVybmlvbigpO1xudmFyIHdxID0gbmV3IFF1YXRlcm5pb24oKTtcblxuLyoqXG4gKiBNb3ZlIHRoZSBib2R5IGZvcndhcmQgaW4gdGltZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkdCBUaW1lIHN0ZXBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcXVhdE5vcm1hbGl6ZSBTZXQgdG8gdHJ1ZSB0byBub3JtYWxpemUgdGhlIGJvZHkgcXVhdGVybmlvblxuICogQHBhcmFtIHtib29sZWFufSBxdWF0Tm9ybWFsaXplRmFzdCBJZiB0aGUgcXVhdGVybmlvbiBzaG91bGQgYmUgbm9ybWFsaXplZCB1c2luZyBcImZhc3RcIiBxdWF0ZXJuaW9uIG5vcm1hbGl6YXRpb25cbiAqL1xuQm9keS5wcm90b3R5cGUuaW50ZWdyYXRlID0gZnVuY3Rpb24oZHQsIHF1YXROb3JtYWxpemUsIHF1YXROb3JtYWxpemVGYXN0KXtcblxuICAgIC8vIFNhdmUgcHJldmlvdXMgcG9zaXRpb25cbiAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24uY29weSh0aGlzLnBvc2l0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUXVhdGVybmlvbi5jb3B5KHRoaXMucXVhdGVybmlvbik7XG5cbiAgICBpZighKHRoaXMudHlwZSA9PT0gQm9keS5EWU5BTUlDIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpIHx8IHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyl7IC8vIE9ubHkgZm9yIGR5bmFtaWNcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2ZWxvID0gdGhpcy52ZWxvY2l0eSxcbiAgICAgICAgYW5ndWxhclZlbG8gPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbixcbiAgICAgICAgZm9yY2UgPSB0aGlzLmZvcmNlLFxuICAgICAgICB0b3JxdWUgPSB0aGlzLnRvcnF1ZSxcbiAgICAgICAgcXVhdCA9IHRoaXMucXVhdGVybmlvbixcbiAgICAgICAgaW52TWFzcyA9IHRoaXMuaW52TWFzcyxcbiAgICAgICAgaW52SW5lcnRpYSA9IHRoaXMuaW52SW5lcnRpYVdvcmxkLFxuICAgICAgICBsaW5lYXJGYWN0b3IgPSB0aGlzLmxpbmVhckZhY3RvcjtcblxuICAgIHZhciBpTWR0ID0gaW52TWFzcyAqIGR0O1xuICAgIHZlbG8ueCArPSBmb3JjZS54ICogaU1kdCAqIGxpbmVhckZhY3Rvci54O1xuICAgIHZlbG8ueSArPSBmb3JjZS55ICogaU1kdCAqIGxpbmVhckZhY3Rvci55O1xuICAgIHZlbG8ueiArPSBmb3JjZS56ICogaU1kdCAqIGxpbmVhckZhY3Rvci56O1xuXG4gICAgdmFyIGUgPSBpbnZJbmVydGlhLmVsZW1lbnRzO1xuICAgIHZhciBhbmd1bGFyRmFjdG9yID0gdGhpcy5hbmd1bGFyRmFjdG9yO1xuICAgIHZhciB0eCA9IHRvcnF1ZS54ICogYW5ndWxhckZhY3Rvci54O1xuICAgIHZhciB0eSA9IHRvcnF1ZS55ICogYW5ndWxhckZhY3Rvci55O1xuICAgIHZhciB0eiA9IHRvcnF1ZS56ICogYW5ndWxhckZhY3Rvci56O1xuICAgIGFuZ3VsYXJWZWxvLnggKz0gZHQgKiAoZVswXSAqIHR4ICsgZVsxXSAqIHR5ICsgZVsyXSAqIHR6KTtcbiAgICBhbmd1bGFyVmVsby55ICs9IGR0ICogKGVbM10gKiB0eCArIGVbNF0gKiB0eSArIGVbNV0gKiB0eik7XG4gICAgYW5ndWxhclZlbG8ueiArPSBkdCAqIChlWzZdICogdHggKyBlWzddICogdHkgKyBlWzhdICogdHopO1xuXG4gICAgLy8gVXNlIG5ldyB2ZWxvY2l0eSAgLSBsZWFwIGZyb2dcbiAgICBwb3MueCArPSB2ZWxvLnggKiBkdDtcbiAgICBwb3MueSArPSB2ZWxvLnkgKiBkdDtcbiAgICBwb3MueiArPSB2ZWxvLnogKiBkdDtcblxuICAgIHF1YXQuaW50ZWdyYXRlKHRoaXMuYW5ndWxhclZlbG9jaXR5LCBkdCwgdGhpcy5hbmd1bGFyRmFjdG9yLCBxdWF0KTtcblxuICAgIGlmKHF1YXROb3JtYWxpemUpe1xuICAgICAgICBpZihxdWF0Tm9ybWFsaXplRmFzdCl7XG4gICAgICAgICAgICBxdWF0Lm5vcm1hbGl6ZUZhc3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1YXQubm9ybWFsaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAvLyBVcGRhdGUgd29ybGQgaW5lcnRpYVxuICAgIHRoaXMudXBkYXRlSW5lcnRpYVdvcmxkKCk7XG59O1xuIiwidmFyIEJvZHkgPSByZXF1aXJlKCcuL0JvZHknKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFJheWNhc3RSZXN1bHQgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xudmFyIFJheSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9SYXknKTtcbnZhciBXaGVlbEluZm8gPSByZXF1aXJlKCcuLi9vYmplY3RzL1doZWVsSW5mbycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RWZWhpY2xlO1xuXG4vKipcbiAqIFZlaGljbGUgaGVscGVyIGNsYXNzIHRoYXQgY2FzdHMgcmF5cyBmcm9tIHRoZSB3aGVlbCBwb3NpdGlvbnMgdG93YXJkcyB0aGUgZ3JvdW5kIGFuZCBhcHBsaWVzIGZvcmNlcy5cbiAqIEBjbGFzcyBSYXljYXN0VmVoaWNsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0JvZHl9IFtvcHRpb25zLmNoYXNzaXNCb2R5XSBUaGUgY2FyIGNoYXNzaXMgYm9keS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuaW5kZXhSaWdodEF4aXNdIEF4aXMgdG8gdXNlIGZvciByaWdodC4geD0wLCB5PTEsIHo9MlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5pbmRleExlZnRBeGlzXVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5pbmRleFVwQXhpc11cbiAqL1xuZnVuY3Rpb24gUmF5Y2FzdFZlaGljbGUob3B0aW9ucyl7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGNoYXNzaXNCb2R5XG4gICAgICovXG4gICAgdGhpcy5jaGFzc2lzQm9keSA9IG9wdGlvbnMuY2hhc3Npc0JvZHk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBXaGVlbEluZm8gb2JqZWN0cy5cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSB3aGVlbEluZm9zXG4gICAgICovXG4gICAgdGhpcy53aGVlbEluZm9zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBjYXIgaXMgc2xpZGluZy5cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNsaWRpbmdcbiAgICAgKi9cbiAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7V29ybGR9IHdvcmxkXG4gICAgICovXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJbmRleCBvZiB0aGUgcmlnaHQgYXhpcywgMD14LCAxPXksIDI9elxuICAgICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXhSaWdodEF4aXNcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5pbmRleFJpZ2h0QXhpcyA9IHR5cGVvZihvcHRpb25zLmluZGV4UmlnaHRBeGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmluZGV4UmlnaHRBeGlzIDogMTtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSBmb3J3YXJkIGF4aXMsIDA9eCwgMT15LCAyPXpcbiAgICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IGluZGV4Rm9yd2FyZEF4aXNcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5pbmRleEZvcndhcmRBeGlzID0gdHlwZW9mKG9wdGlvbnMuaW5kZXhGb3J3YXJkQXhpcykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleEZvcndhcmRBeGlzIDogMDtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSB1cCBheGlzLCAwPXgsIDE9eSwgMj16XG4gICAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBpbmRleFVwQXhpc1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICB0aGlzLmluZGV4VXBBeGlzID0gdHlwZW9mKG9wdGlvbnMuaW5kZXhVcEF4aXMpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuaW5kZXhVcEF4aXMgOiAyO1xufVxuXG52YXIgdG1wVmVjMSA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjMyA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjNCA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjNSA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjNiA9IG5ldyBWZWMzKCk7XG52YXIgdG1wUmF5ID0gbmV3IFJheSgpO1xuXG4vKipcbiAqIEFkZCBhIHdoZWVsLiBGb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9wdGlvbnMsIHNlZSBXaGVlbEluZm8uXG4gKiBAbWV0aG9kIGFkZFdoZWVsXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKi9cblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGluZm8gPSBuZXcgV2hlZWxJbmZvKG9wdGlvbnMpO1xuICAgIHZhciBpbmRleCA9IHRoaXMud2hlZWxJbmZvcy5sZW5ndGg7XG4gICAgdGhpcy53aGVlbEluZm9zLnB1c2goaW5mbyk7XG5cbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3RlZXJpbmcgdmFsdWUgb2YgYSB3aGVlbC5cbiAqIEBtZXRob2Qgc2V0U3RlZXJpbmdWYWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnNldFN0ZWVyaW5nVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XG4gICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdO1xuICAgIHdoZWVsLnN0ZWVyaW5nID0gdmFsdWU7XG59O1xuXG52YXIgdG9ycXVlID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBTZXQgdGhlIHdoZWVsIGZvcmNlIHRvIGFwcGx5IG9uIG9uZSBvZiB0aGUgd2hlZWxzIGVhY2ggdGltZSBzdGVwXG4gKiBAbWV0aG9kIGFwcGx5RW5naW5lRm9yY2VcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmFwcGx5RW5naW5lRm9yY2UgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XG4gICAgdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLmVuZ2luZUZvcmNlID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYnJha2luZyBmb3JjZSBvZiBhIHdoZWVsXG4gKiBAbWV0aG9kIHNldEJyYWtlXG4gKiBAcGFyYW0ge251bWJlcn0gYnJha2VcbiAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxuICovXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuc2V0QnJha2UgPSBmdW5jdGlvbihicmFrZSwgd2hlZWxJbmRleCl7XG4gICAgdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLmJyYWtlID0gYnJha2U7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIHRvIHRoZSB3b3JsZC5cbiAqIEBtZXRob2QgYWRkVG9Xb3JsZFxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICB3b3JsZC5hZGRCb2R5KHRoaXMuY2hhc3Npc0JvZHkpO1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLnByZVN0ZXBDYWxsYmFjayA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoYXQudXBkYXRlVmVoaWNsZSh3b3JsZC5kdCk7XG4gICAgfTtcbiAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKCdwcmVTdGVwJywgdGhpcy5wcmVTdGVwQ2FsbGJhY2spO1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbn07XG5cbi8qKlxuICogR2V0IG9uZSBvZiB0aGUgd2hlZWwgYXhsZXMsIHdvcmxkLW9yaWVudGVkLlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgZ2V0VmVoaWNsZUF4aXNXb3JsZFxuICogQHBhcmFtICB7aW50ZWdlcn0gYXhpc0luZGV4XG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmdldFZlaGljbGVBeGlzV29ybGQgPSBmdW5jdGlvbihheGlzSW5kZXgsIHJlc3VsdCl7XG4gICAgcmVzdWx0LnNldChcbiAgICAgICAgYXhpc0luZGV4ID09PSAwID8gMSA6IDAsXG4gICAgICAgIGF4aXNJbmRleCA9PT0gMSA/IDEgOiAwLFxuICAgICAgICBheGlzSW5kZXggPT09IDIgPyAxIDogMFxuICAgICk7XG4gICAgdGhpcy5jaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUocmVzdWx0LCByZXN1bHQpO1xufTtcblxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVZlaGljbGUgPSBmdW5jdGlvbih0aW1lU3RlcCl7XG4gICAgdmFyIHdoZWVsSW5mb3MgPSB0aGlzLndoZWVsSW5mb3M7XG4gICAgdmFyIG51bVdoZWVscyA9IHdoZWVsSW5mb3MubGVuZ3RoO1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm0oaSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50VmVoaWNsZVNwZWVkS21Ib3VyID0gMy42ICogY2hhc3Npc0JvZHkudmVsb2NpdHkubm9ybSgpO1xuXG4gICAgdmFyIGZvcndhcmRXb3JsZCA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5nZXRWZWhpY2xlQXhpc1dvcmxkKHRoaXMuaW5kZXhGb3J3YXJkQXhpcywgZm9yd2FyZFdvcmxkKTtcblxuICAgIGlmIChmb3J3YXJkV29ybGQuZG90KGNoYXNzaXNCb2R5LnZlbG9jaXR5KSA8IDApe1xuICAgICAgICB0aGlzLmN1cnJlbnRWZWhpY2xlU3BlZWRLbUhvdXIgKj0gLTE7XG4gICAgfVxuXG4gICAgLy8gc2ltdWxhdGUgc3VzcGVuc2lvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy5jYXN0UmF5KHdoZWVsSW5mb3NbaV0pO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU3VzcGVuc2lvbih0aW1lU3RlcCk7XG5cbiAgICB2YXIgaW1wdWxzZSA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIHJlbHBvcyA9IG5ldyBWZWMzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xuICAgICAgICAvL2FwcGx5IHN1c3BlbnNpb24gZm9yY2VcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcbiAgICAgICAgdmFyIHN1c3BlbnNpb25Gb3JjZSA9IHdoZWVsLnN1c3BlbnNpb25Gb3JjZTtcbiAgICAgICAgaWYgKHN1c3BlbnNpb25Gb3JjZSA+IHdoZWVsLm1heFN1c3BlbnNpb25Gb3JjZSkge1xuICAgICAgICAgICAgc3VzcGVuc2lvbkZvcmNlID0gd2hlZWwubWF4U3VzcGVuc2lvbkZvcmNlO1xuICAgICAgICB9XG4gICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuc2NhbGUoc3VzcGVuc2lvbkZvcmNlICogdGltZVN0ZXAsIGltcHVsc2UpO1xuXG4gICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXNCb2R5LnBvc2l0aW9uLCByZWxwb3MpO1xuICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2UoaW1wdWxzZSwgcmVscG9zKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUZyaWN0aW9uKHRpbWVTdGVwKTtcblxuICAgIHZhciBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgZndkICA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIHZlbCA9IG5ldyBWZWMzKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG4gICAgICAgIC8vdmFyIHJlbHBvcyA9IG5ldyBWZWMzKCk7XG4gICAgICAgIC8vd2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbHBvcyk7XG4gICAgICAgIGNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCwgdmVsKTtcblxuICAgICAgICAvLyBIYWNrIHRvIGdldCB0aGUgcm90YXRpb24gaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uXG4gICAgICAgIHZhciBtID0gMTtcbiAgICAgICAgc3dpdGNoKHRoaXMuaW5kZXhVcEF4aXMpe1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBtID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aGVlbC5pc0luQ29udGFjdCkge1xuXG4gICAgICAgICAgICB0aGlzLmdldFZlaGljbGVBeGlzV29ybGQodGhpcy5pbmRleEZvcndhcmRBeGlzLCBmd2QpO1xuICAgICAgICAgICAgdmFyIHByb2ogPSBmd2QuZG90KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5zY2FsZShwcm9qLCBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qKTtcblxuICAgICAgICAgICAgZndkLnZzdWIoaGl0Tm9ybWFsV29ybGRTY2FsZWRXaXRoUHJvaiwgZndkKTtcblxuICAgICAgICAgICAgdmFyIHByb2oyID0gZndkLmRvdCh2ZWwpO1xuICAgICAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiA9IG0gKiBwcm9qMiAqIHRpbWVTdGVwIC8gd2hlZWwucmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoKHdoZWVsLnNsaWRpbmcgfHwgIXdoZWVsLmlzSW5Db250YWN0KSAmJiB3aGVlbC5lbmdpbmVGb3JjZSAhPT0gMCAmJiB3aGVlbC51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkKXtcbiAgICAgICAgICAgIC8vIEFwcGx5IGN1c3RvbSByb3RhdGlvbiB3aGVuIGFjY2VsZXJhdGluZyBhbmQgc2xpZGluZ1xuICAgICAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiA9ICh3aGVlbC5lbmdpbmVGb3JjZSA+IDAgPyAxIDogLTEpICogd2hlZWwuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCAqIHRpbWVTdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9jayB3aGVlbHNcbiAgICAgICAgaWYoTWF0aC5hYnMod2hlZWwuYnJha2UpID4gTWF0aC5hYnMod2hlZWwuZW5naW5lRm9yY2UpKXtcbiAgICAgICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hlZWwucm90YXRpb24gKz0gd2hlZWwuZGVsdGFSb3RhdGlvbjsgLy8gVXNlIHRoZSBvbGQgdmFsdWVcbiAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiAqPSAwLjk5OyAvLyBkYW1waW5nIG9mIHJvdGF0aW9uIHdoZW4gbm90IGluIGNvbnRhY3RcbiAgICB9XG59O1xuXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUudXBkYXRlU3VzcGVuc2lvbiA9IGZ1bmN0aW9uKGRlbHRhVGltZSkge1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG4gICAgdmFyIGNoYXNzaXNNYXNzID0gY2hhc3Npc0JvZHkubWFzcztcbiAgICB2YXIgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciB3X2l0ID0gMDsgd19pdCA8IG51bVdoZWVsczsgd19pdCsrKXtcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1t3X2l0XTtcblxuICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3Qpe1xuICAgICAgICAgICAgdmFyIGZvcmNlO1xuXG4gICAgICAgICAgICAvLyBTcHJpbmdcbiAgICAgICAgICAgIHZhciBzdXNwX2xlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRfbGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvbkxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsZW5ndGhfZGlmZiA9IChzdXNwX2xlbmd0aCAtIGN1cnJlbnRfbGVuZ3RoKTtcblxuICAgICAgICAgICAgZm9yY2UgPSB3aGVlbC5zdXNwZW5zaW9uU3RpZmZuZXNzICogbGVuZ3RoX2RpZmYgKiB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb247XG5cbiAgICAgICAgICAgIC8vIERhbXBlclxuICAgICAgICAgICAgdmFyIHByb2plY3RlZF9yZWxfdmVsID0gd2hlZWwuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHk7XG4gICAgICAgICAgICB2YXIgc3VzcF9kYW1waW5nO1xuICAgICAgICAgICAgaWYgKHByb2plY3RlZF9yZWxfdmVsIDwgMCkge1xuICAgICAgICAgICAgICAgIHN1c3BfZGFtcGluZyA9IHdoZWVsLmRhbXBpbmdDb21wcmVzc2lvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VzcF9kYW1waW5nID0gd2hlZWwuZGFtcGluZ1JlbGF4YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3JjZSAtPSBzdXNwX2RhbXBpbmcgKiBwcm9qZWN0ZWRfcmVsX3ZlbDtcblxuICAgICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gZm9yY2UgKiBjaGFzc2lzTWFzcztcbiAgICAgICAgICAgIGlmICh3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25Gb3JjZSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIGZyb20gdGhlIHdvcmxkLlxuICogQG1ldGhvZCByZW1vdmVGcm9tV29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5yZW1vdmVGcm9tV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICB3b3JsZC5yZW1vdmUodGhpcy5jaGFzc2lzQm9keSk7XG4gICAgd29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTtcbiAgICB0aGlzLndvcmxkID0gbnVsbDtcbn07XG5cbnZhciBjYXN0UmF5X3JheXZlY3RvciA9IG5ldyBWZWMzKCk7XG52YXIgY2FzdFJheV90YXJnZXQgPSBuZXcgVmVjMygpO1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmNhc3RSYXkgPSBmdW5jdGlvbih3aGVlbCkge1xuICAgIHZhciByYXl2ZWN0b3IgPSBjYXN0UmF5X3JheXZlY3RvcjtcbiAgICB2YXIgdGFyZ2V0ID0gY2FzdFJheV90YXJnZXQ7XG5cbiAgICB0aGlzLnVwZGF0ZVdoZWVsVHJhbnNmb3JtV29ybGQod2hlZWwpO1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG5cbiAgICB2YXIgZGVwdGggPSAtMTtcblxuICAgIHZhciByYXlsZW4gPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aCArIHdoZWVsLnJhZGl1cztcblxuICAgIHdoZWVsLmRpcmVjdGlvbldvcmxkLnNjYWxlKHJheWxlbiwgcmF5dmVjdG9yKTtcbiAgICB2YXIgc291cmNlID0gd2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkO1xuICAgIHNvdXJjZS52YWRkKHJheXZlY3RvciwgdGFyZ2V0KTtcbiAgICB2YXIgcmF5Y2FzdFJlc3VsdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQ7XG5cbiAgICB2YXIgcGFyYW0gPSAwO1xuXG4gICAgcmF5Y2FzdFJlc3VsdC5yZXNldCgpO1xuICAgIC8vIFR1cm4gb2ZmIHJheSBjb2xsaXNpb24gd2l0aCB0aGUgY2hhc3NpcyB0ZW1wb3JhcmlseVxuICAgIHZhciBvbGRTdGF0ZSA9IGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlID0gZmFsc2U7XG5cbiAgICAvLyBDYXN0IHJheSBhZ2FpbnN0IHdvcmxkXG4gICAgdGhpcy53b3JsZC5yYXlUZXN0KHNvdXJjZSwgdGFyZ2V0LCByYXljYXN0UmVzdWx0KTtcbiAgICBjaGFzc2lzQm9keS5jb2xsaXNpb25SZXNwb25zZSA9IG9sZFN0YXRlO1xuXG4gICAgdmFyIG9iamVjdCA9IHJheWNhc3RSZXN1bHQuYm9keTtcblxuICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuZ3JvdW5kT2JqZWN0ID0gMDtcblxuICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgZGVwdGggPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkICA9IHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQ7XG4gICAgICAgIHdoZWVsLmlzSW5Db250YWN0ID0gdHJ1ZTtcblxuICAgICAgICB2YXIgaGl0RGlzdGFuY2UgPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gaGl0RGlzdGFuY2UgLSB3aGVlbC5yYWRpdXM7XG5cbiAgICAgICAgLy8gY2xhbXAgb24gbWF4IHN1c3BlbnNpb24gdHJhdmVsXG4gICAgICAgIHZhciBtaW5TdXNwZW5zaW9uTGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvblJlc3RMZW5ndGggLSB3aGVlbC5tYXhTdXNwZW5zaW9uVHJhdmVsO1xuICAgICAgICB2YXIgbWF4U3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDtcbiAgICAgICAgaWYgKHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPCBtaW5TdXNwZW5zaW9uTGVuZ3RoKSB7XG4gICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gbWluU3VzcGVuc2lvbkxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA+IG1heFN1c3BlbnNpb25MZW5ndGgpIHtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSBtYXhTdXNwZW5zaW9uTGVuZ3RoO1xuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5yZXNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3Qod2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuXG4gICAgICAgIHZhciBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCA9IG5ldyBWZWMzKCk7XG4gICAgICAgIGNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCwgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpO1xuXG4gICAgICAgIHZhciBwcm9qVmVsID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ICk7XG5cbiAgICAgICAgaWYgKGRlbm9taW5hdG9yID49IC0wLjEpIHtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEgLyAwLjE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW52ID0gLTEgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gcHJvalZlbCAqIGludjtcbiAgICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IGludjtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvL3B1dCB3aGVlbCBpbmZvIGFzIGluIHJlc3QgcG9zaXRpb25cbiAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgMCAqIHdoZWVsLm1heFN1c3BlbnNpb25UcmF2ZWw7XG4gICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMC4wO1xuICAgICAgICB3aGVlbC5kaXJlY3Rpb25Xb3JsZC5zY2FsZSgtMSwgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZCk7XG4gICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVwdGg7XG59O1xuXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUudXBkYXRlV2hlZWxUcmFuc2Zvcm1Xb3JsZCA9IGZ1bmN0aW9uKHdoZWVsKXtcbiAgICB3aGVlbC5pc0luQ29udGFjdCA9IGZhbHNlO1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG4gICAgY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsLCB3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQpO1xuICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5kaXJlY3Rpb25Mb2NhbCwgd2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5heGxlTG9jYWwsIHdoZWVsLmF4bGVXb3JsZCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIG9uZSBvZiB0aGUgd2hlZWwgdHJhbnNmb3JtLlxuICogTm90ZSB3aGVuIHJlbmRlcmluZyB3aGVlbHM6IGR1cmluZyBlYWNoIHN0ZXAsIHdoZWVsIHRyYW5zZm9ybXMgYXJlIHVwZGF0ZWQgQkVGT1JFIHRoZSBjaGFzc2lzOyBpZS4gdGhlaXIgcG9zaXRpb24gYmVjb21lcyBpbnZhbGlkIGFmdGVyIHRoZSBzdGVwLiBUaHVzIHdoZW4geW91IHJlbmRlciB3aGVlbHMsIHlvdSBtdXN0IHVwZGF0ZSB3aGVlbCB0cmFuc2Zvcm1zIGJlZm9yZSByZW5kZXJpbmcgdGhlbS4gU2VlIHJheWNhc3RWZWhpY2xlIGRlbW8gZm9yIGFuIGV4YW1wbGUuXG4gKiBAbWV0aG9kIHVwZGF0ZVdoZWVsVHJhbnNmb3JtXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXggVGhlIHdoZWVsIGluZGV4IHRvIHVwZGF0ZS5cbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVdoZWVsVHJhbnNmb3JtID0gZnVuY3Rpb24od2hlZWxJbmRleCl7XG4gICAgdmFyIHVwID0gdG1wVmVjNDtcbiAgICB2YXIgcmlnaHQgPSB0bXBWZWM1O1xuICAgIHZhciBmd2QgPSB0bXBWZWM2O1xuXG4gICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdO1xuICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm1Xb3JsZCh3aGVlbCk7XG5cbiAgICB3aGVlbC5kaXJlY3Rpb25Mb2NhbC5zY2FsZSgtMSwgdXApO1xuICAgIHJpZ2h0LmNvcHkod2hlZWwuYXhsZUxvY2FsKTtcbiAgICB1cC5jcm9zcyhyaWdodCwgZndkKTtcbiAgICBmd2Qubm9ybWFsaXplKCk7XG4gICAgcmlnaHQubm9ybWFsaXplKCk7XG5cbiAgICAvLyBSb3RhdGUgYXJvdW5kIHN0ZWVyaW5nIG92ZXIgdGhlIHdoZWVsQXhsZVxuICAgIHZhciBzdGVlcmluZyA9IHdoZWVsLnN0ZWVyaW5nO1xuICAgIHZhciBzdGVlcmluZ09ybiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgc3RlZXJpbmdPcm4uc2V0RnJvbUF4aXNBbmdsZSh1cCwgc3RlZXJpbmcpO1xuXG4gICAgdmFyIHJvdGF0aW5nT3JuID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICByb3RhdGluZ09ybi5zZXRGcm9tQXhpc0FuZ2xlKHJpZ2h0LCB3aGVlbC5yb3RhdGlvbik7XG5cbiAgICAvLyBXb3JsZCByb3RhdGlvbiBvZiB0aGUgd2hlZWxcbiAgICB2YXIgcSA9IHdoZWVsLndvcmxkVHJhbnNmb3JtLnF1YXRlcm5pb247XG4gICAgdGhpcy5jaGFzc2lzQm9keS5xdWF0ZXJuaW9uLm11bHQoc3RlZXJpbmdPcm4sIHEpO1xuICAgIHEubXVsdChyb3RhdGluZ09ybiwgcSk7XG5cbiAgICBxLm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gd29ybGQgcG9zaXRpb24gb2YgdGhlIHdoZWVsXG4gICAgdmFyIHAgPSB3aGVlbC53b3JsZFRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBwLmNvcHkod2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuICAgIHAuc2NhbGUod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCwgcCk7XG4gICAgcC52YWRkKHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCwgcCk7XG59O1xuXG52YXIgZGlyZWN0aW9ucyA9IFtcbiAgICBuZXcgVmVjMygxLCAwLCAwKSxcbiAgICBuZXcgVmVjMygwLCAxLCAwKSxcbiAgICBuZXcgVmVjMygwLCAwLCAxKVxuXTtcblxuLyoqXG4gKiBHZXQgdGhlIHdvcmxkIHRyYW5zZm9ybSBvZiBvbmUgb2YgdGhlIHdoZWVsc1xuICogQG1ldGhvZCBnZXRXaGVlbFRyYW5zZm9ybVdvcmxkXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm19XG4gKi9cblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5nZXRXaGVlbFRyYW5zZm9ybVdvcmxkID0gZnVuY3Rpb24od2hlZWxJbmRleCkge1xuICAgIHJldHVybiB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0ud29ybGRUcmFuc2Zvcm07XG59O1xuXG5cbnZhciB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSBuZXcgVmVjMygpO1xudmFyIHVwZGF0ZUZyaWN0aW9uX2F4bGUgPSBbXTtcbnZhciB1cGRhdGVGcmljdGlvbl9mb3J3YXJkV1MgPSBbXTtcbnZhciBzaWRlRnJpY3Rpb25TdGlmZm5lc3MyID0gMTtcblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS51cGRhdGVGcmljdGlvbiA9IGZ1bmN0aW9uKHRpbWVTdGVwKSB7XG4gICAgdmFyIHN1cmZOb3JtYWxXU19zY2FsZWRfcHJvaiA9IHVwZGF0ZUZyaWN0aW9uX3N1cmZOb3JtYWxXU19zY2FsZWRfcHJvajtcblxuICAgIC8vY2FsY3VsYXRlIHRoZSBpbXB1bHNlLCBzbyB0aGF0IHRoZSB3aGVlbHMgZG9uJ3QgbW92ZSBzaWRld2FyZHNcbiAgICB2YXIgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XG4gICAgdmFyIGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTtcbiAgICB2YXIgZm9yd2FyZFdTID0gdXBkYXRlRnJpY3Rpb25fZm9yd2FyZFdTO1xuICAgIHZhciBheGxlID0gdXBkYXRlRnJpY3Rpb25fYXhsZTtcblxuICAgIHZhciBudW1XaGVlbHNPbkdyb3VuZCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG5cbiAgICAgICAgdmFyIGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTtcbiAgICAgICAgaWYgKGdyb3VuZE9iamVjdCl7XG4gICAgICAgICAgICBudW1XaGVlbHNPbkdyb3VuZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hlZWwuc2lkZUltcHVsc2UgPSAwO1xuICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IDA7XG4gICAgICAgIGlmKCFmb3J3YXJkV1NbaV0pe1xuICAgICAgICAgICAgZm9yd2FyZFdTW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZighYXhsZVtpXSl7XG4gICAgICAgICAgICBheGxlW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspe1xuICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xuXG4gICAgICAgIHZhciBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7XG5cbiAgICAgICAgaWYgKGdyb3VuZE9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGF4bGVpID0gYXhsZVtpXTtcbiAgICAgICAgICAgIHZhciB3aGVlbFRyYW5zID0gdGhpcy5nZXRXaGVlbFRyYW5zZm9ybVdvcmxkKGkpO1xuXG4gICAgICAgICAgICAvLyBHZXQgd29ybGQgYXhsZVxuICAgICAgICAgICAgd2hlZWxUcmFucy52ZWN0b3JUb1dvcmxkRnJhbWUoZGlyZWN0aW9uc1t0aGlzLmluZGV4UmlnaHRBeGlzXSwgYXhsZWkpO1xuXG4gICAgICAgICAgICB2YXIgc3VyZk5vcm1hbFdTID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZDtcbiAgICAgICAgICAgIHZhciBwcm9qID0gYXhsZWkuZG90KHN1cmZOb3JtYWxXUyk7XG4gICAgICAgICAgICBzdXJmTm9ybWFsV1Muc2NhbGUocHJvaiwgc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qKTtcbiAgICAgICAgICAgIGF4bGVpLnZzdWIoc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qLCBheGxlaSk7XG4gICAgICAgICAgICBheGxlaS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgc3VyZk5vcm1hbFdTLmNyb3NzKGF4bGVpLCBmb3J3YXJkV1NbaV0pO1xuICAgICAgICAgICAgZm9yd2FyZFdTW2ldLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICB3aGVlbC5zaWRlSW1wdWxzZSA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWwoXG4gICAgICAgICAgICAgICAgY2hhc3Npc0JvZHksXG4gICAgICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgICAgIGdyb3VuZE9iamVjdCxcbiAgICAgICAgICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICAgICAgYXhsZWlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHNpZGVGcmljdGlvblN0aWZmbmVzczI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2lkZUZhY3RvciA9IDE7XG4gICAgdmFyIGZ3ZEZhY3RvciA9IDAuNTtcblxuICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcbiAgICAgICAgdmFyIGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTtcblxuICAgICAgICB2YXIgcm9sbGluZ0ZyaWN0aW9uID0gMDtcblxuICAgICAgICB3aGVlbC5zbGlwSW5mbyA9IDE7XG4gICAgICAgIGlmIChncm91bmRPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZSA9IDA7XG4gICAgICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IHdoZWVsLmJyYWtlID8gd2hlZWwuYnJha2UgOiBkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZTtcblxuICAgICAgICAgICAgLy8gYnRXaGVlbENvbnRhY3RQb2ludCBjb250YWN0UHQoY2hhc3Npc0JvZHksZ3JvdW5kT2JqZWN0LHdoZWVsSW5mcmF5Y2FzdEluZm8uaGl0UG9pbnRXb3JsZCxmb3J3YXJkV1Nbd2hlZWxdLG1heEltcHVsc2UpO1xuICAgICAgICAgICAgLy8gcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjb250YWN0UHQpO1xuICAgICAgICAgICAgcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjaGFzc2lzQm9keSwgZ3JvdW5kT2JqZWN0LCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsIGZvcndhcmRXU1tpXSwgbWF4SW1wdWxzZSk7XG5cbiAgICAgICAgICAgIHJvbGxpbmdGcmljdGlvbiArPSB3aGVlbC5lbmdpbmVGb3JjZSAqIHRpbWVTdGVwO1xuXG4gICAgICAgICAgICAvLyByb2xsaW5nRnJpY3Rpb24gPSAwO1xuICAgICAgICAgICAgdmFyIGZhY3RvciA9IG1heEltcHVsc2UgLyByb2xsaW5nRnJpY3Rpb247XG4gICAgICAgICAgICB3aGVlbC5zbGlwSW5mbyAqPSBmYWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICAvL3N3aXRjaCBiZXR3ZWVuIGFjdGl2ZSByb2xsaW5nICh0aHJvdHRsZSksIGJyYWtpbmcgYW5kIG5vbi1hY3RpdmUgcm9sbGluZyBmcmljdGlvbiAobnRocm90dGxlL2JyZWFrKVxuXG4gICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gMDtcbiAgICAgICAgd2hlZWwuc2tpZEluZm8gPSAxO1xuXG4gICAgICAgIGlmIChncm91bmRPYmplY3QpIHtcbiAgICAgICAgICAgIHdoZWVsLnNraWRJbmZvID0gMTtcblxuICAgICAgICAgICAgdmFyIG1heGltcCA9IHdoZWVsLnN1c3BlbnNpb25Gb3JjZSAqIHRpbWVTdGVwICogd2hlZWwuZnJpY3Rpb25TbGlwO1xuICAgICAgICAgICAgdmFyIG1heGltcFNpZGUgPSBtYXhpbXA7XG5cbiAgICAgICAgICAgIHZhciBtYXhpbXBTcXVhcmVkID0gbWF4aW1wICogbWF4aW1wU2lkZTtcblxuICAgICAgICAgICAgd2hlZWwuZm9yd2FyZEltcHVsc2UgPSByb2xsaW5nRnJpY3Rpb247Ly93aGVlbEluZm8uZW5naW5lRm9yY2UqIHRpbWVTdGVwO1xuXG4gICAgICAgICAgICB2YXIgeCA9IHdoZWVsLmZvcndhcmRJbXB1bHNlICogZndkRmFjdG9yO1xuICAgICAgICAgICAgdmFyIHkgPSB3aGVlbC5zaWRlSW1wdWxzZSAqIHNpZGVGYWN0b3I7XG5cbiAgICAgICAgICAgIHZhciBpbXB1bHNlU3F1YXJlZCA9IHggKiB4ICsgeSAqIHk7XG5cbiAgICAgICAgICAgIHdoZWVsLnNsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpbXB1bHNlU3F1YXJlZCA+IG1heGltcFNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNsaWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdoZWVsLnNsaWRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IG1heGltcCAvIE1hdGguc3FydChpbXB1bHNlU3F1YXJlZCk7XG5cbiAgICAgICAgICAgICAgICB3aGVlbC5za2lkSW5mbyAqPSBmYWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zbGlkaW5nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG4gICAgICAgICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAod2hlZWwuc2tpZEluZm8gPCAxKXtcbiAgICAgICAgICAgICAgICAgICAgd2hlZWwuZm9yd2FyZEltcHVsc2UgKj0gd2hlZWwuc2tpZEluZm87XG4gICAgICAgICAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHdoZWVsLnNraWRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRoZSBpbXB1bHNlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcblxuICAgICAgICB2YXIgcmVsX3BvcyA9IG5ldyBWZWMzKCk7XG4gICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXNCb2R5LnBvc2l0aW9uLCByZWxfcG9zKTtcbiAgICAgICAgLy8gY2Fubm9ucyBhcHBseWltcHVsc2UgaXMgdXNpbmcgd29ybGQgY29vcmQgZm9yIHRoZSBwb3NpdGlvblxuICAgICAgICAvL3JlbF9wb3MuY29weSh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQpO1xuXG4gICAgICAgIGlmICh3aGVlbC5mb3J3YXJkSW1wdWxzZSAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgZm9yd2FyZFdTW2ldLnNjYWxlKHdoZWVsLmZvcndhcmRJbXB1bHNlLCBpbXB1bHNlKTtcbiAgICAgICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlLCByZWxfcG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aGVlbC5zaWRlSW1wdWxzZSAhPT0gMCl7XG4gICAgICAgICAgICB2YXIgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xuXG4gICAgICAgICAgICB2YXIgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoZ3JvdW5kT2JqZWN0LnBvc2l0aW9uLCByZWxfcG9zMik7XG4gICAgICAgICAgICAvL3JlbF9wb3MyLmNvcHkod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkKTtcbiAgICAgICAgICAgIHZhciBzaWRlSW1wID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIGF4bGVbaV0uc2NhbGUod2hlZWwuc2lkZUltcHVsc2UsIHNpZGVJbXApO1xuXG4gICAgICAgICAgICAvLyBTY2FsZSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIHVwIGRpcmVjdGlvbiB3aXRoIHJvbGxJbmZsdWVuY2UuXG4gICAgICAgICAgICAvLyBJZiByb2xsSW5mbHVlbmNlIGlzIDEsIHRoZSBpbXB1bHNlIHdpbGwgYmUgYXBwbGllZCBvbiB0aGUgaGl0UG9pbnQgKGVhc3kgdG8gcm9sbCBvdmVyKSwgaWYgaXQgaXMgemVybyBpdCB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIHNhbWUgcGxhbmUgYXMgdGhlIGNlbnRlciBvZiBtYXNzIChub3QgZWFzeSB0byByb2xsIG92ZXIpLlxuICAgICAgICAgICAgY2hhc3Npc0JvZHkudmVjdG9yVG9Mb2NhbEZyYW1lKHJlbF9wb3MsIHJlbF9wb3MpO1xuICAgICAgICAgICAgcmVsX3Bvc1sneHl6J1t0aGlzLmluZGV4VXBBeGlzXV0gKj0gd2hlZWwucm9sbEluZmx1ZW5jZTtcbiAgICAgICAgICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShyZWxfcG9zLCByZWxfcG9zKTtcbiAgICAgICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShzaWRlSW1wLCByZWxfcG9zKTtcblxuICAgICAgICAgICAgLy9hcHBseSBmcmljdGlvbiBpbXB1bHNlIG9uIHRoZSBncm91bmRcbiAgICAgICAgICAgIHNpZGVJbXAuc2NhbGUoLTEsIHNpZGVJbXApO1xuICAgICAgICAgICAgZ3JvdW5kT2JqZWN0LmFwcGx5SW1wdWxzZShzaWRlSW1wLCByZWxfcG9zMik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwxID0gbmV3IFZlYzMoKTtcbnZhciBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDIgPSBuZXcgVmVjMygpO1xudmFyIGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsID0gbmV3IFZlYzMoKTtcblxuZnVuY3Rpb24gY2FsY1JvbGxpbmdGcmljdGlvbihib2R5MCwgYm9keTEsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQsIG1heEltcHVsc2UpIHtcbiAgICB2YXIgajEgPSAwO1xuICAgIHZhciBjb250YWN0UG9zV29ybGQgPSBmcmljdGlvblBvc1dvcmxkO1xuXG4gICAgLy8gdmFyIHJlbF9wb3MxID0gbmV3IFZlYzMoKTtcbiAgICAvLyB2YXIgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xuICAgIHZhciB2ZWwxID0gY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwxO1xuICAgIHZhciB2ZWwyID0gY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwyO1xuICAgIHZhciB2ZWwgPSBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDtcbiAgICAvLyBjb250YWN0UG9zV29ybGQudnN1Yihib2R5MC5wb3NpdGlvbiwgcmVsX3BvczEpO1xuICAgIC8vIGNvbnRhY3RQb3NXb3JsZC52c3ViKGJvZHkxLnBvc2l0aW9uLCByZWxfcG9zMik7XG5cbiAgICBib2R5MC5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChjb250YWN0UG9zV29ybGQsIHZlbDEpO1xuICAgIGJvZHkxLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KGNvbnRhY3RQb3NXb3JsZCwgdmVsMik7XG4gICAgdmVsMS52c3ViKHZlbDIsIHZlbCk7XG5cbiAgICB2YXIgdnJlbCA9IGZyaWN0aW9uRGlyZWN0aW9uV29ybGQuZG90KHZlbCk7XG5cbiAgICB2YXIgZGVub20wID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcihib2R5MCwgZnJpY3Rpb25Qb3NXb3JsZCwgZnJpY3Rpb25EaXJlY3Rpb25Xb3JsZCk7XG4gICAgdmFyIGRlbm9tMSA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTEsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpO1xuICAgIHZhciByZWxheGF0aW9uID0gMTtcbiAgICB2YXIgamFjRGlhZ0FCSW52ID0gcmVsYXhhdGlvbiAvIChkZW5vbTAgKyBkZW5vbTEpO1xuXG4gICAgLy8gY2FsY3VsYXRlIGogdGhhdCBtb3ZlcyB1cyB0byB6ZXJvIHJlbGF0aXZlIHZlbG9jaXR5XG4gICAgajEgPSAtdnJlbCAqIGphY0RpYWdBQkludjtcblxuICAgIGlmIChtYXhJbXB1bHNlIDwgajEpIHtcbiAgICAgICAgajEgPSBtYXhJbXB1bHNlO1xuICAgIH1cbiAgICBpZiAoajEgPCAtbWF4SW1wdWxzZSkge1xuICAgICAgICBqMSA9IC1tYXhJbXB1bHNlO1xuICAgIH1cblxuICAgIHJldHVybiBqMTtcbn1cblxudmFyIGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfcjAgPSBuZXcgVmVjMygpO1xudmFyIGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfYzAgPSBuZXcgVmVjMygpO1xudmFyIGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfdmVjID0gbmV3IFZlYzMoKTtcbnZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX20gPSBuZXcgVmVjMygpO1xuZnVuY3Rpb24gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcihib2R5LCBwb3MsIG5vcm1hbCkge1xuICAgIHZhciByMCA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfcjA7XG4gICAgdmFyIGMwID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9jMDtcbiAgICB2YXIgdmVjID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl92ZWM7XG4gICAgdmFyIG0gPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX207XG5cbiAgICBwb3MudnN1Yihib2R5LnBvc2l0aW9uLCByMCk7XG4gICAgcjAuY3Jvc3Mobm9ybWFsLCBjMCk7XG4gICAgYm9keS5pbnZJbmVydGlhV29ybGQudm11bHQoYzAsIG0pO1xuICAgIG0uY3Jvc3MocjAsIHZlYyk7XG5cbiAgICByZXR1cm4gYm9keS5pbnZNYXNzICsgbm9ybWFsLmRvdCh2ZWMpO1xufVxuXG5cbnZhciByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDEgPSBuZXcgVmVjMygpO1xudmFyIHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMiA9IG5ldyBWZWMzKCk7XG52YXIgcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwgPSBuZXcgVmVjMygpO1xuXG4vL2JpbGF0ZXJhbCBjb25zdHJhaW50IGJldHdlZW4gdHdvIGR5bmFtaWMgb2JqZWN0c1xuZnVuY3Rpb24gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbChib2R5MSwgcG9zMSwgYm9keTIsIHBvczIsIG5vcm1hbCwgaW1wdWxzZSl7XG4gICAgdmFyIG5vcm1hbExlblNxciA9IG5vcm1hbC5ub3JtMigpO1xuICAgIGlmIChub3JtYWxMZW5TcXIgPiAxLjEpe1xuICAgICAgICByZXR1cm4gMDsgLy8gbm8gaW1wdWxzZVxuICAgIH1cbiAgICAvLyB2YXIgcmVsX3BvczEgPSBuZXcgVmVjMygpO1xuICAgIC8vIHZhciByZWxfcG9zMiA9IG5ldyBWZWMzKCk7XG4gICAgLy8gcG9zMS52c3ViKGJvZHkxLnBvc2l0aW9uLCByZWxfcG9zMSk7XG4gICAgLy8gcG9zMi52c3ViKGJvZHkyLnBvc2l0aW9uLCByZWxfcG9zMik7XG5cbiAgICB2YXIgdmVsMSA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMTtcbiAgICB2YXIgdmVsMiA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMjtcbiAgICB2YXIgdmVsID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWw7XG4gICAgYm9keTEuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocG9zMSwgdmVsMSk7XG4gICAgYm9keTIuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocG9zMiwgdmVsMik7XG5cbiAgICB2ZWwxLnZzdWIodmVsMiwgdmVsKTtcblxuICAgIHZhciByZWxfdmVsID0gbm9ybWFsLmRvdCh2ZWwpO1xuXG4gICAgdmFyIGNvbnRhY3REYW1waW5nID0gMC4yO1xuICAgIHZhciBtYXNzVGVybSA9IDEgLyAoYm9keTEuaW52TWFzcyArIGJvZHkyLmludk1hc3MpO1xuICAgIHZhciBpbXB1bHNlID0gLSBjb250YWN0RGFtcGluZyAqIHJlbF92ZWwgKiBtYXNzVGVybTtcblxuICAgIHJldHVybiBpbXB1bHNlO1xufSIsInZhciBCb2R5ID0gcmVxdWlyZSgnLi9Cb2R5Jyk7XG52YXIgU3BoZXJlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NwaGVyZScpO1xudmFyIEJveCA9IHJlcXVpcmUoJy4uL3NoYXBlcy9Cb3gnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgSGluZ2VDb25zdHJhaW50ID0gcmVxdWlyZSgnLi4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmlnaWRWZWhpY2xlO1xuXG4vKipcbiAqIFNpbXBsZSB2ZWhpY2xlIGhlbHBlciBjbGFzcyB3aXRoIHNwaGVyaWNhbCByaWdpZCBib2R5IHdoZWVscy5cbiAqIEBjbGFzcyBSaWdpZFZlaGljbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5jaGFzc2lzQm9keV1cbiAqL1xuZnVuY3Rpb24gUmlnaWRWZWhpY2xlKG9wdGlvbnMpe1xuICAgIHRoaXMud2hlZWxCb2RpZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBjb29yZGluYXRlU3lzdGVtXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlU3lzdGVtID0gdHlwZW9mKG9wdGlvbnMuY29vcmRpbmF0ZVN5c3RlbSk9PT0ndW5kZWZpbmVkJyA/IG5ldyBWZWMzKDEsIDIsIDMpIDogb3B0aW9ucy5jb29yZGluYXRlU3lzdGVtLmNsb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGNoYXNzaXNCb2R5XG4gICAgICovXG4gICAgdGhpcy5jaGFzc2lzQm9keSA9IG9wdGlvbnMuY2hhc3Npc0JvZHk7XG5cbiAgICBpZighdGhpcy5jaGFzc2lzQm9keSl7XG4gICAgICAgIC8vIE5vIGNoYXNzaXMgYm9keSBnaXZlbi4gQ3JlYXRlIGl0IVxuICAgICAgICB2YXIgY2hhc3Npc1NoYXBlID0gbmV3IEJveChuZXcgVmVjMyg1LCAyLCAwLjUpKTtcbiAgICAgICAgdGhpcy5jaGFzc2lzQm9keSA9IG5ldyBCb2R5KDEsIGNoYXNzaXNTaGFwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgIHRoaXMud2hlZWxBeGVzID0gW107XG4gICAgdGhpcy53aGVlbEZvcmNlcyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIHdoZWVsXG4gKiBAbWV0aG9kIGFkZFdoZWVsXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0Zyb250V2hlZWxdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBvc2l0aW9uXSBQb3NpdGlvbiBvZiB0aGUgd2hlZWwsIGxvY2FsbHkgaW4gdGhlIGNoYXNzaXMgYm9keS5cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuZGlyZWN0aW9uXSBTbGlkZSBkaXJlY3Rpb24gb2YgdGhlIHdoZWVsIGFsb25nIHRoZSBzdXNwZW5zaW9uLlxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzXSBBeGlzIG9mIHJvdGF0aW9uIG9mIHRoZSB3aGVlbCwgbG9jYWxseSBkZWZpbmVkIGluIHRoZSBjaGFzc2lzLlxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5ib2R5XSBUaGUgd2hlZWwgYm9keS5cbiAqL1xuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB3aGVlbEJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgaWYoIXdoZWVsQm9keSl7XG4gICAgICAgIHdoZWVsQm9keSA9ICBuZXcgQm9keSgxLCBuZXcgU3BoZXJlKDEuMikpO1xuICAgIH1cbiAgICB0aGlzLndoZWVsQm9kaWVzLnB1c2god2hlZWxCb2R5KTtcbiAgICB0aGlzLndoZWVsRm9yY2VzLnB1c2goMCk7XG5cbiAgICAvLyBQb3NpdGlvbiBjb25zdHJhaW4gd2hlZWxzXG4gICAgdmFyIHplcm8gPSBuZXcgVmVjMygpO1xuICAgIHZhciBwb3NpdGlvbiA9IHR5cGVvZihvcHRpb25zLnBvc2l0aW9uKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnBvc2l0aW9uLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuXG4gICAgLy8gU2V0IHBvc2l0aW9uIGxvY2FsbHkgdG8gdGhlIGNoYXNzaXNcbiAgICB2YXIgd29ybGRQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5jaGFzc2lzQm9keS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgd29ybGRQb3NpdGlvbik7XG4gICAgd2hlZWxCb2R5LnBvc2l0aW9uLnNldCh3b3JsZFBvc2l0aW9uLngsIHdvcmxkUG9zaXRpb24ueSwgd29ybGRQb3NpdGlvbi56KTtcblxuICAgIC8vIENvbnN0cmFpbiB3aGVlbFxuICAgIHZhciBheGlzID0gdHlwZW9mKG9wdGlvbnMuYXhpcykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5heGlzLmNsb25lKCkgOiBuZXcgVmVjMygwLCAxLCAwKTtcbiAgICB0aGlzLndoZWVsQXhlcy5wdXNoKGF4aXMpO1xuXG4gICAgdmFyIGhpbmdlQ29uc3RyYWludCA9IG5ldyBIaW5nZUNvbnN0cmFpbnQodGhpcy5jaGFzc2lzQm9keSwgd2hlZWxCb2R5LCB7XG4gICAgICAgIHBpdm90QTogcG9zaXRpb24sXG4gICAgICAgIGF4aXNBOiBheGlzLFxuICAgICAgICBwaXZvdEI6IFZlYzMuWkVSTyxcbiAgICAgICAgYXhpc0I6IGF4aXMsXG4gICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKGhpbmdlQ29uc3RyYWludCk7XG5cbiAgICByZXR1cm4gdGhpcy53aGVlbEJvZGllcy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHN0ZWVyaW5nIHZhbHVlIG9mIGEgd2hlZWwuXG4gKiBAbWV0aG9kIHNldFN0ZWVyaW5nVmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKiBAdG9kbyBjaGVjayBjb29yZGluYXRlU3lzdGVtXG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0U3RlZXJpbmdWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcbiAgICAvLyBTZXQgYW5nbGUgb2YgdGhlIGhpbmdlIGF4aXNcbiAgICB2YXIgYXhpcyA9IHRoaXMud2hlZWxBeGVzW3doZWVsSW5kZXhdO1xuXG4gICAgdmFyIGMgPSBNYXRoLmNvcyh2YWx1ZSksXG4gICAgICAgIHMgPSBNYXRoLnNpbih2YWx1ZSksXG4gICAgICAgIHggPSBheGlzLngsXG4gICAgICAgIHkgPSBheGlzLnk7XG4gICAgdGhpcy5jb25zdHJhaW50c1t3aGVlbEluZGV4XS5heGlzQS5zZXQoXG4gICAgICAgIGMqeCAtcyp5LFxuICAgICAgICBzKnggK2MqeSxcbiAgICAgICAgMFxuICAgICk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIGhpbmdlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIHNldE1vdG9yU3BlZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcbiAgICB2YXIgaGluZ2VDb25zdHJhaW50ID0gdGhpcy5jb25zdHJhaW50c1t3aGVlbEluZGV4XTtcbiAgICBoaW5nZUNvbnN0cmFpbnQuZW5hYmxlTW90b3IoKTtcbiAgICBoaW5nZUNvbnN0cmFpbnQubW90b3JUYXJnZXRWZWxvY2l0eSA9IHZhbHVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBoaW5nZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBkaXNhYmxlTW90b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24od2hlZWxJbmRleCl7XG4gICAgdmFyIGhpbmdlQ29uc3RyYWludCA9IHRoaXMuY29uc3RyYWludHNbd2hlZWxJbmRleF07XG4gICAgaGluZ2VDb25zdHJhaW50LmRpc2FibGVNb3RvcigpO1xufTtcblxudmFyIHRvcnF1ZSA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogU2V0IHRoZSB3aGVlbCBmb3JjZSB0byBhcHBseSBvbiBvbmUgb2YgdGhlIHdoZWVscyBlYWNoIHRpbWUgc3RlcFxuICogQG1ldGhvZCBzZXRXaGVlbEZvcmNlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0V2hlZWxGb3JjZSA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcbiAgICB0aGlzLndoZWVsRm9yY2VzW3doZWVsSW5kZXhdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgdG9ycXVlIG9uIG9uZSBvZiB0aGUgd2hlZWxzLlxuICogQG1ldGhvZCBhcHBseVdoZWVsRm9yY2VcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5hcHBseVdoZWVsRm9yY2UgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XG4gICAgdmFyIGF4aXMgPSB0aGlzLndoZWVsQXhlc1t3aGVlbEluZGV4XTtcbiAgICB2YXIgd2hlZWxCb2R5ID0gdGhpcy53aGVlbEJvZGllc1t3aGVlbEluZGV4XTtcbiAgICB2YXIgYm9keVRvcnF1ZSA9IHdoZWVsQm9keS50b3JxdWU7XG5cbiAgICBheGlzLnNjYWxlKHZhbHVlLCB0b3JxdWUpO1xuICAgIHdoZWVsQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUodG9ycXVlLCB0b3JxdWUpO1xuICAgIGJvZHlUb3JxdWUudmFkZCh0b3JxdWUsIGJvZHlUb3JxdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIHZlaGljbGUgaW5jbHVkaW5nIGl0cyBjb25zdHJhaW50cyB0byB0aGUgd29ybGQuXG4gKiBAbWV0aG9kIGFkZFRvV29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgIHZhciBib2RpZXMgPSB0aGlzLndoZWVsQm9kaWVzLmNvbmNhdChbdGhpcy5jaGFzc2lzQm9keV0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29ybGQuYWRkQm9keShib2RpZXNbaV0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50c1tpXSk7XG4gICAgfVxuXG4gICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpKTtcbn07XG5cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHdoZWVsRm9yY2VzID0gdGhpcy53aGVlbEZvcmNlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdoZWVsRm9yY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYXBwbHlXaGVlbEZvcmNlKHdoZWVsRm9yY2VzW2ldLCBpKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIGZyb20gdGhlIHdvcmxkLlxuICogQG1ldGhvZCByZW1vdmVGcm9tV29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUucmVtb3ZlRnJvbVdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xuICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMud2hlZWxCb2RpZXMuY29uY2F0KFt0aGlzLmNoYXNzaXNCb2R5XSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3b3JsZC5yZW1vdmUoYm9kaWVzW2ldKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdvcmxkLnJlbW92ZUNvbnN0cmFpbnQoY29uc3RyYWludHNbaV0pO1xuICAgIH1cbn07XG5cbnZhciB3b3JsZEF4aXMgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEdldCBjdXJyZW50IHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgYSB3aGVlbFxuICogQG1ldGhvZCBnZXRXaGVlbFNwZWVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5nZXRXaGVlbFNwZWVkID0gZnVuY3Rpb24od2hlZWxJbmRleCl7XG4gICAgdmFyIGF4aXMgPSB0aGlzLndoZWVsQXhlc1t3aGVlbEluZGV4XTtcbiAgICB2YXIgd2hlZWxCb2R5ID0gdGhpcy53aGVlbEJvZGllc1t3aGVlbEluZGV4XTtcbiAgICB2YXIgdyA9IHdoZWVsQm9keS5hbmd1bGFyVmVsb2NpdHk7XG4gICAgdGhpcy5jaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUoYXhpcywgd29ybGRBeGlzKTtcbiAgICByZXR1cm4gdy5kb3Qod29ybGRBeGlzKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFNQSFN5c3RlbTtcblxudmFyIFNoYXBlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBQYXJ0aWNsZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9QYXJ0aWNsZScpO1xudmFyIEJvZHkgPSByZXF1aXJlKCcuLi9vYmplY3RzL0JvZHknKTtcbnZhciBNYXRlcmlhbCA9IHJlcXVpcmUoJy4uL21hdGVyaWFsL01hdGVyaWFsJyk7XG5cbi8qKlxuICogU21vb3RoZWQtcGFydGljbGUgaHlkcm9keW5hbWljcyBzeXN0ZW1cbiAqIEBjbGFzcyBTUEhTeXN0ZW1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTUEhTeXN0ZW0oKXtcbiAgICB0aGlzLnBhcnRpY2xlcyA9IFtdO1xuXHRcbiAgICAvKipcbiAgICAgKiBEZW5zaXR5IG9mIHRoZSBzeXN0ZW0gKGtnL20zKS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVuc2l0eVxuICAgICAqL1xuICAgIHRoaXMuZGVuc2l0eSA9IDE7XG5cdFxuICAgIC8qKlxuICAgICAqIERpc3RhbmNlIGJlbG93IHdoaWNoIHR3byBwYXJ0aWNsZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgbmVpZ2hib3JzLlxuICAgICAqIEl0IHNob3VsZCBiZSBhZGp1c3RlZCBzbyB0aGVyZSBhcmUgYWJvdXQgMTUtMjAgbmVpZ2hib3IgcGFydGljbGVzIHdpdGhpbiB0aGlzIHJhZGl1cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc21vb3RoaW5nUmFkaXVzXG4gICAgICovXG4gICAgdGhpcy5zbW9vdGhpbmdSYWRpdXMgPSAxO1xuICAgIHRoaXMuc3BlZWRPZlNvdW5kID0gMTtcblx0XG4gICAgLyoqXG4gICAgICogVmlzY29zaXR5IG9mIHRoZSBzeXN0ZW0uXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZpc2Nvc2l0eVxuICAgICAqL1xuICAgIHRoaXMudmlzY29zaXR5ID0gMC4wMTtcbiAgICB0aGlzLmVwcyA9IDAuMDAwMDAxO1xuXG4gICAgLy8gU3R1ZmYgQ29tcHV0ZWQgcGVyIHBhcnRpY2xlXG4gICAgdGhpcy5wcmVzc3VyZXMgPSBbXTtcbiAgICB0aGlzLmRlbnNpdGllcyA9IFtdO1xuICAgIHRoaXMubmVpZ2hib3JzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgcGFydGljbGUgdG8gdGhlIHN5c3RlbS5cbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge0JvZHl9IHBhcnRpY2xlXG4gKi9cblNQSFN5c3RlbS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocGFydGljbGUpe1xuICAgIHRoaXMucGFydGljbGVzLnB1c2gocGFydGljbGUpO1xuICAgIGlmKHRoaXMubmVpZ2hib3JzLmxlbmd0aCA8IHRoaXMucGFydGljbGVzLmxlbmd0aCl7XG4gICAgICAgIHRoaXMubmVpZ2hib3JzLnB1c2goW10pO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgcGFydGljbGUgZnJvbSB0aGUgc3lzdGVtLlxuICogQG1ldGhvZCByZW1vdmVcbiAqIEBwYXJhbSB7Qm9keX0gcGFydGljbGVcbiAqL1xuU1BIU3lzdGVtLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihwYXJ0aWNsZSl7XG4gICAgdmFyIGlkeCA9IHRoaXMucGFydGljbGVzLmluZGV4T2YocGFydGljbGUpO1xuICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICB0aGlzLnBhcnRpY2xlcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICBpZih0aGlzLm5laWdoYm9ycy5sZW5ndGggPiB0aGlzLnBhcnRpY2xlcy5sZW5ndGgpe1xuICAgICAgICAgICAgdGhpcy5uZWlnaGJvcnMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBuZWlnaGJvcnMgd2l0aGluIHNtb290aGluZyB2b2x1bWUsIHNhdmUgaW4gdGhlIGFycmF5IG5laWdoYm9yc1xuICogQG1ldGhvZCBnZXROZWlnaGJvcnNcbiAqIEBwYXJhbSB7Qm9keX0gcGFydGljbGVcbiAqIEBwYXJhbSB7QXJyYXl9IG5laWdoYm9yc1xuICovXG52YXIgU1BIU3lzdGVtX2dldE5laWdoYm9yc19kaXN0ID0gbmV3IFZlYzMoKTtcblNQSFN5c3RlbS5wcm90b3R5cGUuZ2V0TmVpZ2hib3JzID0gZnVuY3Rpb24ocGFydGljbGUsbmVpZ2hib3JzKXtcbiAgICB2YXIgTiA9IHRoaXMucGFydGljbGVzLmxlbmd0aCxcbiAgICAgICAgaWQgPSBwYXJ0aWNsZS5pZCxcbiAgICAgICAgUjIgPSB0aGlzLnNtb290aGluZ1JhZGl1cyAqIHRoaXMuc21vb3RoaW5nUmFkaXVzLFxuICAgICAgICBkaXN0ID0gU1BIU3lzdGVtX2dldE5laWdoYm9yc19kaXN0O1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhcnRpY2xlc1tpXTtcbiAgICAgICAgcC5wb3NpdGlvbi52c3ViKHBhcnRpY2xlLnBvc2l0aW9uLGRpc3QpO1xuICAgICAgICBpZihpZCE9PXAuaWQgJiYgZGlzdC5ub3JtMigpIDwgUjIpe1xuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBUZW1wIHZlY3RvcnMgZm9yIGNhbGN1bGF0aW9uXG52YXIgU1BIU3lzdGVtX3VwZGF0ZV9kaXN0ID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX2FfcHJlc3N1cmUgPSBuZXcgVmVjMygpLFxuICAgIFNQSFN5c3RlbV91cGRhdGVfYV92aXNjID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX2dyYWRXID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX3JfdmVjID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX3UgPSBuZXcgVmVjMygpOyAvLyBSZWxhdGl2ZSB2ZWxvY2l0eVxuU1BIU3lzdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBOID0gdGhpcy5wYXJ0aWNsZXMubGVuZ3RoLFxuICAgICAgICBkaXN0ID0gU1BIU3lzdGVtX3VwZGF0ZV9kaXN0LFxuICAgICAgICBjcyA9IHRoaXMuc3BlZWRPZlNvdW5kLFxuICAgICAgICBlcHMgPSB0aGlzLmVwcztcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhcnRpY2xlc1tpXTsgLy8gQ3VycmVudCBwYXJ0aWNsZVxuICAgICAgICB2YXIgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnNbaV07XG5cbiAgICAgICAgLy8gR2V0IG5laWdoYm9yc1xuICAgICAgICBuZWlnaGJvcnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5nZXROZWlnaGJvcnMocCxuZWlnaGJvcnMpO1xuICAgICAgICBuZWlnaGJvcnMucHVzaCh0aGlzLnBhcnRpY2xlc1tpXSk7IC8vIEFkZCBjdXJyZW50IHRvb1xuICAgICAgICB2YXIgbnVtTmVpZ2hib3JzID0gbmVpZ2hib3JzLmxlbmd0aDtcblxuICAgICAgICAvLyBBY2N1bXVsYXRlIGRlbnNpdHkgZm9yIHRoZSBwYXJ0aWNsZVxuICAgICAgICB2YXIgc3VtID0gMC4wO1xuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PW51bU5laWdoYm9yczsgaisrKXtcblxuICAgICAgICAgICAgLy9wcmludGYoXCJDdXJyZW50IHBhcnRpY2xlIGhhcyBwb3NpdGlvbiAlZiAlZiAlZlxcblwiLG9iamVjdHNbaWRdLnBvcy54KCksb2JqZWN0c1tpZF0ucG9zLnkoKSxvYmplY3RzW2lkXS5wb3MueigpKTtcbiAgICAgICAgICAgIHAucG9zaXRpb24udnN1YihuZWlnaGJvcnNbal0ucG9zaXRpb24sIGRpc3QpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGRpc3Qubm9ybSgpO1xuXG4gICAgICAgICAgICB2YXIgd2VpZ2h0ID0gdGhpcy53KGxlbik7XG4gICAgICAgICAgICBzdW0gKz0gbmVpZ2hib3JzW2pdLm1hc3MgKiB3ZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlXG4gICAgICAgIHRoaXMuZGVuc2l0aWVzW2ldID0gc3VtO1xuICAgICAgICB0aGlzLnByZXNzdXJlc1tpXSA9IGNzICogY3MgKiAodGhpcy5kZW5zaXRpZXNbaV0gLSB0aGlzLmRlbnNpdHkpO1xuICAgIH1cblxuICAgIC8vIEFkZCBmb3JjZXNcblxuICAgIC8vIFN1bSB0byB0aGVzZSBhY2NlbGVyYXRpb25zXG4gICAgdmFyIGFfcHJlc3N1cmU9IFNQSFN5c3RlbV91cGRhdGVfYV9wcmVzc3VyZTtcbiAgICB2YXIgYV92aXNjID0gICAgU1BIU3lzdGVtX3VwZGF0ZV9hX3Zpc2M7XG4gICAgdmFyIGdyYWRXID0gICAgIFNQSFN5c3RlbV91cGRhdGVfZ3JhZFc7XG4gICAgdmFyIHJfdmVjID0gICAgIFNQSFN5c3RlbV91cGRhdGVfcl92ZWM7XG4gICAgdmFyIHUgPSAgICAgICAgIFNQSFN5c3RlbV91cGRhdGVfdTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcblxuICAgICAgICB2YXIgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlc1tpXTtcblxuICAgICAgICBhX3ByZXNzdXJlLnNldCgwLDAsMCk7XG4gICAgICAgIGFfdmlzYy5zZXQoMCwwLDApO1xuXG4gICAgICAgIC8vIEluaXQgdmFyc1xuICAgICAgICB2YXIgUGlqO1xuICAgICAgICB2YXIgbmFibGE7XG4gICAgICAgIHZhciBWaWo7XG5cbiAgICAgICAgLy8gU3VtIHVwIGZvciBhbGwgb3RoZXIgbmVpZ2hib3JzXG4gICAgICAgIHZhciBuZWlnaGJvcnMgPSB0aGlzLm5laWdoYm9yc1tpXTtcbiAgICAgICAgdmFyIG51bU5laWdoYm9ycyA9IG5laWdoYm9ycy5sZW5ndGg7XG5cbiAgICAgICAgLy9wcmludGYoXCJOZWlnaGJvcnM6IFwiKTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT1udW1OZWlnaGJvcnM7IGorKyl7XG5cbiAgICAgICAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tqXTtcbiAgICAgICAgICAgIC8vcHJpbnRmKFwiJWQgXCIsbmopO1xuXG4gICAgICAgICAgICAvLyBHZXQgciBvbmNlIGZvciBhbGwuLlxuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24udnN1YihuZWlnaGJvci5wb3NpdGlvbixyX3ZlYyk7XG4gICAgICAgICAgICB2YXIgciA9IHJfdmVjLm5vcm0oKTtcblxuICAgICAgICAgICAgLy8gUHJlc3N1cmUgY29udHJpYnV0aW9uXG4gICAgICAgICAgICBQaWogPSAtbmVpZ2hib3IubWFzcyAqICh0aGlzLnByZXNzdXJlc1tpXSAvICh0aGlzLmRlbnNpdGllc1tpXSp0aGlzLmRlbnNpdGllc1tpXSArIGVwcykgKyB0aGlzLnByZXNzdXJlc1tqXSAvICh0aGlzLmRlbnNpdGllc1tqXSp0aGlzLmRlbnNpdGllc1tqXSArIGVwcykpO1xuICAgICAgICAgICAgdGhpcy5ncmFkdyhyX3ZlYywgZ3JhZFcpO1xuICAgICAgICAgICAgLy8gQWRkIHRvIHByZXNzdXJlIGFjY2VsZXJhdGlvblxuICAgICAgICAgICAgZ3JhZFcubXVsdChQaWogLCBncmFkVyk7XG4gICAgICAgICAgICBhX3ByZXNzdXJlLnZhZGQoZ3JhZFcsIGFfcHJlc3N1cmUpO1xuXG4gICAgICAgICAgICAvLyBWaXNjb3NpdHkgY29udHJpYnV0aW9uXG4gICAgICAgICAgICBuZWlnaGJvci52ZWxvY2l0eS52c3ViKHBhcnRpY2xlLnZlbG9jaXR5LCB1KTtcbiAgICAgICAgICAgIHUubXVsdCggMS4wIC8gKDAuMDAwMSt0aGlzLmRlbnNpdGllc1tpXSAqIHRoaXMuZGVuc2l0aWVzW2pdKSAqIHRoaXMudmlzY29zaXR5ICogbmVpZ2hib3IubWFzcyAsIHUgKTtcbiAgICAgICAgICAgIG5hYmxhID0gdGhpcy5uYWJsYXcocik7XG4gICAgICAgICAgICB1Lm11bHQobmFibGEsdSk7XG4gICAgICAgICAgICAvLyBBZGQgdG8gdmlzY29zaXR5IGFjY2VsZXJhdGlvblxuICAgICAgICAgICAgYV92aXNjLnZhZGQoIHUsIGFfdmlzYyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGZvcmNlXG4gICAgICAgIGFfdmlzYy5tdWx0KHBhcnRpY2xlLm1hc3MsIGFfdmlzYyk7XG4gICAgICAgIGFfcHJlc3N1cmUubXVsdChwYXJ0aWNsZS5tYXNzLCBhX3ByZXNzdXJlKTtcblxuICAgICAgICAvLyBBZGQgZm9yY2UgdG8gcGFydGljbGVzXG4gICAgICAgIHBhcnRpY2xlLmZvcmNlLnZhZGQoYV92aXNjLCBwYXJ0aWNsZS5mb3JjZSk7XG4gICAgICAgIHBhcnRpY2xlLmZvcmNlLnZhZGQoYV9wcmVzc3VyZSwgcGFydGljbGUuZm9yY2UpO1xuICAgIH1cbn07XG5cbi8vIENhbGN1bGF0ZSB0aGUgd2VpZ2h0IHVzaW5nIHRoZSBXKHIpIHdlaWdodGZ1bmN0aW9uXG5TUEhTeXN0ZW0ucHJvdG90eXBlLncgPSBmdW5jdGlvbihyKXtcbiAgICAvLyAzMTVcbiAgICB2YXIgaCA9IHRoaXMuc21vb3RoaW5nUmFkaXVzO1xuICAgIHJldHVybiAzMTUuMC8oNjQuMCpNYXRoLlBJKk1hdGgucG93KGgsOSkpICogTWF0aC5wb3coaCpoLXIqciwzKTtcbn07XG5cbi8vIGNhbGN1bGF0ZSBncmFkaWVudCBvZiB0aGUgd2VpZ2h0IGZ1bmN0aW9uXG5TUEhTeXN0ZW0ucHJvdG90eXBlLmdyYWR3ID0gZnVuY3Rpb24oclZlYyxyZXN1bHRWZWMpe1xuICAgIHZhciByID0gclZlYy5ub3JtKCksXG4gICAgICAgIGggPSB0aGlzLnNtb290aGluZ1JhZGl1cztcbiAgICByVmVjLm11bHQoOTQ1LjAvKDMyLjAqTWF0aC5QSSpNYXRoLnBvdyhoLDkpKSAqIE1hdGgucG93KChoKmgtcipyKSwyKSAsIHJlc3VsdFZlYyk7XG59O1xuXG4vLyBDYWxjdWxhdGUgbmFibGEoVylcblNQSFN5c3RlbS5wcm90b3R5cGUubmFibGF3ID0gZnVuY3Rpb24ocil7XG4gICAgdmFyIGggPSB0aGlzLnNtb290aGluZ1JhZGl1cztcbiAgICB2YXIgbmFibGEgPSA5NDUuMC8oMzIuMCpNYXRoLlBJKk1hdGgucG93KGgsOSkpICogKGgqaC1yKnIpKig3KnIqciAtIDMqaCpoKTtcbiAgICByZXR1cm4gbmFibGE7XG59O1xuIiwidmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpbmc7XG5cbi8qKlxuICogQSBzcHJpbmcsIGNvbm5lY3RpbmcgdHdvIGJvZGllcy5cbiAqXG4gKiBAY2xhc3MgU3ByaW5nXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXN0TGVuZ3RoXSAgIEEgbnVtYmVyID4gMC4gRGVmYXVsdDogMVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzc10gICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMTAwXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ10gICAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxXG4gKiBAcGFyYW0ge1ZlYzN9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMud29ybGRBbmNob3JCXVxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiBsb2NhbCBib2R5IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxuICovXG5mdW5jdGlvbiBTcHJpbmcoYm9keUEsYm9keUIsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBSZXN0IGxlbmd0aCBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0TGVuZ3RoXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RMZW5ndGggPSB0eXBlb2Yob3B0aW9ucy5yZXN0TGVuZ3RoKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmVzdExlbmd0aCA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9IG9wdGlvbnMuc3RpZmZuZXNzIHx8IDEwMDtcblxuICAgIC8qKlxuICAgICAqIERhbXBpbmcgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgZGFtcGluZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kYW1waW5nID0gb3B0aW9ucy5kYW1waW5nIHx8IDE7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBjb25uZWN0ZWQgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgY29ubmVjdGVkIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QSBpbiBsb2NhbCBib2R5QSBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QiBpbiBsb2NhbCBib2R5QiBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckEpe1xuICAgICAgICB0aGlzLmxvY2FsQW5jaG9yQS5jb3B5KG9wdGlvbnMubG9jYWxBbmNob3JBKTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckIpe1xuICAgICAgICB0aGlzLmxvY2FsQW5jaG9yQi5jb3B5KG9wdGlvbnMubG9jYWxBbmNob3JCKTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy53b3JsZEFuY2hvckEpe1xuICAgICAgICB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMud29ybGRBbmNob3JCKXtcbiAgICAgICAgdGhpcy5zZXRXb3JsZEFuY2hvckIob3B0aW9ucy53b3JsZEFuY2hvckIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBzZXRXb3JsZEFuY2hvckFcbiAqIEBwYXJhbSB7VmVjM30gd29ybGRBbmNob3JBXG4gKi9cblNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24od29ybGRBbmNob3JBKXtcbiAgICB0aGlzLmJvZHlBLnBvaW50VG9Mb2NhbEZyYW1lKHdvcmxkQW5jaG9yQSx0aGlzLmxvY2FsQW5jaG9yQSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtWZWMzfSB3b3JsZEFuY2hvckJcbiAqL1xuU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbih3b3JsZEFuY2hvckIpe1xuICAgIHRoaXMuYm9keUIucG9pbnRUb0xvY2FsRnJhbWUod29ybGRBbmNob3JCLHRoaXMubG9jYWxBbmNob3JCKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JBXG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXG4gKi9cblNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLmJvZHlBLnBvaW50VG9Xb3JsZEZyYW1lKHRoaXMubG9jYWxBbmNob3JBLHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIGdldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtWZWMzfSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxuICovXG5TcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdGhpcy5ib2R5Qi5wb2ludFRvV29ybGRGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQixyZXN1bHQpO1xufTtcblxudmFyIGFwcGx5Rm9yY2VfciA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2Vfcl91bml0ID0gICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfdSA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfZiA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBID0gICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCID0gICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmkgPSAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmogPSAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmlfeF9mID0gICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmpfeF9mID0gICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfdG1wID0gICAgICAgICAgICBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqL1xuU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5kYW1waW5nLFxuICAgICAgICBsID0gdGhpcy5yZXN0TGVuZ3RoLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgciA9IGFwcGx5Rm9yY2VfcixcbiAgICAgICAgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQsXG4gICAgICAgIHUgPSBhcHBseUZvcmNlX3UsXG4gICAgICAgIGYgPSBhcHBseUZvcmNlX2YsXG4gICAgICAgIHRtcCA9IGFwcGx5Rm9yY2VfdG1wO1xuXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBLFxuICAgICAgICB3b3JsZEFuY2hvckIgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQixcbiAgICAgICAgcmkgPSBhcHBseUZvcmNlX3JpLFxuICAgICAgICByaiA9IGFwcGx5Rm9yY2VfcmosXG4gICAgICAgIHJpX3hfZiA9IGFwcGx5Rm9yY2VfcmlfeF9mLFxuICAgICAgICByal94X2YgPSBhcHBseUZvcmNlX3JqX3hfZjtcblxuICAgIC8vIEdldCB3b3JsZCBhbmNob3JzXG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xuXG4gICAgLy8gR2V0IG9mZnNldCBwb2ludHNcbiAgICB3b3JsZEFuY2hvckEudnN1Yihib2R5QS5wb3NpdGlvbixyaSk7XG4gICAgd29ybGRBbmNob3JCLnZzdWIoYm9keUIucG9zaXRpb24scmopO1xuXG4gICAgLy8gQ29tcHV0ZSBkaXN0YW5jZSB2ZWN0b3IgYmV0d2VlbiB3b3JsZCBhbmNob3IgcG9pbnRzXG4gICAgd29ybGRBbmNob3JCLnZzdWIod29ybGRBbmNob3JBLHIpO1xuICAgIHZhciBybGVuID0gci5ub3JtKCk7XG4gICAgcl91bml0LmNvcHkocik7XG4gICAgcl91bml0Lm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gQ29tcHV0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBvZiB0aGUgYW5jaG9yIHBvaW50cywgdVxuICAgIGJvZHlCLnZlbG9jaXR5LnZzdWIoYm9keUEudmVsb2NpdHksdSk7XG4gICAgLy8gQWRkIHJvdGF0aW9uYWwgdmVsb2NpdHlcblxuICAgIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eS5jcm9zcyhyaix0bXApO1xuICAgIHUudmFkZCh0bXAsdSk7XG4gICAgYm9keUEuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHJpLHRtcCk7XG4gICAgdS52c3ViKHRtcCx1KTtcblxuICAgIC8vIEYgPSAtIGsgKiAoIHggLSBMICkgLSBEICogKCB1IClcbiAgICByX3VuaXQubXVsdCgtayoocmxlbi1sKSAtIGQqdS5kb3Qocl91bml0KSwgZik7XG5cbiAgICAvLyBBZGQgZm9yY2VzIHRvIGJvZGllc1xuICAgIGJvZHlBLmZvcmNlLnZzdWIoZixib2R5QS5mb3JjZSk7XG4gICAgYm9keUIuZm9yY2UudmFkZChmLGJvZHlCLmZvcmNlKTtcblxuICAgIC8vIEFuZ3VsYXIgZm9yY2VcbiAgICByaS5jcm9zcyhmLHJpX3hfZik7XG4gICAgcmouY3Jvc3MoZixyal94X2YpO1xuICAgIGJvZHlBLnRvcnF1ZS52c3ViKHJpX3hfZixib2R5QS50b3JxdWUpO1xuICAgIGJvZHlCLnRvcnF1ZS52YWRkKHJqX3hfZixib2R5Qi50b3JxdWUpO1xufTtcbiIsInZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcbnZhciBSYXljYXN0UmVzdWx0ID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKTtcbnZhciBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2hlZWxJbmZvO1xuXG4vKipcbiAqIEBjbGFzcyBXaGVlbEluZm9cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICpcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGRdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmRpcmVjdGlvbkxvY2FsXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5kaXJlY3Rpb25Xb3JsZF1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhsZUxvY2FsXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGxlV29ybGRdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblJlc3RMZW5ndGg9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoPTJdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmFkaXVzPTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblN0aWZmbmVzcz0xMDBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ0NvbXByZXNzaW9uPTEwXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmdSZWxheGF0aW9uPTEwXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmZyaWN0aW9uU2xpcD0xMDAwMF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGVlcmluZz0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvdGF0aW9uPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGVsdGFSb3RhdGlvbj0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvbGxJbmZsdWVuY2U9MC4wMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTdXNwZW5zaW9uRm9yY2VdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzRnJvbnRXaGVlbD10cnVlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbj0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvbkZvcmNlPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2tpZEluZm89MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uTGVuZ3RoPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4U3VzcGVuc2lvblRyYXZlbD0xXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkPWZhbHNlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ9LTAuMV1cbiAqL1xuZnVuY3Rpb24gV2hlZWxJbmZvKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgICAgY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkOiBuZXcgVmVjMygpLFxuICAgICAgICBkaXJlY3Rpb25Mb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgICAgZGlyZWN0aW9uV29ybGQ6IG5ldyBWZWMzKCksXG4gICAgICAgIGF4bGVMb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgICAgYXhsZVdvcmxkOiBuZXcgVmVjMygpLFxuICAgICAgICBzdXNwZW5zaW9uUmVzdExlbmd0aDogMSxcbiAgICAgICAgc3VzcGVuc2lvbk1heExlbmd0aDogMixcbiAgICAgICAgcmFkaXVzOiAxLFxuICAgICAgICBzdXNwZW5zaW9uU3RpZmZuZXNzOiAxMDAsXG4gICAgICAgIGRhbXBpbmdDb21wcmVzc2lvbjogMTAsXG4gICAgICAgIGRhbXBpbmdSZWxheGF0aW9uOiAxMCxcbiAgICAgICAgZnJpY3Rpb25TbGlwOiAxMDAwMCxcbiAgICAgICAgc3RlZXJpbmc6IDAsXG4gICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICBkZWx0YVJvdGF0aW9uOiAwLFxuICAgICAgICByb2xsSW5mbHVlbmNlOiAwLjAxLFxuICAgICAgICBtYXhTdXNwZW5zaW9uRm9yY2U6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIGlzRnJvbnRXaGVlbDogdHJ1ZSxcbiAgICAgICAgY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uOiAxLFxuICAgICAgICBzdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eTogMCxcbiAgICAgICAgc3VzcGVuc2lvbkZvcmNlOiAwLFxuICAgICAgICBza2lkSW5mbzogMCxcbiAgICAgICAgc3VzcGVuc2lvbkxlbmd0aDogMCxcbiAgICAgICAgbWF4U3VzcGVuc2lvblRyYXZlbDogMSxcbiAgICAgICAgdXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDogZmFsc2UsXG4gICAgICAgIGN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ6IC0wLjFcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE1heCB0cmF2ZWwgZGlzdGFuY2Ugb2YgdGhlIHN1c3BlbnNpb24sIGluIG1ldGVycy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4U3VzcGVuc2lvblRyYXZlbFxuICAgICAqL1xuICAgIHRoaXMubWF4U3VzcGVuc2lvblRyYXZlbCA9IG9wdGlvbnMubWF4U3VzcGVuc2lvblRyYXZlbDtcblxuICAgIC8qKlxuICAgICAqIFNwZWVkIHRvIGFwcGx5IHRvIHRoZSB3aGVlbCByb3RhdGlvbiB3aGVuIHRoZSB3aGVlbCBpcyBzbGlkaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkXG4gICAgICovXG4gICAgdGhpcy5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQgc2hvdWxkIGJlIHVzZWQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkXG4gICAgICovXG4gICAgdGhpcy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzbGlkaW5nXG4gICAgICovXG4gICAgdGhpcy5zbGlkaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0aW9uIHBvaW50LCBkZWZpbmVkIGxvY2FsbHkgaW4gdGhlIGNoYXNzaXMgYm9keSBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbFxuICAgICAqL1xuICAgIHRoaXMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsID0gb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwuY2xvbmUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkXG4gICAgICovXG4gICAgdGhpcy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQgPSBvcHRpb25zLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBkaXJlY3Rpb25Mb2NhbFxuICAgICAqL1xuICAgIHRoaXMuZGlyZWN0aW9uTG9jYWwgPSBvcHRpb25zLmRpcmVjdGlvbkxvY2FsLmNsb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGRpcmVjdGlvbldvcmxkXG4gICAgICovXG4gICAgdGhpcy5kaXJlY3Rpb25Xb3JsZCA9IG9wdGlvbnMuZGlyZWN0aW9uV29ybGQuY2xvbmUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhsZUxvY2FsXG4gICAgICovXG4gICAgdGhpcy5heGxlTG9jYWwgPSBvcHRpb25zLmF4bGVMb2NhbC5jbG9uZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBheGxlV29ybGRcbiAgICAgKi9cbiAgICB0aGlzLmF4bGVXb3JsZCA9IG9wdGlvbnMuYXhsZVdvcmxkLmNsb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvblJlc3RMZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLnN1c3BlbnNpb25SZXN0TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uUmVzdExlbmd0aDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uTWF4TGVuZ3RoXG4gICAgICovXG4gICAgdGhpcy5zdXNwZW5zaW9uTWF4TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGl1c1xuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvblN0aWZmbmVzc1xuICAgICAqL1xuICAgIHRoaXMuc3VzcGVuc2lvblN0aWZmbmVzcyA9IG9wdGlvbnMuc3VzcGVuc2lvblN0aWZmbmVzcztcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYW1waW5nQ29tcHJlc3Npb25cbiAgICAgKi9cbiAgICB0aGlzLmRhbXBpbmdDb21wcmVzc2lvbiA9IG9wdGlvbnMuZGFtcGluZ0NvbXByZXNzaW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhbXBpbmdSZWxheGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5kYW1waW5nUmVsYXhhdGlvbiA9IG9wdGlvbnMuZGFtcGluZ1JlbGF4YXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZnJpY3Rpb25TbGlwXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblNsaXAgPSBvcHRpb25zLmZyaWN0aW9uU2xpcDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGVlcmluZ1xuICAgICAqL1xuICAgIHRoaXMuc3RlZXJpbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUm90YXRpb24gdmFsdWUsIGluIHJhZGlhbnMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJvdGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVsdGFSb3RhdGlvblxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFSb3RhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcm9sbEluZmx1ZW5jZVxuICAgICAqL1xuICAgIHRoaXMucm9sbEluZmx1ZW5jZSA9IG9wdGlvbnMucm9sbEluZmx1ZW5jZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhTdXNwZW5zaW9uRm9yY2VcbiAgICAgKi9cbiAgICB0aGlzLm1heFN1c3BlbnNpb25Gb3JjZSA9IG9wdGlvbnMubWF4U3VzcGVuc2lvbkZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZ2luZUZvcmNlXG4gICAgICovXG4gICAgdGhpcy5lbmdpbmVGb3JjZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYnJha2VcbiAgICAgKi9cbiAgICB0aGlzLmJyYWtlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpc0Zyb250V2hlZWxcbiAgICAgKi9cbiAgICB0aGlzLmlzRnJvbnRXaGVlbCA9IG9wdGlvbnMuaXNGcm9udFdoZWVsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvblxuICAgICAqL1xuICAgIHRoaXMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eVxuICAgICAqL1xuICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25Gb3JjZVxuICAgICAqL1xuICAgIHRoaXMuc3VzcGVuc2lvbkZvcmNlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBza2lkSW5mb1xuICAgICAqL1xuICAgIHRoaXMuc2tpZEluZm8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25MZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLnN1c3BlbnNpb25MZW5ndGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZGVJbXB1bHNlXG4gICAgICovXG4gICAgdGhpcy5zaWRlSW1wdWxzZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZm9yd2FyZEltcHVsc2VcbiAgICAgKi9cbiAgICB0aGlzLmZvcndhcmRJbXB1bHNlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHQgZnJvbSByYXljYXN0aW5nXG4gICAgICogQHByb3BlcnR5IHtSYXljYXN0UmVzdWx0fSByYXljYXN0UmVzdWx0XG4gICAgICovXG4gICAgdGhpcy5yYXljYXN0UmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTtcblxuICAgIC8qKlxuICAgICAqIFdoZWVsIHdvcmxkIHRyYW5zZm9ybVxuICAgICAqIEBwcm9wZXJ0eSB7VHJhbnNmb3JtfSB3b3JsZFRyYW5zZm9ybVxuICAgICAqL1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSW5Db250YWN0XG4gICAgICovXG4gICAgdGhpcy5pc0luQ29udGFjdCA9IGZhbHNlO1xufVxuXG52YXIgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIHJlbHBvcyA9IG5ldyBWZWMzKCk7XG52YXIgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQgPSBuZXcgVmVjMygpO1xuV2hlZWxJbmZvLnByb3RvdHlwZS51cGRhdGVXaGVlbCA9IGZ1bmN0aW9uKGNoYXNzaXMpe1xuICAgIHZhciByYXljYXN0UmVzdWx0ID0gdGhpcy5yYXljYXN0UmVzdWx0O1xuXG4gICAgaWYgKHRoaXMuaXNJbkNvbnRhY3Qpe1xuICAgICAgICB2YXIgcHJvamVjdD0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QocmF5Y2FzdFJlc3VsdC5kaXJlY3Rpb25Xb3JsZCk7XG4gICAgICAgIHJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXMucG9zaXRpb24sIHJlbHBvcyk7XG4gICAgICAgIGNoYXNzaXMuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocmVscG9zLCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCk7XG4gICAgICAgIHZhciBwcm9qVmVsID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ICk7XG4gICAgICAgIGlmIChwcm9qZWN0ID49IC0wLjEpIHtcbiAgICAgICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMCAvIDAuMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnYgPSAtMSAvIHByb2plY3Q7XG4gICAgICAgICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gcHJvalZlbCAqIGludjtcbiAgICAgICAgICAgIHRoaXMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gaW52O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgaW4gY29udGFjdCA6IHBvc2l0aW9uIHdoZWVsIGluIGEgbmljZSAocmVzdCBsZW5ndGgpIHBvc2l0aW9uXG4gICAgICAgIHJheWNhc3RSZXN1bHQuc3VzcGVuc2lvbkxlbmd0aCA9IHRoaXMuc3VzcGVuc2lvblJlc3RMZW5ndGg7XG4gICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7XG4gICAgICAgIHJheWNhc3RSZXN1bHQuZGlyZWN0aW9uV29ybGQuc2NhbGUoLTEsIHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMDtcbiAgICB9XG59OyIsIm1vZHVsZS5leHBvcnRzID0gQm94O1xuXG52YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIENvbnZleFBvbHloZWRyb24gPSByZXF1aXJlKCcuL0NvbnZleFBvbHloZWRyb24nKTtcblxuLyoqXG4gKiBBIDNkIGJveCBzaGFwZS5cbiAqIEBjbGFzcyBCb3hcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtWZWMzfSBoYWxmRXh0ZW50c1xuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqL1xuZnVuY3Rpb24gQm94KGhhbGZFeHRlbnRzKXtcbiAgICBTaGFwZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuQk9YXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaGFsZkV4dGVudHNcbiAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgKi9cbiAgICB0aGlzLmhhbGZFeHRlbnRzID0gaGFsZkV4dGVudHM7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IHRoZSBjb250YWN0IGdlbmVyYXRvciB0byBtYWtlIGNvbnRhY3RzIHdpdGggb3RoZXIgY29udmV4IHBvbHloZWRyYSBmb3IgZXhhbXBsZVxuICAgICAqIEBwcm9wZXJ0eSBjb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb25cbiAgICAgKiBAdHlwZSB7Q29udmV4UG9seWhlZHJvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiA9IG51bGw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbigpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcbn1cbkJveC5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3g7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgbG9jYWwgY29udmV4IHBvbHloZWRyb24gcmVwcmVzZW50YXRpb24gdXNlZCBmb3Igc29tZSBjb2xsaXNpb25zLlxuICogQG1ldGhvZCB1cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb25cbiAqL1xuQm94LnByb3RvdHlwZS51cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24gPSBmdW5jdGlvbigpe1xuICAgIHZhciBzeCA9IHRoaXMuaGFsZkV4dGVudHMueDtcbiAgICB2YXIgc3kgPSB0aGlzLmhhbGZFeHRlbnRzLnk7XG4gICAgdmFyIHN6ID0gdGhpcy5oYWxmRXh0ZW50cy56O1xuICAgIHZhciBWID0gVmVjMztcblxuICAgIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgbmV3IFYoLXN4LC1zeSwtc3opLFxuICAgICAgICBuZXcgViggc3gsLXN5LC1zeiksXG4gICAgICAgIG5ldyBWKCBzeCwgc3ksLXN6KSxcbiAgICAgICAgbmV3IFYoLXN4LCBzeSwtc3opLFxuICAgICAgICBuZXcgVigtc3gsLXN5LCBzeiksXG4gICAgICAgIG5ldyBWKCBzeCwtc3ksIHN6KSxcbiAgICAgICAgbmV3IFYoIHN4LCBzeSwgc3opLFxuICAgICAgICBuZXcgVigtc3gsIHN5LCBzeilcbiAgICBdO1xuXG4gICAgdmFyIGluZGljZXMgPSBbXG4gICAgICAgIFszLDIsMSwwXSwgLy8gLXpcbiAgICAgICAgWzQsNSw2LDddLCAvLyArelxuICAgICAgICBbNSw0LDAsMV0sIC8vIC15XG4gICAgICAgIFsyLDMsNyw2XSwgLy8gK3lcbiAgICAgICAgWzAsNCw3LDNdLCAvLyAteFxuICAgICAgICBbMSwyLDYsNV0sIC8vICt4XG4gICAgXTtcblxuICAgIHZhciBheGVzID0gW1xuICAgICAgICBuZXcgVigwLCAwLCAxKSxcbiAgICAgICAgbmV3IFYoMCwgMSwgMCksXG4gICAgICAgIG5ldyBWKDEsIDAsIDApXG4gICAgXTtcblxuICAgIHZhciBoID0gbmV3IENvbnZleFBvbHloZWRyb24odmVydGljZXMsIGluZGljZXMpO1xuICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gaDtcbiAgICBoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5Cb3gucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsdGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcbiAgICBCb3guY2FsY3VsYXRlSW5lcnRpYSh0aGlzLmhhbGZFeHRlbnRzLCBtYXNzLCB0YXJnZXQpO1xuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5Cb3guY2FsY3VsYXRlSW5lcnRpYSA9IGZ1bmN0aW9uKGhhbGZFeHRlbnRzLG1hc3MsdGFyZ2V0KXtcbiAgICB2YXIgZSA9IGhhbGZFeHRlbnRzO1xuICAgIHRhcmdldC54ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoICAgMiplLnkqMiplLnkgKyAyKmUueioyKmUueiApO1xuICAgIHRhcmdldC55ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoICAgMiplLngqMiplLnggKyAyKmUueioyKmUueiApO1xuICAgIHRhcmdldC56ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoICAgMiplLnkqMiplLnkgKyAyKmUueCoyKmUueCApO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGJveCA2IHNpZGUgbm9ybWFsc1xuICogQG1ldGhvZCBnZXRTaWRlTm9ybWFsc1xuICogQHBhcmFtIHthcnJheX0gICAgICBzaXhUYXJnZXRWZWN0b3JzIEFuIGFycmF5IG9mIDYgdmVjdG9ycywgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBzaWRlIG5vcm1hbHMgaW4uXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXQgICAgICAgICAgICAgT3JpZW50YXRpb24gdG8gYXBwbHkgdG8gdGhlIG5vcm1hbCB2ZWN0b3JzLiBJZiBub3QgcHJvdmlkZWQsIHRoZSB2ZWN0b3JzIHdpbGwgYmUgaW4gcmVzcGVjdCB0byB0aGUgbG9jYWwgZnJhbWUuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuQm94LnByb3RvdHlwZS5nZXRTaWRlTm9ybWFscyA9IGZ1bmN0aW9uKHNpeFRhcmdldFZlY3RvcnMscXVhdCl7XG4gICAgdmFyIHNpZGVzID0gc2l4VGFyZ2V0VmVjdG9ycztcbiAgICB2YXIgZXggPSB0aGlzLmhhbGZFeHRlbnRzO1xuICAgIHNpZGVzWzBdLnNldCggIGV4LngsICAgICAwLCAgICAgMCk7XG4gICAgc2lkZXNbMV0uc2V0KCAgICAgMCwgIGV4LnksICAgICAwKTtcbiAgICBzaWRlc1syXS5zZXQoICAgICAwLCAgICAgMCwgIGV4LnopO1xuICAgIHNpZGVzWzNdLnNldCggLWV4LngsICAgICAwLCAgICAgMCk7XG4gICAgc2lkZXNbNF0uc2V0KCAgICAgMCwgLWV4LnksICAgICAwKTtcbiAgICBzaWRlc1s1XS5zZXQoICAgICAwLCAgICAgMCwgLWV4LnopO1xuXG4gICAgaWYocXVhdCE9PXVuZGVmaW5lZCl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09c2lkZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgcXVhdC52bXVsdChzaWRlc1tpXSxzaWRlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2lkZXM7XG59O1xuXG5Cb3gucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIDguMCAqIHRoaXMuaGFsZkV4dGVudHMueCAqIHRoaXMuaGFsZkV4dGVudHMueSAqIHRoaXMuaGFsZkV4dGVudHMuejtcbn07XG5cbkJveC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSB0aGlzLmhhbGZFeHRlbnRzLm5vcm0oKTtcbn07XG5cbnZhciB3b3JsZENvcm5lclRlbXBQb3MgPSBuZXcgVmVjMygpO1xudmFyIHdvcmxkQ29ybmVyVGVtcE5lZyA9IG5ldyBWZWMzKCk7XG5Cb3gucHJvdG90eXBlLmZvckVhY2hXb3JsZENvcm5lciA9IGZ1bmN0aW9uKHBvcyxxdWF0LGNhbGxiYWNrKXtcblxuICAgIHZhciBlID0gdGhpcy5oYWxmRXh0ZW50cztcbiAgICB2YXIgY29ybmVycyA9IFtbICBlLngsICBlLnksICBlLnpdLFxuICAgICAgICAgICAgICAgICAgIFsgLWUueCwgIGUueSwgIGUuel0sXG4gICAgICAgICAgICAgICAgICAgWyAtZS54LCAtZS55LCAgZS56XSxcbiAgICAgICAgICAgICAgICAgICBbIC1lLngsIC1lLnksIC1lLnpdLFxuICAgICAgICAgICAgICAgICAgIFsgIGUueCwgLWUueSwgLWUuel0sXG4gICAgICAgICAgICAgICAgICAgWyAgZS54LCAgZS55LCAtZS56XSxcbiAgICAgICAgICAgICAgICAgICBbIC1lLngsICBlLnksIC1lLnpdLFxuICAgICAgICAgICAgICAgICAgIFsgIGUueCwgLWUueSwgIGUuel1dO1xuICAgIGZvcih2YXIgaT0wOyBpPGNvcm5lcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICB3b3JsZENvcm5lclRlbXBQb3Muc2V0KGNvcm5lcnNbaV1bMF0sY29ybmVyc1tpXVsxXSxjb3JuZXJzW2ldWzJdKTtcbiAgICAgICAgcXVhdC52bXVsdCh3b3JsZENvcm5lclRlbXBQb3Msd29ybGRDb3JuZXJUZW1wUG9zKTtcbiAgICAgICAgcG9zLnZhZGQod29ybGRDb3JuZXJUZW1wUG9zLHdvcmxkQ29ybmVyVGVtcFBvcyk7XG4gICAgICAgIGNhbGxiYWNrKHdvcmxkQ29ybmVyVGVtcFBvcy54LFxuICAgICAgICAgICAgICAgICB3b3JsZENvcm5lclRlbXBQb3MueSxcbiAgICAgICAgICAgICAgICAgd29ybGRDb3JuZXJUZW1wUG9zLnopO1xuICAgIH1cbn07XG5cbnZhciB3b3JsZENvcm5lcnNUZW1wID0gW1xuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKVxuXTtcbkJveC5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLHF1YXQsbWluLG1heCl7XG5cbiAgICB2YXIgZSA9IHRoaXMuaGFsZkV4dGVudHM7XG4gICAgd29ybGRDb3JuZXJzVGVtcFswXS5zZXQoZS54LCBlLnksIGUueik7XG4gICAgd29ybGRDb3JuZXJzVGVtcFsxXS5zZXQoLWUueCwgIGUueSwgZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzJdLnNldCgtZS54LCAtZS55LCBlLnopO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbM10uc2V0KC1lLngsIC1lLnksIC1lLnopO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbNF0uc2V0KGUueCwgLWUueSwgLWUueik7XG4gICAgd29ybGRDb3JuZXJzVGVtcFs1XS5zZXQoZS54LCAgZS55LCAtZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzZdLnNldCgtZS54LCAgZS55LCAtZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzddLnNldChlLngsIC1lLnksICBlLnopO1xuXG4gICAgdmFyIHdjID0gd29ybGRDb3JuZXJzVGVtcFswXTtcbiAgICBxdWF0LnZtdWx0KHdjLCB3Yyk7XG4gICAgcG9zLnZhZGQod2MsIHdjKTtcbiAgICBtYXguY29weSh3Yyk7XG4gICAgbWluLmNvcHkod2MpO1xuICAgIGZvcih2YXIgaT0xOyBpPDg7IGkrKyl7XG4gICAgICAgIHZhciB3YyA9IHdvcmxkQ29ybmVyc1RlbXBbaV07XG4gICAgICAgIHF1YXQudm11bHQod2MsIHdjKTtcbiAgICAgICAgcG9zLnZhZGQod2MsIHdjKTtcbiAgICAgICAgdmFyIHggPSB3Yy54O1xuICAgICAgICB2YXIgeSA9IHdjLnk7XG4gICAgICAgIHZhciB6ID0gd2MuejtcbiAgICAgICAgaWYoeCA+IG1heC54KXtcbiAgICAgICAgICAgIG1heC54ID0geDtcbiAgICAgICAgfVxuICAgICAgICBpZih5ID4gbWF4Lnkpe1xuICAgICAgICAgICAgbWF4LnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGlmKHogPiBtYXgueil7XG4gICAgICAgICAgICBtYXgueiA9IHo7XG4gICAgICAgIH1cblxuICAgICAgICBpZih4IDwgbWluLngpe1xuICAgICAgICAgICAgbWluLnggPSB4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHkgPCBtaW4ueSl7XG4gICAgICAgICAgICBtaW4ueSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeiA8IG1pbi56KXtcbiAgICAgICAgICAgIG1pbi56ID0gejtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCBlYWNoIGF4aXMgbWF4XG4gICAgLy8gbWluLnNldChJbmZpbml0eSxJbmZpbml0eSxJbmZpbml0eSk7XG4gICAgLy8gbWF4LnNldCgtSW5maW5pdHksLUluZmluaXR5LC1JbmZpbml0eSk7XG4gICAgLy8gdGhpcy5mb3JFYWNoV29ybGRDb3JuZXIocG9zLHF1YXQsZnVuY3Rpb24oeCx5LHope1xuICAgIC8vICAgICBpZih4ID4gbWF4Lngpe1xuICAgIC8vICAgICAgICAgbWF4LnggPSB4O1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmKHkgPiBtYXgueSl7XG4gICAgLy8gICAgICAgICBtYXgueSA9IHk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgaWYoeiA+IG1heC56KXtcbiAgICAvLyAgICAgICAgIG1heC56ID0gejtcbiAgICAvLyAgICAgfVxuXG4gICAgLy8gICAgIGlmKHggPCBtaW4ueCl7XG4gICAgLy8gICAgICAgICBtaW4ueCA9IHg7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgaWYoeSA8IG1pbi55KXtcbiAgICAvLyAgICAgICAgIG1pbi55ID0geTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZih6IDwgbWluLnope1xuICAgIC8vICAgICAgICAgbWluLnogPSB6O1xuICAgIC8vICAgICB9XG4gICAgLy8gfSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBDb252ZXhQb2x5aGVkcm9uO1xuXG52YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi9tYXRoL1RyYW5zZm9ybScpO1xuXG4vKipcbiAqIEEgc2V0IG9mIHBvbHlnb25zIGRlc2NyaWJpbmcgYSBjb252ZXggc2hhcGUuXG4gKiBAY2xhc3MgQ29udmV4UG9seWhlZHJvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGRlc2NyaXB0aW9uIFRoZSBzaGFwZSBNVVNUIGJlIGNvbnZleCBmb3IgdGhlIGNvZGUgdG8gd29yayBwcm9wZXJseS4gTm8gcG9seWdvbnMgbWF5IGJlIGNvcGxhbmFyIChjb250YWluZWRcbiAqIGluIHRoZSBzYW1lIDNEIHBsYW5lKSwgaW5zdGVhZCB0aGVzZSBzaG91bGQgYmUgbWVyZ2VkIGludG8gb25lIHBvbHlnb24uXG4gKlxuICogQHBhcmFtIHthcnJheX0gcG9pbnRzIEFuIGFycmF5IG9mIFZlYzMnc1xuICogQHBhcmFtIHthcnJheX0gZmFjZXMgQXJyYXkgb2YgaW50ZWdlciBhcnJheXMsIGRlc2NyaWJpbmcgd2hpY2ggdmVydGljZXMgdGhhdCBpcyBpbmNsdWRlZCBpbiBlYWNoIGZhY2UuXG4gKlxuICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW8gKG9yaWdpbmFsIGF1dGhvciwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvL3RocmVlLmpzL2NvbW1pdC84NTAyNmYwYzc2OWU0MDAwMTQ4YTY3ZDQ1YTllOWI5YzUxMDg4MzZmKVxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxuICogQHNlZSBodHRwOi8vd3d3LmFsdGRldmJsb2dhZGF5LmNvbS8yMDExLzA1LzEzL2NvbnRhY3QtZ2VuZXJhdGlvbi1iZXR3ZWVuLTNkLWNvbnZleC1tZXNoZXMvXG4gKiBAc2VlIGh0dHA6Ly9idWxsZXQuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL3NyYy9CdWxsZXRDb2xsaXNpb24vTmFycm93UGhhc2VDb2xsaXNpb24vYnRQb2x5aGVkcmFsQ29udGFjdENsaXBwaW5nLmNwcFxuICpcbiAqIEB0b2RvIE1vdmUgdGhlIGNsaXBwaW5nIGZ1bmN0aW9ucyB0byBDb250YWN0R2VuZXJhdG9yP1xuICogQHRvZG8gQXV0b21hdGljYWxseSBtZXJnZSBjb3BsYW5hciBwb2x5Z29ucyBpbiBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gQ29udmV4UG9seWhlZHJvbihwb2ludHMsIGZhY2VzLCB1bmlxdWVBeGVzKSB7XG4gICAgU2hhcGUuY2FsbCh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST05cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIFZlYzNcbiAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNlcyA9IHBvaW50c3x8W107XG5cbiAgICB0aGlzLndvcmxkVmVydGljZXMgPSBbXTsgLy8gV29ybGQgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiAudmVydGljZXNcbiAgICB0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBpbnRlZ2VyIGFycmF5cywgaW5kaWNhdGluZyB3aGljaCB2ZXJ0aWNlcyBlYWNoIGZhY2UgY29uc2lzdHMgb2ZcbiAgICAgKiBAcHJvcGVydHkgZmFjZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5mYWNlcyA9IGZhY2VzfHxbXTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIFZlYzNcbiAgICAgKiBAcHJvcGVydHkgZmFjZU5vcm1hbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5mYWNlTm9ybWFscyA9IFtdO1xuICAgIHRoaXMuY29tcHV0ZU5vcm1hbHMoKTtcblxuICAgIHRoaXMud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHMgPSBbXTsgLy8gV29ybGQgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiAuZmFjZU5vcm1hbHNcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIFZlYzNcbiAgICAgKiBAcHJvcGVydHkgdW5pcXVlRWRnZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy51bmlxdWVFZGdlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogSWYgZ2l2ZW4sIHRoZXNlIGxvY2FsbHkgZGVmaW5lZCwgbm9ybWFsaXplZCBheGVzIGFyZSB0aGUgb25seSBvbmVzIGJlaW5nIGNoZWNrZWQgd2hlbiBkb2luZyBzZXBhcmF0aW5nIGF4aXMgY2hlY2suXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gdW5pcXVlQXhlc1xuICAgICAqL1xuICAgIHRoaXMudW5pcXVlQXhlcyA9IHVuaXF1ZUF4ZXMgPyB1bmlxdWVBeGVzLnNsaWNlKCkgOiBudWxsO1xuXG4gICAgdGhpcy5jb21wdXRlRWRnZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG59XG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb252ZXhQb2x5aGVkcm9uO1xuXG52YXIgY29tcHV0ZUVkZ2VzX3RtcEVkZ2UgPSBuZXcgVmVjMygpO1xuLyoqXG4gKiBDb21wdXRlcyB1bmlxdWVFZGdlc1xuICogQG1ldGhvZCBjb21wdXRlRWRnZXNcbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZUVkZ2VzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIG52ID0gdmVydGljZXMubGVuZ3RoO1xuICAgIHZhciBlZGdlcyA9IHRoaXMudW5pcXVlRWRnZXM7XG5cbiAgICBlZGdlcy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGVkZ2UgPSBjb21wdXRlRWRnZXNfdG1wRWRnZTtcblxuICAgIGZvcih2YXIgaT0wOyBpICE9PSBmYWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBmYWNlID0gZmFjZXNbaV07XG4gICAgICAgIHZhciBudW1WZXJ0aWNlcyA9IGZhY2UubGVuZ3RoO1xuICAgICAgICBmb3IodmFyIGogPSAwOyBqICE9PSBudW1WZXJ0aWNlczsgaisrKXtcbiAgICAgICAgICAgIHZhciBrID0gKCBqKzEgKSAlIG51bVZlcnRpY2VzO1xuICAgICAgICAgICAgdmVydGljZXNbZmFjZVtqXV0udnN1Yih2ZXJ0aWNlc1tmYWNlW2tdXSwgZWRnZSk7XG4gICAgICAgICAgICBlZGdlLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IodmFyIHA9MDsgcCAhPT0gZWRnZXMubGVuZ3RoOyBwKyspe1xuICAgICAgICAgICAgICAgIGlmIChlZGdlc1twXS5hbG1vc3RFcXVhbHMoZWRnZSkgfHwgZWRnZXNbcF0uYWxtb3N0RXF1YWxzKGVkZ2UpKXtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZm91bmQpe1xuICAgICAgICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZS5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbm9ybWFscyBvZiB0aGUgZmFjZXMuIFdpbGwgcmV1c2UgZXhpc3RpbmcgVmVjMyBvYmplY3RzIGluIHRoZSAuZmFjZU5vcm1hbHMgYXJyYXkgaWYgdGhleSBleGlzdC5cbiAqIEBtZXRob2QgY29tcHV0ZU5vcm1hbHNcbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZU5vcm1hbHMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoID0gdGhpcy5mYWNlcy5sZW5ndGg7XG5cbiAgICAvLyBHZW5lcmF0ZSBub3JtYWxzXG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5mYWNlcy5sZW5ndGg7IGkrKyl7XG5cbiAgICAgICAgLy8gQ2hlY2sgc28gYWxsIHZlcnRpY2VzIGV4aXN0cyBmb3IgdGhpcyBmYWNlXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHRoaXMuZmFjZXNbaV0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgaWYoIXRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVtqXV0pe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcnRleCBcIit0aGlzLmZhY2VzW2ldW2pdK1wiIG5vdCBmb3VuZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbiA9IHRoaXMuZmFjZU5vcm1hbHNbaV0gfHwgbmV3IFZlYzMoKTtcbiAgICAgICAgdGhpcy5nZXRGYWNlTm9ybWFsKGksbik7XG4gICAgICAgIG4ubmVnYXRlKG4pO1xuICAgICAgICB0aGlzLmZhY2VOb3JtYWxzW2ldID0gbjtcbiAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVswXV07XG4gICAgICAgIGlmKG4uZG90KHZlcnRleCkgPCAwKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIuZmFjZU5vcm1hbHNbXCIgKyBpICsgXCJdID0gVmVjMyhcIituLnRvU3RyaW5nKCkrXCIpIGxvb2tzIGxpa2UgaXQgcG9pbnRzIGludG8gdGhlIHNoYXBlPyBUaGUgdmVydGljZXMgZm9sbG93LiBNYWtlIHN1cmUgdGhleSBhcmUgb3JkZXJlZCBDQ1cgYXJvdW5kIHRoZSBub3JtYWwsIHVzaW5nIHRoZSByaWdodCBoYW5kIHJ1bGUuXCIpO1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8dGhpcy5mYWNlc1tpXS5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiLnZlcnRpY2VzW1wiK3RoaXMuZmFjZXNbaV1bal0rXCJdID0gVmVjMyhcIit0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbaV1bal1dLnRvU3RyaW5nKCkrXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgZmFjZSBub3JtYWwgZ2l2ZW4gMyB2ZXJ0aWNlc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRGYWNlTm9ybWFsXG4gKiBAcGFyYW0ge1ZlYzN9IHZhXG4gKiBAcGFyYW0ge1ZlYzN9IHZiXG4gKiBAcGFyYW0ge1ZlYzN9IHZjXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICovXG52YXIgY2IgPSBuZXcgVmVjMygpO1xudmFyIGFiID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24uY29tcHV0ZU5vcm1hbCA9IGZ1bmN0aW9uICggdmEsIHZiLCB2YywgdGFyZ2V0ICkge1xuICAgIHZiLnZzdWIodmEsYWIpO1xuICAgIHZjLnZzdWIodmIsY2IpO1xuICAgIGNiLmNyb3NzKGFiLHRhcmdldCk7XG4gICAgaWYgKCAhdGFyZ2V0LmlzWmVybygpICkge1xuICAgICAgICB0YXJnZXQubm9ybWFsaXplKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBub3JtYWwgb2YgYSBmYWNlIGZyb20gaXRzIHZlcnRpY2VzXG4gKiBAbWV0aG9kIGdldEZhY2VOb3JtYWxcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmdldEZhY2VOb3JtYWwgPSBmdW5jdGlvbihpLHRhcmdldCl7XG4gICAgdmFyIGYgPSB0aGlzLmZhY2VzW2ldO1xuICAgIHZhciB2YSA9IHRoaXMudmVydGljZXNbZlswXV07XG4gICAgdmFyIHZiID0gdGhpcy52ZXJ0aWNlc1tmWzFdXTtcbiAgICB2YXIgdmMgPSB0aGlzLnZlcnRpY2VzW2ZbMl1dO1xuICAgIHJldHVybiBDb252ZXhQb2x5aGVkcm9uLmNvbXB1dGVOb3JtYWwodmEsdmIsdmMsdGFyZ2V0KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjbGlwQWdhaW5zdEh1bGxcbiAqIEBwYXJhbSB7VmVjM30gcG9zQVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxuICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsQlxuICogQHBhcmFtIHtWZWMzfSBwb3NCXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRCXG4gKiBAcGFyYW0ge1ZlYzN9IHNlcGFyYXRpbmdOb3JtYWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5EaXN0IENsYW1wIGRpc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RGlzdFxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IFRoZSBhbiBhcnJheSBvZiBjb250YWN0IHBvaW50IG9iamVjdHMsIHNlZSBjbGlwRmFjZUFnYWluc3RIdWxsXG4gKiBAc2VlIGh0dHA6Ly9idWxsZXQuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL3NyYy9CdWxsZXRDb2xsaXNpb24vTmFycm93UGhhc2VDb2xsaXNpb24vYnRQb2x5aGVkcmFsQ29udGFjdENsaXBwaW5nLmNwcFxuICovXG52YXIgY2FoX1dvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNsaXBBZ2FpbnN0SHVsbCA9IGZ1bmN0aW9uKHBvc0EscXVhdEEsaHVsbEIscG9zQixxdWF0QixzZXBhcmF0aW5nTm9ybWFsLG1pbkRpc3QsbWF4RGlzdCxyZXN1bHQpe1xuICAgIHZhciBXb3JsZE5vcm1hbCA9IGNhaF9Xb3JsZE5vcm1hbDtcbiAgICB2YXIgaHVsbEEgPSB0aGlzO1xuICAgIHZhciBjdXJNYXhEaXN0ID0gbWF4RGlzdDtcbiAgICB2YXIgY2xvc2VzdEZhY2VCID0gLTE7XG4gICAgdmFyIGRtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBmb3IodmFyIGZhY2U9MDsgZmFjZSA8IGh1bGxCLmZhY2VzLmxlbmd0aDsgZmFjZSsrKXtcbiAgICAgICAgV29ybGROb3JtYWwuY29weShodWxsQi5mYWNlTm9ybWFsc1tmYWNlXSk7XG4gICAgICAgIHF1YXRCLnZtdWx0KFdvcmxkTm9ybWFsLFdvcmxkTm9ybWFsKTtcbiAgICAgICAgLy9wb3NCLnZhZGQoV29ybGROb3JtYWwsV29ybGROb3JtYWwpO1xuICAgICAgICB2YXIgZCA9IFdvcmxkTm9ybWFsLmRvdChzZXBhcmF0aW5nTm9ybWFsKTtcbiAgICAgICAgaWYgKGQgPiBkbWF4KXtcbiAgICAgICAgICAgIGRtYXggPSBkO1xuICAgICAgICAgICAgY2xvc2VzdEZhY2VCID0gZmFjZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgd29ybGRWZXJ0c0IxID0gW107XG4gICAgdmFyIHBvbHlCID0gaHVsbEIuZmFjZXNbY2xvc2VzdEZhY2VCXTtcbiAgICB2YXIgbnVtVmVydGljZXMgPSBwb2x5Qi5sZW5ndGg7XG4gICAgZm9yKHZhciBlMD0wOyBlMDxudW1WZXJ0aWNlczsgZTArKyl7XG4gICAgICAgIHZhciBiID0gaHVsbEIudmVydGljZXNbcG9seUJbZTBdXTtcbiAgICAgICAgdmFyIHdvcmxkYiA9IG5ldyBWZWMzKCk7XG4gICAgICAgIHdvcmxkYi5jb3B5KGIpO1xuICAgICAgICBxdWF0Qi52bXVsdCh3b3JsZGIsd29ybGRiKTtcbiAgICAgICAgcG9zQi52YWRkKHdvcmxkYix3b3JsZGIpO1xuICAgICAgICB3b3JsZFZlcnRzQjEucHVzaCh3b3JsZGIpO1xuICAgIH1cblxuICAgIGlmIChjbG9zZXN0RmFjZUI+PTApe1xuICAgICAgICB0aGlzLmNsaXBGYWNlQWdhaW5zdEh1bGwoc2VwYXJhdGluZ05vcm1hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc0EsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWF0QSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkVmVydHNCMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhEaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIHNlcGFyYXRpbmcgYXhpcyBiZXR3ZWVuIHRoaXMgaHVsbCBhbmQgYW5vdGhlclxuICogQG1ldGhvZCBmaW5kU2VwYXJhdGluZ0F4aXNcbiAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbEJcbiAqIEBwYXJhbSB7VmVjM30gcG9zQVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxuICogQHBhcmFtIHtWZWMzfSBwb3NCXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRCXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBUaGUgdGFyZ2V0IHZlY3RvciB0byBzYXZlIHRoZSBheGlzIGluXG4gKiBAcmV0dXJuIHtib29sfSBSZXR1cm5zIGZhbHNlIGlmIGEgc2VwYXJhdGlvbiBpcyBmb3VuZCwgZWxzZSB0cnVlXG4gKi9cbnZhciBmc2FfZmFjZUFOb3JtYWxXUzMgPSBuZXcgVmVjMygpLFxuICAgIGZzYV9Xb3JsZG5vcm1hbDEgPSBuZXcgVmVjMygpLFxuICAgIGZzYV9kZWx0YUMgPSBuZXcgVmVjMygpLFxuICAgIGZzYV93b3JsZEVkZ2UwID0gbmV3IFZlYzMoKSxcbiAgICBmc2Ffd29ybGRFZGdlMSA9IG5ldyBWZWMzKCksXG4gICAgZnNhX0Nyb3NzID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmZpbmRTZXBhcmF0aW5nQXhpcyA9IGZ1bmN0aW9uKGh1bGxCLHBvc0EscXVhdEEscG9zQixxdWF0Qix0YXJnZXQsIGZhY2VMaXN0QSwgZmFjZUxpc3RCKXtcbiAgICB2YXIgZmFjZUFOb3JtYWxXUzMgPSBmc2FfZmFjZUFOb3JtYWxXUzMsXG4gICAgICAgIFdvcmxkbm9ybWFsMSA9IGZzYV9Xb3JsZG5vcm1hbDEsXG4gICAgICAgIGRlbHRhQyA9IGZzYV9kZWx0YUMsXG4gICAgICAgIHdvcmxkRWRnZTAgPSBmc2Ffd29ybGRFZGdlMCxcbiAgICAgICAgd29ybGRFZGdlMSA9IGZzYV93b3JsZEVkZ2UxLFxuICAgICAgICBDcm9zcyA9IGZzYV9Dcm9zcztcblxuICAgIHZhciBkbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgaHVsbEEgPSB0aGlzO1xuICAgIHZhciBjdXJQbGFuZVRlc3RzPTA7XG5cbiAgICBpZighaHVsbEEudW5pcXVlQXhlcyl7XG5cbiAgICAgICAgdmFyIG51bUZhY2VzQSA9IGZhY2VMaXN0QSA/IGZhY2VMaXN0QS5sZW5ndGggOiBodWxsQS5mYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gVGVzdCBmYWNlIG5vcm1hbHMgZnJvbSBodWxsQVxuICAgICAgICBmb3IodmFyIGk9MDsgaTxudW1GYWNlc0E7IGkrKyl7XG4gICAgICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdEEgPyBmYWNlTGlzdEFbaV0gOiBpO1xuXG4gICAgICAgICAgICAvLyBHZXQgd29ybGQgZmFjZSBub3JtYWxcbiAgICAgICAgICAgIGZhY2VBTm9ybWFsV1MzLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmldKTtcbiAgICAgICAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MzLGZhY2VBTm9ybWFsV1MzKTtcblxuICAgICAgICAgICAgdmFyIGQgPSBodWxsQS50ZXN0U2VwQXhpcyhmYWNlQU5vcm1hbFdTMywgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7XG4gICAgICAgICAgICBpZihkPT09ZmFsc2Upe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZDxkbWluKXtcbiAgICAgICAgICAgICAgICBkbWluID0gZDtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY29weShmYWNlQU5vcm1hbFdTMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gVGVzdCB1bmlxdWUgYXhlc1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpICE9PSBodWxsQS51bmlxdWVBeGVzLmxlbmd0aDsgaSsrKXtcblxuICAgICAgICAgICAgLy8gR2V0IHdvcmxkIGF4aXNcbiAgICAgICAgICAgIHF1YXRBLnZtdWx0KGh1bGxBLnVuaXF1ZUF4ZXNbaV0sZmFjZUFOb3JtYWxXUzMpO1xuXG4gICAgICAgICAgICB2YXIgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKGZhY2VBTm9ybWFsV1MzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKTtcbiAgICAgICAgICAgIGlmKGQ9PT1mYWxzZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihkPGRtaW4pe1xuICAgICAgICAgICAgICAgIGRtaW4gPSBkO1xuICAgICAgICAgICAgICAgIHRhcmdldC5jb3B5KGZhY2VBTm9ybWFsV1MzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKCFodWxsQi51bmlxdWVBeGVzKXtcblxuICAgICAgICAvLyBUZXN0IGZhY2Ugbm9ybWFscyBmcm9tIGh1bGxCXG4gICAgICAgIHZhciBudW1GYWNlc0IgPSBmYWNlTGlzdEIgPyBmYWNlTGlzdEIubGVuZ3RoIDogaHVsbEIuZmFjZXMubGVuZ3RoO1xuICAgICAgICBmb3IodmFyIGk9MDtpPG51bUZhY2VzQjtpKyspe1xuXG4gICAgICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdEIgPyBmYWNlTGlzdEJbaV0gOiBpO1xuXG4gICAgICAgICAgICBXb3JsZG5vcm1hbDEuY29weShodWxsQi5mYWNlTm9ybWFsc1tmaV0pO1xuICAgICAgICAgICAgcXVhdEIudm11bHQoV29ybGRub3JtYWwxLFdvcmxkbm9ybWFsMSk7XG4gICAgICAgICAgICBjdXJQbGFuZVRlc3RzKys7XG4gICAgICAgICAgICB2YXIgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKFdvcmxkbm9ybWFsMSwgaHVsbEIscG9zQSxxdWF0QSxwb3NCLHF1YXRCKTtcbiAgICAgICAgICAgIGlmKGQ9PT1mYWxzZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihkPGRtaW4pe1xuICAgICAgICAgICAgICAgIGRtaW4gPSBkO1xuICAgICAgICAgICAgICAgIHRhcmdldC5jb3B5KFdvcmxkbm9ybWFsMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFRlc3QgdW5pcXVlIGF4ZXMgaW4gQlxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpICE9PSBodWxsQi51bmlxdWVBeGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHF1YXRCLnZtdWx0KGh1bGxCLnVuaXF1ZUF4ZXNbaV0sV29ybGRub3JtYWwxKTtcblxuICAgICAgICAgICAgY3VyUGxhbmVUZXN0cysrO1xuICAgICAgICAgICAgdmFyIGQgPSBodWxsQS50ZXN0U2VwQXhpcyhXb3JsZG5vcm1hbDEsIGh1bGxCLHBvc0EscXVhdEEscG9zQixxdWF0Qik7XG4gICAgICAgICAgICBpZihkPT09ZmFsc2Upe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZDxkbWluKXtcbiAgICAgICAgICAgICAgICBkbWluID0gZDtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY29weShXb3JsZG5vcm1hbDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGVzdCBlZGdlc1xuICAgIGZvcih2YXIgZTA9MDsgZTAgIT09IGh1bGxBLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgZTArKyl7XG5cbiAgICAgICAgLy8gR2V0IHdvcmxkIGVkZ2VcbiAgICAgICAgcXVhdEEudm11bHQoaHVsbEEudW5pcXVlRWRnZXNbZTBdLHdvcmxkRWRnZTApO1xuXG4gICAgICAgIGZvcih2YXIgZTE9MDsgZTEgIT09IGh1bGxCLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgZTErKyl7XG5cbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBlZGdlIDJcbiAgICAgICAgICAgIHF1YXRCLnZtdWx0KGh1bGxCLnVuaXF1ZUVkZ2VzW2UxXSwgd29ybGRFZGdlMSk7XG4gICAgICAgICAgICB3b3JsZEVkZ2UwLmNyb3NzKHdvcmxkRWRnZTEsQ3Jvc3MpO1xuXG4gICAgICAgICAgICBpZighQ3Jvc3MuYWxtb3N0WmVybygpKXtcbiAgICAgICAgICAgICAgICBDcm9zcy5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGh1bGxBLnRlc3RTZXBBeGlzKENyb3NzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKTtcbiAgICAgICAgICAgICAgICBpZihkaXN0ID09PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoZGlzdCA8IGRtaW4pe1xuICAgICAgICAgICAgICAgICAgICBkbWluID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNvcHkoQ3Jvc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBvc0IudnN1Yihwb3NBLGRlbHRhQyk7XG4gICAgaWYoKGRlbHRhQy5kb3QodGFyZ2V0KSk+MC4wKXtcbiAgICAgICAgdGFyZ2V0Lm5lZ2F0ZSh0YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxudmFyIG1heG1pbkE9W10sIG1heG1pbkI9W107XG5cbi8qKlxuICogVGVzdCBzZXBhcmF0aW5nIGF4aXMgYWdhaW5zdCB0d28gaHVsbHMuIEJvdGggaHVsbHMgYXJlIHByb2plY3RlZCBvbnRvIHRoZSBheGlzIGFuZCB0aGUgb3ZlcmxhcCBzaXplIGlzIHJldHVybmVkIGlmIHRoZXJlIGlzIG9uZS5cbiAqIEBtZXRob2QgdGVzdFNlcEF4aXNcbiAqIEBwYXJhbSB7VmVjM30gYXhpc1xuICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsQlxuICogQHBhcmFtIHtWZWMzfSBwb3NBXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRBXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc0JcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG92ZXJsYXAgZGVwdGgsIG9yIEZBTFNFIGlmIG5vIHBlbmV0cmF0aW9uLlxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS50ZXN0U2VwQXhpcyA9IGZ1bmN0aW9uKGF4aXMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpe1xuICAgIHZhciBodWxsQT10aGlzO1xuICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQSwgYXhpcywgcG9zQSwgcXVhdEEsIG1heG1pbkEpO1xuICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQiwgYXhpcywgcG9zQiwgcXVhdEIsIG1heG1pbkIpO1xuICAgIHZhciBtYXhBID0gbWF4bWluQVswXTtcbiAgICB2YXIgbWluQSA9IG1heG1pbkFbMV07XG4gICAgdmFyIG1heEIgPSBtYXhtaW5CWzBdO1xuICAgIHZhciBtaW5CID0gbWF4bWluQlsxXTtcbiAgICBpZihtYXhBPG1pbkIgfHwgbWF4QjxtaW5BKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTZXBhcmF0ZWRcbiAgICB9XG4gICAgdmFyIGQwID0gbWF4QSAtIG1pbkI7XG4gICAgdmFyIGQxID0gbWF4QiAtIG1pbkE7XG4gICAgdmFyIGRlcHRoID0gZDA8ZDEgPyBkMDpkMTtcbiAgICByZXR1cm4gZGVwdGg7XG59O1xuXG52YXIgY2xpX2FhYmJtaW4gPSBuZXcgVmVjMygpLFxuICAgIGNsaV9hYWJibWF4ID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xuICAgIC8vIEFwcHJveGltYXRlIHdpdGggYm94IGluZXJ0aWFcbiAgICAvLyBFeGFjdCBpbmVydGlhIGNhbGN1bGF0aW9uIGlzIG92ZXJraWxsLCBidXQgc2VlIGh0dHA6Ly9nZW9tZXRyaWN0b29scy5jb20vRG9jdW1lbnRhdGlvbi9Qb2x5aGVkcmFsTWFzc1Byb3BlcnRpZXMucGRmIGZvciB0aGUgY29ycmVjdCB3YXkgdG8gZG8gaXRcbiAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIoY2xpX2FhYmJtaW4sY2xpX2FhYmJtYXgpO1xuICAgIHZhciB4ID0gY2xpX2FhYmJtYXgueCAtIGNsaV9hYWJibWluLngsXG4gICAgICAgIHkgPSBjbGlfYWFiYm1heC55IC0gY2xpX2FhYmJtaW4ueSxcbiAgICAgICAgeiA9IGNsaV9hYWJibWF4LnogLSBjbGlfYWFiYm1pbi56O1xuICAgIHRhcmdldC54ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoIDIqeSoyKnkgKyAyKnoqMip6ICk7XG4gICAgdGFyZ2V0LnkgPSAxLjAgLyAxMi4wICogbWFzcyAqICggMip4KjIqeCArIDIqeioyKnogKTtcbiAgICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAyKnkqMip5ICsgMip4KjIqeCApO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGdldFBsYW5lQ29uc3RhbnRPZkZhY2VcbiAqIEBwYXJhbSAge051bWJlcn0gZmFjZV9pIEluZGV4IG9mIHRoZSBmYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmdldFBsYW5lQ29uc3RhbnRPZkZhY2UgPSBmdW5jdGlvbihmYWNlX2kpe1xuICAgIHZhciBmID0gdGhpcy5mYWNlc1tmYWNlX2ldO1xuICAgIHZhciBuID0gdGhpcy5mYWNlTm9ybWFsc1tmYWNlX2ldO1xuICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tmWzBdXTtcbiAgICB2YXIgYyA9IC1uLmRvdCh2KTtcbiAgICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogQ2xpcCBhIGZhY2UgYWdhaW5zdCBhIGh1bGwuXG4gKiBAbWV0aG9kIGNsaXBGYWNlQWdhaW5zdEh1bGxcbiAqIEBwYXJhbSB7VmVjM30gc2VwYXJhdGluZ05vcm1hbFxuICogQHBhcmFtIHtWZWMzfSBwb3NBXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRBXG4gKiBAcGFyYW0ge0FycmF5fSB3b3JsZFZlcnRzQjEgQW4gYXJyYXkgb2YgVmVjMyB3aXRoIHZlcnRpY2VzIGluIHRoZSB3b3JsZCBmcmFtZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5EaXN0IERpc3RhbmNlIGNsYW1waW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RGlzdFxuICogQHBhcmFtIEFycmF5IHJlc3VsdCBBcnJheSB0byBzdG9yZSByZXN1bHRpbmcgY29udGFjdCBwb2ludHMgaW4uIFdpbGwgYmUgb2JqZWN0cyB3aXRoIHByb3BlcnRpZXM6IHBvaW50LCBkZXB0aCwgbm9ybWFsLiBUaGVzZSBhcmUgcmVwcmVzZW50ZWQgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKi9cbnZhciBjZmFoX2ZhY2VBTm9ybWFsV1MgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfZWRnZTAgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfV29ybGRFZGdlMCA9IG5ldyBWZWMzKCksXG4gICAgY2ZhaF93b3JsZFBsYW5lQW5vcm1hbDEgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfcGxhbmVOb3JtYWxXUzEgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfd29ybGRBMSA9IG5ldyBWZWMzKCksXG4gICAgY2ZhaF9sb2NhbFBsYW5lTm9ybWFsID0gbmV3IFZlYzMoKSxcbiAgICBjZmFoX3BsYW5lTm9ybWFsV1MgPSBuZXcgVmVjMygpO1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY2xpcEZhY2VBZ2FpbnN0SHVsbCA9IGZ1bmN0aW9uKHNlcGFyYXRpbmdOb3JtYWwsIHBvc0EsIHF1YXRBLCB3b3JsZFZlcnRzQjEsIG1pbkRpc3QsIG1heERpc3QscmVzdWx0KXtcbiAgICB2YXIgZmFjZUFOb3JtYWxXUyA9IGNmYWhfZmFjZUFOb3JtYWxXUyxcbiAgICAgICAgZWRnZTAgPSBjZmFoX2VkZ2UwLFxuICAgICAgICBXb3JsZEVkZ2UwID0gY2ZhaF9Xb3JsZEVkZ2UwLFxuICAgICAgICB3b3JsZFBsYW5lQW5vcm1hbDEgPSBjZmFoX3dvcmxkUGxhbmVBbm9ybWFsMSxcbiAgICAgICAgcGxhbmVOb3JtYWxXUzEgPSBjZmFoX3BsYW5lTm9ybWFsV1MxLFxuICAgICAgICB3b3JsZEExID0gY2ZhaF93b3JsZEExLFxuICAgICAgICBsb2NhbFBsYW5lTm9ybWFsID0gY2ZhaF9sb2NhbFBsYW5lTm9ybWFsLFxuICAgICAgICBwbGFuZU5vcm1hbFdTID0gY2ZhaF9wbGFuZU5vcm1hbFdTO1xuXG4gICAgdmFyIGh1bGxBID0gdGhpcztcbiAgICB2YXIgd29ybGRWZXJ0c0IyID0gW107XG4gICAgdmFyIHBWdHhJbiA9IHdvcmxkVmVydHNCMTtcbiAgICB2YXIgcFZ0eE91dCA9IHdvcmxkVmVydHNCMjtcbiAgICAvLyBGaW5kIHRoZSBmYWNlIHdpdGggbm9ybWFsIGNsb3Nlc3QgdG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xuICAgIHZhciBjbG9zZXN0RmFjZUEgPSAtMTtcbiAgICB2YXIgZG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgZm9yKHZhciBmYWNlPTA7IGZhY2U8aHVsbEEuZmFjZXMubGVuZ3RoOyBmYWNlKyspe1xuICAgICAgICBmYWNlQU5vcm1hbFdTLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmFjZV0pO1xuICAgICAgICBxdWF0QS52bXVsdChmYWNlQU5vcm1hbFdTLGZhY2VBTm9ybWFsV1MpO1xuICAgICAgICAvL3Bvc0EudmFkZChmYWNlQU5vcm1hbFdTLGZhY2VBTm9ybWFsV1MpO1xuICAgICAgICB2YXIgZCA9IGZhY2VBTm9ybWFsV1MuZG90KHNlcGFyYXRpbmdOb3JtYWwpO1xuICAgICAgICBpZiAoZCA8IGRtaW4pe1xuICAgICAgICAgICAgZG1pbiA9IGQ7XG4gICAgICAgICAgICBjbG9zZXN0RmFjZUEgPSBmYWNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbG9zZXN0RmFjZUEgPCAwKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCItLS0gZGlkIG5vdCBmaW5kIGFueSBjbG9zZXN0IGZhY2UuLi4gLS0tXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coXCJjbG9zZXN0IEE6IFwiLGNsb3Nlc3RGYWNlQSk7XG4gICAgLy8gR2V0IHRoZSBmYWNlIGFuZCBjb25zdHJ1Y3QgY29ubmVjdGVkIGZhY2VzXG4gICAgdmFyIHBvbHlBID0gaHVsbEEuZmFjZXNbY2xvc2VzdEZhY2VBXTtcbiAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcyA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPGh1bGxBLmZhY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aHVsbEEuZmFjZXNbaV0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgaWYocG9seUEuaW5kZXhPZihodWxsQS5mYWNlc1tpXVtqXSkhPT0tMSAvKiBTaGFyaW5nIGEgdmVydGV4Ki8gJiYgaSE9PWNsb3Nlc3RGYWNlQSAvKiBOb3QgdGhlIG9uZSB3ZSBhcmUgbG9va2luZyBmb3IgY29ubmVjdGlvbnMgZnJvbSAqLyAmJiBwb2x5QS5jb25uZWN0ZWRGYWNlcy5pbmRleE9mKGkpPT09LTEgLyogTm90IGFscmVhZHkgYWRkZWQgKi8gKXtcbiAgICAgICAgICAgICAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENsaXAgdGhlIHBvbHlnb24gdG8gdGhlIGJhY2sgb2YgdGhlIHBsYW5lcyBvZiBhbGwgZmFjZXMgb2YgaHVsbCBBLCB0aGF0IGFyZSBhZGphY2VudCB0byB0aGUgd2l0bmVzcyBmYWNlXG4gICAgdmFyIG51bUNvbnRhY3RzID0gcFZ0eEluLmxlbmd0aDtcbiAgICB2YXIgbnVtVmVydGljZXNBID0gcG9seUEubGVuZ3RoO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IodmFyIGUwPTA7IGUwPG51bVZlcnRpY2VzQTsgZTArKyl7XG4gICAgICAgIHZhciBhID0gaHVsbEEudmVydGljZXNbcG9seUFbZTBdXTtcbiAgICAgICAgdmFyIGIgPSBodWxsQS52ZXJ0aWNlc1twb2x5QVsoZTArMSklbnVtVmVydGljZXNBXV07XG4gICAgICAgIGEudnN1YihiLGVkZ2UwKTtcbiAgICAgICAgV29ybGRFZGdlMC5jb3B5KGVkZ2UwKTtcbiAgICAgICAgcXVhdEEudm11bHQoV29ybGRFZGdlMCxXb3JsZEVkZ2UwKTtcbiAgICAgICAgcG9zQS52YWRkKFdvcmxkRWRnZTAsV29ybGRFZGdlMCk7XG4gICAgICAgIHdvcmxkUGxhbmVBbm9ybWFsMS5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbY2xvc2VzdEZhY2VBXSk7Ly90cmFuc0EuZ2V0QmFzaXMoKSogYnRWZWN0b3IzKHBvbHlBLm1fcGxhbmVbMF0scG9seUEubV9wbGFuZVsxXSxwb2x5QS5tX3BsYW5lWzJdKTtcbiAgICAgICAgcXVhdEEudm11bHQod29ybGRQbGFuZUFub3JtYWwxLHdvcmxkUGxhbmVBbm9ybWFsMSk7XG4gICAgICAgIHBvc0EudmFkZCh3b3JsZFBsYW5lQW5vcm1hbDEsd29ybGRQbGFuZUFub3JtYWwxKTtcbiAgICAgICAgV29ybGRFZGdlMC5jcm9zcyh3b3JsZFBsYW5lQW5vcm1hbDEscGxhbmVOb3JtYWxXUzEpO1xuICAgICAgICBwbGFuZU5vcm1hbFdTMS5uZWdhdGUocGxhbmVOb3JtYWxXUzEpO1xuICAgICAgICB3b3JsZEExLmNvcHkoYSk7XG4gICAgICAgIHF1YXRBLnZtdWx0KHdvcmxkQTEsd29ybGRBMSk7XG4gICAgICAgIHBvc0EudmFkZCh3b3JsZEExLHdvcmxkQTEpO1xuICAgICAgICB2YXIgcGxhbmVFcVdTMSA9IC13b3JsZEExLmRvdChwbGFuZU5vcm1hbFdTMSk7XG4gICAgICAgIHZhciBwbGFuZUVxV1M7XG4gICAgICAgIGlmKHRydWUpe1xuICAgICAgICAgICAgdmFyIG90aGVyRmFjZSA9IHBvbHlBLmNvbm5lY3RlZEZhY2VzW2UwXTtcbiAgICAgICAgICAgIGxvY2FsUGxhbmVOb3JtYWwuY29weSh0aGlzLmZhY2VOb3JtYWxzW290aGVyRmFjZV0pO1xuICAgICAgICAgICAgdmFyIGxvY2FsUGxhbmVFcSA9IHRoaXMuZ2V0UGxhbmVDb25zdGFudE9mRmFjZShvdGhlckZhY2UpO1xuXG4gICAgICAgICAgICBwbGFuZU5vcm1hbFdTLmNvcHkobG9jYWxQbGFuZU5vcm1hbCk7XG4gICAgICAgICAgICBxdWF0QS52bXVsdChwbGFuZU5vcm1hbFdTLHBsYW5lTm9ybWFsV1MpO1xuICAgICAgICAgICAgLy9wb3NBLnZhZGQocGxhbmVOb3JtYWxXUyxwbGFuZU5vcm1hbFdTKTtcbiAgICAgICAgICAgIHZhciBwbGFuZUVxV1MgPSBsb2NhbFBsYW5lRXEgLSBwbGFuZU5vcm1hbFdTLmRvdChwb3NBKTtcbiAgICAgICAgfSBlbHNlICB7XG4gICAgICAgICAgICBwbGFuZU5vcm1hbFdTLmNvcHkocGxhbmVOb3JtYWxXUzEpO1xuICAgICAgICAgICAgcGxhbmVFcVdTID0gcGxhbmVFcVdTMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsaXAgZmFjZSBhZ2FpbnN0IG91ciBjb25zdHJ1Y3RlZCBwbGFuZVxuICAgICAgICB0aGlzLmNsaXBGYWNlQWdhaW5zdFBsYW5lKHBWdHhJbiwgcFZ0eE91dCwgcGxhbmVOb3JtYWxXUywgcGxhbmVFcVdTKTtcblxuICAgICAgICAvLyBUaHJvdyBhd2F5IGFsbCBjbGlwcGVkIHBvaW50cywgYnV0IHNhdmUgdGhlIHJlYW1pbmluZyB1bnRpbCBuZXh0IGNsaXBcbiAgICAgICAgd2hpbGUocFZ0eEluLmxlbmd0aCl7XG4gICAgICAgICAgICBwVnR4SW4uc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShwVnR4T3V0Lmxlbmd0aCl7XG4gICAgICAgICAgICBwVnR4SW4ucHVzaChwVnR4T3V0LnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9jb25zb2xlLmxvZyhcIlJlc3VsdGluZyBwb2ludHMgYWZ0ZXIgY2xpcDpcIixwVnR4SW4pO1xuXG4gICAgLy8gb25seSBrZWVwIGNvbnRhY3QgcG9pbnRzIHRoYXQgYXJlIGJlaGluZCB0aGUgd2l0bmVzcyBmYWNlXG4gICAgbG9jYWxQbGFuZU5vcm1hbC5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbY2xvc2VzdEZhY2VBXSk7XG5cbiAgICB2YXIgbG9jYWxQbGFuZUVxID0gdGhpcy5nZXRQbGFuZUNvbnN0YW50T2ZGYWNlKGNsb3Nlc3RGYWNlQSk7XG4gICAgcGxhbmVOb3JtYWxXUy5jb3B5KGxvY2FsUGxhbmVOb3JtYWwpO1xuICAgIHF1YXRBLnZtdWx0KHBsYW5lTm9ybWFsV1MscGxhbmVOb3JtYWxXUyk7XG5cbiAgICB2YXIgcGxhbmVFcVdTID0gbG9jYWxQbGFuZUVxIC0gcGxhbmVOb3JtYWxXUy5kb3QocG9zQSk7XG4gICAgZm9yICh2YXIgaT0wOyBpPHBWdHhJbi5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXB0aCA9IHBsYW5lTm9ybWFsV1MuZG90KHBWdHhJbltpXSkgKyBwbGFuZUVxV1M7IC8vPz8/XG4gICAgICAgIC8qY29uc29sZS5sb2coXCJkZXB0aCBjYWxjIGZyb20gbm9ybWFsPVwiLHBsYW5lTm9ybWFsV1MudG9TdHJpbmcoKSxcIiBhbmQgY29uc3RhbnQgXCIrcGxhbmVFcVdTK1wiIGFuZCB2ZXJ0ZXggXCIscFZ0eEluW2ldLnRvU3RyaW5nKCksXCIgZ2l2ZXMgXCIrZGVwdGgpOyovXG4gICAgICAgIGlmIChkZXB0aCA8PW1pbkRpc3Qpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjbGFtcGVkOiBkZXB0aD1cIitkZXB0aCtcIiB0byBtaW5EaXN0PVwiKyhtaW5EaXN0K1wiXCIpKTtcbiAgICAgICAgICAgIGRlcHRoID0gbWluRGlzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXB0aCA8PW1heERpc3Qpe1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gcFZ0eEluW2ldO1xuICAgICAgICAgICAgaWYoZGVwdGg8PTApe1xuICAgICAgICAgICAgICAgIC8qY29uc29sZS5sb2coXCJHb3QgY29udGFjdCBwb2ludCBcIixwb2ludC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgXCIsIGRlcHRoPVwiLGRlcHRoLFxuICAgICAgICAgICAgICAgICAgXCJjb250YWN0IG5vcm1hbD1cIixzZXBhcmF0aW5nTm9ybWFsLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICBcInBsYW5lXCIscGxhbmVOb3JtYWxXUy50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgXCJwbGFuZUNvbnN0YW50XCIscGxhbmVFcVdTKTsqL1xuICAgICAgICAgICAgICAgIHZhciBwID0ge1xuICAgICAgICAgICAgICAgICAgICBwb2ludDpwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsOnBsYW5lTm9ybWFsV1MsXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGlwIGEgZmFjZSBpbiBhIGh1bGwgYWdhaW5zdCB0aGUgYmFjayBvZiBhIHBsYW5lLlxuICogQG1ldGhvZCBjbGlwRmFjZUFnYWluc3RQbGFuZVxuICogQHBhcmFtIHtBcnJheX0gaW5WZXJ0aWNlc1xuICogQHBhcmFtIHtBcnJheX0gb3V0VmVydGljZXNcbiAqIEBwYXJhbSB7VmVjM30gcGxhbmVOb3JtYWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBwbGFuZUNvbnN0YW50IFRoZSBjb25zdGFudCBpbiB0aGUgbWF0aGVtYXRpY2FsIHBsYW5lIGVxdWF0aW9uXG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNsaXBGYWNlQWdhaW5zdFBsYW5lID0gZnVuY3Rpb24oaW5WZXJ0aWNlcyxvdXRWZXJ0aWNlcywgcGxhbmVOb3JtYWwsIHBsYW5lQ29uc3RhbnQpe1xuICAgIHZhciBuX2RvdF9maXJzdCwgbl9kb3RfbGFzdDtcbiAgICB2YXIgbnVtVmVydHMgPSBpblZlcnRpY2VzLmxlbmd0aDtcblxuICAgIGlmKG51bVZlcnRzIDwgMil7XG4gICAgICAgIHJldHVybiBvdXRWZXJ0aWNlcztcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RWZXJ0ZXggPSBpblZlcnRpY2VzW2luVmVydGljZXMubGVuZ3RoLTFdLFxuICAgICAgICBsYXN0VmVydGV4ID0gICBpblZlcnRpY2VzWzBdO1xuXG4gICAgbl9kb3RfZmlyc3QgPSBwbGFuZU5vcm1hbC5kb3QoZmlyc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDtcblxuICAgIGZvcih2YXIgdmkgPSAwOyB2aSA8IG51bVZlcnRzOyB2aSsrKXtcbiAgICAgICAgbGFzdFZlcnRleCA9IGluVmVydGljZXNbdmldO1xuICAgICAgICBuX2RvdF9sYXN0ID0gcGxhbmVOb3JtYWwuZG90KGxhc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDtcbiAgICAgICAgaWYobl9kb3RfZmlyc3QgPCAwKXtcbiAgICAgICAgICAgIGlmKG5fZG90X2xhc3QgPCAwKXtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCA8IDAsIGVuZCA8IDAsIHNvIG91dHB1dCBsYXN0VmVydGV4XG4gICAgICAgICAgICAgICAgdmFyIG5ld3YgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIG5ld3YuY29weShsYXN0VmVydGV4KTtcbiAgICAgICAgICAgICAgICBvdXRWZXJ0aWNlcy5wdXNoKG5ld3YpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCA8IDAsIGVuZCA+PSAwLCBzbyBvdXRwdXQgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIG5ld3YgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIGZpcnN0VmVydGV4LmxlcnAobGFzdFZlcnRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5fZG90X2ZpcnN0IC8gKG5fZG90X2ZpcnN0IC0gbl9kb3RfbGFzdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXd2KTtcbiAgICAgICAgICAgICAgICBvdXRWZXJ0aWNlcy5wdXNoKG5ld3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYobl9kb3RfbGFzdDwwKXtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCA+PSAwLCBlbmQgPCAwIHNvIG91dHB1dCBpbnRlcnNlY3Rpb24gYW5kIGVuZFxuICAgICAgICAgICAgICAgIHZhciBuZXd2ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICBmaXJzdFZlcnRleC5sZXJwKGxhc3RWZXJ0ZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuX2RvdF9maXJzdCAvIChuX2RvdF9maXJzdCAtIG5fZG90X2xhc3QpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3dik7XG4gICAgICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTtcbiAgICAgICAgICAgICAgICBvdXRWZXJ0aWNlcy5wdXNoKGxhc3RWZXJ0ZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpcnN0VmVydGV4ID0gbGFzdFZlcnRleDtcbiAgICAgICAgbl9kb3RfZmlyc3QgPSBuX2RvdF9sYXN0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0VmVydGljZXM7XG59O1xuXG4vLyBVcGRhdGVzIC53b3JsZFZlcnRpY2VzIGFuZCBzZXRzIC53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgdG8gZmFsc2UuXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jb21wdXRlV29ybGRWZXJ0aWNlcyA9IGZ1bmN0aW9uKHBvc2l0aW9uLHF1YXQpe1xuICAgIHZhciBOID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgd2hpbGUodGhpcy53b3JsZFZlcnRpY2VzLmxlbmd0aCA8IE4pe1xuICAgICAgICB0aGlzLndvcmxkVmVydGljZXMucHVzaCggbmV3IFZlYzMoKSApO1xuICAgIH1cblxuICAgIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIHdvcmxkVmVydHMgPSB0aGlzLndvcmxkVmVydGljZXM7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICBxdWF0LnZtdWx0KCB2ZXJ0c1tpXSAsIHdvcmxkVmVydHNbaV0gKTtcbiAgICAgICAgcG9zaXRpb24udmFkZCggd29ybGRWZXJ0c1tpXSAsIHdvcmxkVmVydHNbaV0gKTtcbiAgICB9XG5cbiAgICB0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSA9IGZhbHNlO1xufTtcblxudmFyIGNvbXB1dGVMb2NhbEFBQkJfd29ybGRWZXJ0ID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNvbXB1dGVMb2NhbEFBQkIgPSBmdW5jdGlvbihhYWJibWluLGFhYmJtYXgpe1xuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgd29ybGRWZXJ0ID0gY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQ7XG5cbiAgICBhYWJibWluLnNldChOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICBhYWJibWF4LnNldCgtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFKTtcblxuICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVydGljZXNbaV07XG4gICAgICAgIGlmICAgICAodi54IDwgYWFiYm1pbi54KXtcbiAgICAgICAgICAgIGFhYmJtaW4ueCA9IHYueDtcbiAgICAgICAgfSBlbHNlIGlmKHYueCA+IGFhYmJtYXgueCl7XG4gICAgICAgICAgICBhYWJibWF4LnggPSB2Lng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgICAgICh2LnkgPCBhYWJibWluLnkpe1xuICAgICAgICAgICAgYWFiYm1pbi55ID0gdi55O1xuICAgICAgICB9IGVsc2UgaWYodi55ID4gYWFiYm1heC55KXtcbiAgICAgICAgICAgIGFhYmJtYXgueSA9IHYueTtcbiAgICAgICAgfVxuICAgICAgICBpZiAgICAgKHYueiA8IGFhYmJtaW4ueil7XG4gICAgICAgICAgICBhYWJibWluLnogPSB2Lno7XG4gICAgICAgIH0gZWxzZSBpZih2LnogPiBhYWJibWF4Lnope1xuICAgICAgICAgICAgYWFiYm1heC56ID0gdi56O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIC53b3JsZFZlcnRpY2VzIGFuZCBzZXRzIC53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgdG8gZmFsc2UuXG4gKiBAbWV0aG9kIGNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzID0gZnVuY3Rpb24ocXVhdCl7XG4gICAgdmFyIE4gPSB0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aDtcbiAgICB3aGlsZSh0aGlzLndvcmxkRmFjZU5vcm1hbHMubGVuZ3RoIDwgTil7XG4gICAgICAgIHRoaXMud29ybGRGYWNlTm9ybWFscy5wdXNoKCBuZXcgVmVjMygpICk7XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbHMgPSB0aGlzLmZhY2VOb3JtYWxzLFxuICAgICAgICB3b3JsZE5vcm1hbHMgPSB0aGlzLndvcmxkRmFjZU5vcm1hbHM7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICBxdWF0LnZtdWx0KCBub3JtYWxzW2ldICwgd29ybGROb3JtYWxzW2ldICk7XG4gICAgfVxuXG4gICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1c1xuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gQXNzdW1lIHBvaW50cyBhcmUgZGlzdHJpYnV0ZWQgd2l0aCBsb2NhbCAoMCwwLDApIGFzIGNlbnRlclxuICAgIHZhciBtYXgyID0gMDtcbiAgICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIGZvcih2YXIgaT0wLCBOPXZlcnRzLmxlbmd0aDsgaSE9PU47IGkrKykge1xuICAgICAgICB2YXIgbm9ybTIgPSB2ZXJ0c1tpXS5ub3JtMigpO1xuICAgICAgICBpZihub3JtMiA+IG1heDIpe1xuICAgICAgICAgICAgbWF4MiA9IG5vcm0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBNYXRoLnNxcnQobWF4Mik7XG59O1xuXG52YXIgdGVtcFdvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZVdvcmxkQUFCQlxuICogQHBhcmFtIHtWZWMzfSAgICAgICAgcG9zXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259ICBxdWF0XG4gKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBtaW5cbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIG1heFxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MscXVhdCxtaW4sbWF4KXtcbiAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLCB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIG1pbngsbWlueSxtaW56LG1heHgsbWF4eSxtYXh6O1xuICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XG4gICAgICAgIHRlbXBXb3JsZFZlcnRleC5jb3B5KHZlcnRzW2ldKTtcbiAgICAgICAgcXVhdC52bXVsdCh0ZW1wV29ybGRWZXJ0ZXgsdGVtcFdvcmxkVmVydGV4KTtcbiAgICAgICAgcG9zLnZhZGQodGVtcFdvcmxkVmVydGV4LHRlbXBXb3JsZFZlcnRleCk7XG4gICAgICAgIHZhciB2ID0gdGVtcFdvcmxkVmVydGV4O1xuICAgICAgICBpZiAgICAgKHYueCA8IG1pbnggfHwgbWlueD09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW54ID0gdi54O1xuICAgICAgICB9IGVsc2UgaWYodi54ID4gbWF4eCB8fCBtYXh4PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHggPSB2Lng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAgICAgKHYueSA8IG1pbnkgfHwgbWlueT09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW55ID0gdi55O1xuICAgICAgICB9IGVsc2UgaWYodi55ID4gbWF4eSB8fCBtYXh5PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHkgPSB2Lnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAgICAgKHYueiA8IG1pbnogfHwgbWluej09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW56ID0gdi56O1xuICAgICAgICB9IGVsc2UgaWYodi56ID4gbWF4eiB8fCBtYXh6PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHogPSB2Lno7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWluLnNldChtaW54LG1pbnksbWlueik7XG4gICAgbWF4LnNldChtYXh4LG1heHksbWF4eik7XG59O1xuXG4vKipcbiAqIEdldCBhcHByb3hpbWF0ZSBjb252ZXggdm9sdW1lXG4gKiBAbWV0aG9kIHZvbHVtZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyAvIDMuMDtcbn07XG5cbi8qKlxuICogR2V0IGFuIGF2ZXJhZ2Ugb2YgYWxsIHRoZSB2ZXJ0aWNlcyBwb3NpdGlvbnNcbiAqIEBtZXRob2QgZ2V0QXZlcmFnZVBvaW50TG9jYWxcbiAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuZ2V0QXZlcmFnZVBvaW50TG9jYWwgPSBmdW5jdGlvbih0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICB0YXJnZXQudmFkZCh2ZXJ0c1tpXSx0YXJnZXQpO1xuICAgIH1cbiAgICB0YXJnZXQubXVsdCgxL24sdGFyZ2V0KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYWxsIGxvY2FsIHBvaW50cy4gV2lsbCBjaGFuZ2UgdGhlIC52ZXJ0aWNlc1xuICogQG1ldGhvZCB0cmFuc2Zvcm1BbGxQb2ludHNcbiAqIEBwYXJhbSAge1ZlYzN9IG9mZnNldFxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS50cmFuc2Zvcm1BbGxQb2ludHMgPSBmdW5jdGlvbihvZmZzZXQscXVhdCl7XG4gICAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgLy8gQXBwbHkgcm90YXRpb25cbiAgICBpZihxdWF0KXtcbiAgICAgICAgLy8gUm90YXRlIHZlcnRpY2VzXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XG4gICAgICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuICAgICAgICAgICAgcXVhdC52bXVsdCh2LHYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJvdGF0ZSBmYWNlIG5vcm1hbHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZmFjZU5vcm1hbHNbaV07XG4gICAgICAgICAgICBxdWF0LnZtdWx0KHYsdik7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgLy8gUm90YXRlIGVkZ2VzXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudW5pcXVlRWRnZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnVuaXF1ZUVkZ2VzW2ldO1xuICAgICAgICAgICAgcXVhdC52bXVsdCh2LHYpO1xuICAgICAgICB9Ki9cbiAgICB9XG5cbiAgICAvLyBBcHBseSBvZmZzZXRcbiAgICBpZihvZmZzZXQpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcbiAgICAgICAgICAgIHYudmFkZChvZmZzZXQsdik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHAgaXMgaW5zaWRlIHRoZSBwb2x5aGVkcmEuIE11c3QgYmUgaW4gbG9jYWwgY29vcmRzLiBUaGUgcG9pbnQgbGllcyBvdXRzaWRlIG9mIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgb3RoZXIgcG9pbnRzIGlmIGFuZCBvbmx5IGlmIHRoZSBkaXJlY3Rpb24gb2YgYWxsIHRoZSB2ZWN0b3JzIGZyb20gaXQgdG8gdGhvc2Ugb3RoZXIgcG9pbnRzIGFyZSBvbiBsZXNzIHRoYW4gb25lIGhhbGYgb2YgYSBzcGhlcmUgYXJvdW5kIGl0LlxuICogQG1ldGhvZCBwb2ludElzSW5zaWRlXG4gKiBAcGFyYW0gIHtWZWMzfSBwICAgICAgQSBwb2ludCBnaXZlbiBpbiBsb2NhbCBjb29yZGluYXRlc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIENvbnZleFBvbHloZWRyb25fcG9pbnRJc0luc2lkZSA9IG5ldyBWZWMzKCk7XG52YXIgQ29udmV4UG9seWhlZHJvbl92VG9QID0gbmV3IFZlYzMoKTtcbnZhciBDb252ZXhQb2x5aGVkcm9uX3ZUb1BvaW50SW5zaWRlID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLnBvaW50SXNJbnNpZGUgPSBmdW5jdGlvbihwKXtcbiAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIGZhY2VzID0gdGhpcy5mYWNlcyxcbiAgICAgICAgbm9ybWFscyA9IHRoaXMuZmFjZU5vcm1hbHM7XG4gICAgdmFyIHBvc2l0aXZlUmVzdWx0ID0gbnVsbDtcbiAgICB2YXIgTiA9IHRoaXMuZmFjZXMubGVuZ3RoO1xuICAgIHZhciBwb2ludEluc2lkZSA9IENvbnZleFBvbHloZWRyb25fcG9pbnRJc0luc2lkZTtcbiAgICB0aGlzLmdldEF2ZXJhZ2VQb2ludExvY2FsKHBvaW50SW5zaWRlKTtcbiAgICBmb3IodmFyIGk9MDsgaTxOOyBpKyspe1xuICAgICAgICB2YXIgbnVtVmVydGljZXMgPSB0aGlzLmZhY2VzW2ldLmxlbmd0aDtcbiAgICAgICAgdmFyIG4gPSBub3JtYWxzW2ldO1xuICAgICAgICB2YXIgdiA9IHZlcnRzW2ZhY2VzW2ldWzBdXTsgLy8gV2Ugb25seSBuZWVkIG9uZSBwb2ludCBpbiB0aGUgZmFjZVxuXG4gICAgICAgIC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpc1xuICAgICAgICB2YXIgdlRvUCA9IENvbnZleFBvbHloZWRyb25fdlRvUDtcbiAgICAgICAgcC52c3ViKHYsdlRvUCk7XG4gICAgICAgIHZhciByMSA9IG4uZG90KHZUb1ApO1xuXG4gICAgICAgIHZhciB2VG9Qb2ludEluc2lkZSA9IENvbnZleFBvbHloZWRyb25fdlRvUG9pbnRJbnNpZGU7XG4gICAgICAgIHBvaW50SW5zaWRlLnZzdWIodix2VG9Qb2ludEluc2lkZSk7XG4gICAgICAgIHZhciByMiA9IG4uZG90KHZUb1BvaW50SW5zaWRlKTtcblxuICAgICAgICBpZigocjE8MCAmJiByMj4wKSB8fCAocjE+MCAmJiByMjwwKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVuY291bnRlcmVkIHNvbWUgb3RoZXIgc2lnbi4gRXhpdC5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGdvdCBoZXJlLCBhbGwgZG90IHByb2R1Y3RzIHdlcmUgb2YgdGhlIHNhbWUgc2lnbi5cbiAgICByZXR1cm4gcG9zaXRpdmVSZXN1bHQgPyAxIDogLTE7XG59O1xuXG4vKipcbiAqIEdldCBtYXggYW5kIG1pbiBkb3QgcHJvZHVjdCBvZiBhIGNvbnZleCBodWxsIGF0IHBvc2l0aW9uIChwb3MscXVhdCkgcHJvamVjdGVkIG9udG8gYW4gYXhpcy4gUmVzdWx0cyBhcmUgc2F2ZWQgaW4gdGhlIGFycmF5IG1heG1pbi5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgcHJvamVjdFxuICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsXG4gKiBAcGFyYW0ge1ZlYzN9IGF4aXNcbiAqIEBwYXJhbSB7VmVjM30gcG9zXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCByZXN1bHRbMF0gYW5kIHJlc3VsdFsxXSB3aWxsIGJlIHNldCB0byBtYXhpbXVtIGFuZCBtaW5pbXVtLCByZXNwZWN0aXZlbHkuXG4gKi9cbnZhciBwcm9qZWN0X3dvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTtcbnZhciBwcm9qZWN0X2xvY2FsQXhpcyA9IG5ldyBWZWMzKCk7XG52YXIgcHJvamVjdF9sb2NhbE9yaWdpbiA9IG5ldyBWZWMzKCk7XG5Db252ZXhQb2x5aGVkcm9uLnByb2plY3QgPSBmdW5jdGlvbihodWxsLCBheGlzLCBwb3MsIHF1YXQsIHJlc3VsdCl7XG4gICAgdmFyIG4gPSBodWxsLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgd29ybGRWZXJ0ZXggPSBwcm9qZWN0X3dvcmxkVmVydGV4LFxuICAgICAgICBsb2NhbEF4aXMgPSBwcm9qZWN0X2xvY2FsQXhpcyxcbiAgICAgICAgbWF4ID0gMCxcbiAgICAgICAgbWluID0gMCxcbiAgICAgICAgbG9jYWxPcmlnaW4gPSBwcm9qZWN0X2xvY2FsT3JpZ2luLFxuICAgICAgICB2cyA9IGh1bGwudmVydGljZXM7XG5cbiAgICBsb2NhbE9yaWdpbi5zZXRaZXJvKCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gdGhlIGF4aXMgdG8gbG9jYWxcbiAgICBUcmFuc2Zvcm0udmVjdG9yVG9Mb2NhbEZyYW1lKHBvcywgcXVhdCwgYXhpcywgbG9jYWxBeGlzKTtcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBsb2NhbE9yaWdpbiwgbG9jYWxPcmlnaW4pO1xuICAgIHZhciBhZGQgPSBsb2NhbE9yaWdpbi5kb3QobG9jYWxBeGlzKTtcblxuICAgIG1pbiA9IG1heCA9IHZzWzBdLmRvdChsb2NhbEF4aXMpO1xuXG4gICAgZm9yKHZhciBpID0gMTsgaSA8IG47IGkrKyl7XG4gICAgICAgIHZhciB2YWwgPSB2c1tpXS5kb3QobG9jYWxBeGlzKTtcblxuICAgICAgICBpZih2YWwgPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodmFsIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1pbiAtPSBhZGQ7XG4gICAgbWF4IC09IGFkZDtcblxuICAgIGlmKG1pbiA+IG1heCl7XG4gICAgICAgIC8vIEluY29uc2lzdGVudCAtIHN3YXBcbiAgICAgICAgdmFyIHRlbXAgPSBtaW47XG4gICAgICAgIG1pbiA9IG1heDtcbiAgICAgICAgbWF4ID0gdGVtcDtcbiAgICB9XG4gICAgLy8gT3V0cHV0XG4gICAgcmVzdWx0WzBdID0gbWF4O1xuICAgIHJlc3VsdFsxXSA9IG1pbjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEN5bGluZGVyO1xuXG52YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBDb252ZXhQb2x5aGVkcm9uID0gcmVxdWlyZSgnLi9Db252ZXhQb2x5aGVkcm9uJyk7XG5cbi8qKlxuICogQGNsYXNzIEN5bGluZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENvbnZleFBvbHloZWRyb25cbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUb3BcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCb3R0b21cbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1TZWdtZW50cyBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIGJ1aWxkIHRoZSBjeWxpbmRlciBvdXQgb2ZcbiAqL1xuZnVuY3Rpb24gQ3lsaW5kZXIoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQgLCBudW1TZWdtZW50cyApIHtcbiAgICB2YXIgTiA9IG51bVNlZ21lbnRzLFxuICAgICAgICB2ZXJ0cyA9IFtdLFxuICAgICAgICBheGVzID0gW10sXG4gICAgICAgIGZhY2VzID0gW10sXG4gICAgICAgIGJvdHRvbWZhY2UgPSBbXSxcbiAgICAgICAgdG9wZmFjZSA9IFtdLFxuICAgICAgICBjb3MgPSBNYXRoLmNvcyxcbiAgICAgICAgc2luID0gTWF0aC5zaW47XG5cbiAgICAvLyBGaXJzdCBib3R0b20gcG9pbnRcbiAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c0JvdHRvbSpjb3MoMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzQm90dG9tKnNpbigwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtaGVpZ2h0KjAuNSkpO1xuICAgIGJvdHRvbWZhY2UucHVzaCgwKTtcblxuICAgIC8vIEZpcnN0IHRvcCBwb2ludFxuICAgIHZlcnRzLnB1c2gobmV3IFZlYzMocmFkaXVzVG9wKmNvcygwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNUb3Aqc2luKDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCowLjUpKTtcbiAgICB0b3BmYWNlLnB1c2goMSk7XG5cbiAgICBmb3IodmFyIGk9MDsgaTxOOyBpKyspe1xuICAgICAgICB2YXIgdGhldGEgPSAyKk1hdGguUEkvTiAqIChpKzEpO1xuICAgICAgICB2YXIgdGhldGFOID0gMipNYXRoLlBJL04gKiAoaSswLjUpO1xuICAgICAgICBpZihpPE4tMSl7XG4gICAgICAgICAgICAvLyBCb3R0b21cbiAgICAgICAgICAgIHZlcnRzLnB1c2gobmV3IFZlYzMocmFkaXVzQm90dG9tKmNvcyh0aGV0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNCb3R0b20qc2luKHRoZXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1oZWlnaHQqMC41KSk7XG4gICAgICAgICAgICBib3R0b21mYWNlLnB1c2goMippKzIpO1xuICAgICAgICAgICAgLy8gVG9wXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c1RvcCpjb3ModGhldGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzVG9wKnNpbih0aGV0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQqMC41KSk7XG4gICAgICAgICAgICB0b3BmYWNlLnB1c2goMippKzMpO1xuXG4gICAgICAgICAgICAvLyBGYWNlXG4gICAgICAgICAgICBmYWNlcy5wdXNoKFsyKmkrMiwgMippKzMsIDIqaSsxLDIqaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmFjZXMucHVzaChbMCwxLCAyKmkrMSwgMippXSk7IC8vIENvbm5lY3RcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF4aXM6IHdlIGNhbiBjdXQgb2ZmIGhhbGYgb2YgdGhlbSBpZiB3ZSBoYXZlIGV2ZW4gbnVtYmVyIG9mIHNlZ21lbnRzXG4gICAgICAgIGlmKE4gJSAyID09PSAxIHx8IGkgPCBOIC8gMil7XG4gICAgICAgICAgICBheGVzLnB1c2gobmV3IFZlYzMoY29zKHRoZXRhTiksIHNpbih0aGV0YU4pLCAwKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmFjZXMucHVzaCh0b3BmYWNlKTtcbiAgICBheGVzLnB1c2gobmV3IFZlYzMoMCwwLDEpKTtcblxuICAgIC8vIFJlb3JkZXIgYm90dG9tIGZhY2VcbiAgICB2YXIgdGVtcCA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPGJvdHRvbWZhY2UubGVuZ3RoOyBpKyspe1xuICAgICAgICB0ZW1wLnB1c2goYm90dG9tZmFjZVtib3R0b21mYWNlLmxlbmd0aCAtIGkgLSAxXSk7XG4gICAgfVxuICAgIGZhY2VzLnB1c2godGVtcCk7XG5cbiAgICBDb252ZXhQb2x5aGVkcm9uLmNhbGwoIHRoaXMsIHZlcnRzLCBmYWNlcywgYXhlcyApO1xufVxuXG5DeWxpbmRlci5wcm90b3R5cGUgPSBuZXcgQ29udmV4UG9seWhlZHJvbigpO1xuIiwidmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpO1xudmFyIENvbnZleFBvbHloZWRyb24gPSByZXF1aXJlKCcuL0NvbnZleFBvbHloZWRyb24nKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlaWdodGZpZWxkO1xuXG4vKipcbiAqIEhlaWdodGZpZWxkIHNoYXBlIGNsYXNzLiBIZWlnaHQgZGF0YSBpcyBnaXZlbiBhcyBhbiBhcnJheS4gVGhlc2UgZGF0YSBwb2ludHMgYXJlIHNwcmVhZCBvdXQgZXZlbmx5IHdpdGggYSBnaXZlbiBkaXN0YW5jZS5cbiAqIEBjbGFzcyBIZWlnaHRmaWVsZFxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBbiBhcnJheSBvZiBZIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHRlcnJhaW4uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblZhbHVlXSBNaW5pbXVtIHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cyBpbiB0aGUgZGF0YSBhcnJheS4gV2lsbCBiZSBjb21wdXRlZCBhdXRvbWF0aWNhbGx5IGlmIG5vdCBnaXZlbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhWYWx1ZV0gTWF4aW11bSB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lbGVtZW50U2l6ZT0wLjFdIFdvcmxkIHNwYWNpbmcgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb24uXG4gKiBAdG9kbyBTaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIGFsb25nIGFsbCBheGVzLCBub3QganVzdCB5XG4gKiBAdG9kbyBzaG91bGQgYmUgcG9zc2libGUgdG8gc2NhbGUgYWxvbmcgYWxsIGF4ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIEdlbmVyYXRlIHNvbWUgaGVpZ2h0IGRhdGEgKHktdmFsdWVzKS5cbiAqICAgICB2YXIgZGF0YSA9IFtdO1xuICogICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxMDAwOyBpKyspe1xuICogICAgICAgICB2YXIgeSA9IDAuNSAqIE1hdGguY29zKDAuMiAqIGkpO1xuICogICAgICAgICBkYXRhLnB1c2goeSk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBDcmVhdGUgdGhlIGhlaWdodGZpZWxkIHNoYXBlXG4gKiAgICAgdmFyIGhlaWdodGZpZWxkU2hhcGUgPSBuZXcgSGVpZ2h0ZmllbGQoZGF0YSwge1xuICogICAgICAgICBlbGVtZW50U2l6ZTogMSAvLyBEaXN0YW5jZSBiZXR3ZWVuIHRoZSBkYXRhIHBvaW50cyBpbiBYIGFuZCBZIGRpcmVjdGlvbnNcbiAqICAgICB9KTtcbiAqICAgICB2YXIgaGVpZ2h0ZmllbGRCb2R5ID0gbmV3IEJvZHkoKTtcbiAqICAgICBoZWlnaHRmaWVsZEJvZHkuYWRkU2hhcGUoaGVpZ2h0ZmllbGRTaGFwZSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShoZWlnaHRmaWVsZEJvZHkpO1xuICovXG5mdW5jdGlvbiBIZWlnaHRmaWVsZChkYXRhLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBtYXhWYWx1ZSA6IG51bGwsXG4gICAgICAgIG1pblZhbHVlIDogbnVsbCxcbiAgICAgICAgZWxlbWVudFNpemUgOiAxXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBudW1iZXJzLCBvciBoZWlnaHQgdmFsdWVzLCB0aGF0IGFyZSBzcHJlYWQgb3V0IGFsb25nIHRoZSB4IGF4aXMuXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gZGF0YVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAvKipcbiAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGRhdGFcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4VmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLm1heFZhbHVlID0gb3B0aW9ucy5tYXhWYWx1ZTtcblxuICAgIC8qKlxuICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgZGF0YVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5WYWx1ZVxuICAgICAqL1xuICAgIHRoaXMubWluVmFsdWUgPSBvcHRpb25zLm1pblZhbHVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50U2l6ZVxuICAgICAqIEB0b2RvIGVsZW1lbnRTaXplWCBhbmQgWVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudFNpemUgPSBvcHRpb25zLmVsZW1lbnRTaXplO1xuXG4gICAgaWYob3B0aW9ucy5taW5WYWx1ZSA9PT0gbnVsbCl7XG4gICAgICAgIHRoaXMudXBkYXRlTWluVmFsdWUoKTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy5tYXhWYWx1ZSA9PT0gbnVsbCl7XG4gICAgICAgIHRoaXMudXBkYXRlTWF4VmFsdWUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNhY2hlRW5hYmxlZCA9IHRydWU7XG5cbiAgICBTaGFwZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuSEVJR0hURklFTERcbiAgICB9KTtcblxuICAgIHRoaXMucGlsbGFyQ29udmV4ID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcbiAgICB0aGlzLnBpbGxhck9mZnNldCA9IG5ldyBWZWMzKCk7XG5cbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG5cbiAgICAvLyBcImlfal9pc1VwcGVyXCIgPT4geyBjb252ZXg6IC4uLiwgb2Zmc2V0OiAuLi4gfVxuICAgIC8vIGZvciBleGFtcGxlOlxuICAgIC8vIF9jYWNoZWRQaWxsYXJzW1wiMF8yXzFcIl1cbiAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307XG59XG5IZWlnaHRmaWVsZC5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblxuLyoqXG4gKiBDYWxsIHdoZW5ldmVyIHlvdSBjaGFuZ2UgdGhlIGRhdGEgYXJyYXkuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLm1pblZhbHVlIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZU1pblZhbHVlXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVNaW5WYWx1ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG1pblZhbHVlID0gZGF0YVswXVswXTtcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaj0wOyBqICE9PSBkYXRhW2ldLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciB2ID0gZGF0YVtpXVtqXTtcbiAgICAgICAgICAgIGlmKHYgPCBtaW5WYWx1ZSl7XG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluVmFsdWUgPSBtaW5WYWx1ZTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSAubWF4VmFsdWUgcHJvcGVydHlcbiAqIEBtZXRob2QgdXBkYXRlTWF4VmFsdWVcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZU1heFZhbHVlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgbWF4VmFsdWUgPSBkYXRhWzBdWzBdO1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSBkYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGRhdGFbaV0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgdmFyIHYgPSBkYXRhW2ldW2pdO1xuICAgICAgICAgICAgaWYodiA+IG1heFZhbHVlKXtcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXhWYWx1ZSA9IG1heFZhbHVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGhlaWdodCB2YWx1ZSBhdCBhbiBpbmRleC4gRG9uJ3QgZm9yZ2V0IHRvIHVwZGF0ZSBtYXhWYWx1ZSBhbmQgbWluVmFsdWUgYWZ0ZXIgeW91J3JlIGRvbmUuXG4gKiBAbWV0aG9kIHNldEhlaWdodFZhbHVlQXRJbmRleFxuICogQHBhcmFtIHtpbnRlZ2VyfSB4aVxuICogQHBhcmFtIHtpbnRlZ2VyfSB5aVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5zZXRIZWlnaHRWYWx1ZUF0SW5kZXggPSBmdW5jdGlvbih4aSwgeWksIHZhbHVlKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBkYXRhW3hpXVt5aV0gPSB2YWx1ZTtcblxuICAgIC8vIEludmFsaWRhdGUgY2FjaGVcbiAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBmYWxzZSk7XG4gICAgaWYoeGkgPiAwKXtcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpIC0gMSwgeWksIHRydWUpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZih5aSA+IDApe1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpIC0gMSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWkgLSAxLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmKHlpID4gMCAmJiB4aSA+IDApe1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSAtIDEsIHRydWUpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IG1heC9taW4gaW4gYSByZWN0YW5nbGUgaW4gdGhlIG1hdHJpeCBkYXRhXG4gKiBAbWV0aG9kIGdldFJlY3RNaW5NYXhcbiAqIEBwYXJhbSAge2ludGVnZXJ9IGlNaW5YXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBpTWluWVxuICogQHBhcmFtICB7aW50ZWdlcn0gaU1heFhcbiAqIEBwYXJhbSAge2ludGVnZXJ9IGlNYXhZXG4gKiBAcGFyYW0gIHthcnJheX0gW3Jlc3VsdF0gQW4gYXJyYXkgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX0gVGhlIHJlc3VsdCBhcnJheSwgaWYgaXQgd2FzIHBhc3NlZCBpbi4gTWluaW11bSB3aWxsIGJlIGF0IHBvc2l0aW9uIDAgYW5kIG1heCBhdCAxLlxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0UmVjdE1pbk1heCA9IGZ1bmN0aW9uIChpTWluWCwgaU1pblksIGlNYXhYLCBpTWF4WSwgcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gICAgLy8gR2V0IG1heCBhbmQgbWluIG9mIHRoZSBkYXRhXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIG1heCA9IHRoaXMubWluVmFsdWU7IC8vIFNldCBmaXJzdCB2YWx1ZVxuICAgIGZvcih2YXIgaSA9IGlNaW5YOyBpIDw9IGlNYXhYOyBpKyspe1xuICAgICAgICBmb3IodmFyIGogPSBpTWluWTsgaiA8PSBpTWF4WTsgaisrKXtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2ldW2pdO1xuICAgICAgICAgICAgaWYoaGVpZ2h0ID4gbWF4KXtcbiAgICAgICAgICAgICAgICBtYXggPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHRbMF0gPSB0aGlzLm1pblZhbHVlO1xuICAgIHJlc3VsdFsxXSA9IG1heDtcbn07XG5cblxuXG4vKipcbiAqIEdldCB0aGUgaW5kZXggb2YgYSBsb2NhbCBwb3NpdGlvbiBvbiB0aGUgaGVpZ2h0ZmllbGQuIFRoZSBpbmRleGVzIGluZGljYXRlIHRoZSByZWN0YW5nbGVzLCBzbyBpZiB5b3VyIHRlcnJhaW4gaXMgbWFkZSBvZiBOIHggTiBoZWlnaHQgZGF0YSBwb2ludHMsIHlvdSB3aWxsIGhhdmUgcmVjdGFuZ2xlIGluZGV4ZXMgcmFuZ2luZyBmcm9tIDAgdG8gTi0xLlxuICogQG1ldGhvZCBnZXRJbmRleE9mUG9zaXRpb25cbiAqIEBwYXJhbSAge251bWJlcn0geFxuICogQHBhcmFtICB7bnVtYmVyfSB5XG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0IFR3by1lbGVtZW50IGFycmF5XG4gKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcCBJZiB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIGNsYW1wZWQgdG8gdGhlIGhlaWdodGZpZWxkIGVkZ2UuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0SW5kZXhPZlBvc2l0aW9uID0gZnVuY3Rpb24gKHgsIHksIHJlc3VsdCwgY2xhbXApIHtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxuICAgIHZhciB3ID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgeGkgPSBNYXRoLmZsb29yKHggLyB3KTtcbiAgICB2YXIgeWkgPSBNYXRoLmZsb29yKHkgLyB3KTtcblxuICAgIHJlc3VsdFswXSA9IHhpO1xuICAgIHJlc3VsdFsxXSA9IHlpO1xuXG4gICAgaWYoY2xhbXApe1xuICAgICAgICAvLyBDbGFtcCBpbmRleCB0byBlZGdlc1xuICAgICAgICBpZih4aSA8IDApeyB4aSA9IDA7IH1cbiAgICAgICAgaWYoeWkgPCAwKXsgeWkgPSAwOyB9XG4gICAgICAgIGlmKHhpID49IGRhdGEubGVuZ3RoIC0gMSl7IHhpID0gZGF0YS5sZW5ndGggLSAxOyB9XG4gICAgICAgIGlmKHlpID49IGRhdGFbMF0ubGVuZ3RoIC0gMSl7IHlpID0gZGF0YVswXS5sZW5ndGggLSAxOyB9XG4gICAgfVxuXG4gICAgLy8gQmFpbCBvdXQgaWYgd2UgYXJlIG91dCBvZiB0aGUgdGVycmFpblxuICAgIGlmKHhpIDwgMCB8fCB5aSA8IDAgfHwgeGkgPj0gZGF0YS5sZW5ndGgtMSB8fCB5aSA+PSBkYXRhWzBdLmxlbmd0aC0xKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG52YXIgZ2V0SGVpZ2h0QXRfaWR4ID0gW107XG52YXIgZ2V0SGVpZ2h0QXRfd2VpZ2h0cyA9IG5ldyBWZWMzKCk7XG52YXIgZ2V0SGVpZ2h0QXRfYSA9IG5ldyBWZWMzKCk7XG52YXIgZ2V0SGVpZ2h0QXRfYiA9IG5ldyBWZWMzKCk7XG52YXIgZ2V0SGVpZ2h0QXRfYyA9IG5ldyBWZWMzKCk7XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRUcmlhbmdsZUF0ID0gZnVuY3Rpb24oeCwgeSwgZWRnZUNsYW1wLCBhLCBiLCBjKXtcbiAgICB2YXIgaWR4ID0gZ2V0SGVpZ2h0QXRfaWR4O1xuICAgIHRoaXMuZ2V0SW5kZXhPZlBvc2l0aW9uKHgsIHksIGlkeCwgZWRnZUNsYW1wKTtcbiAgICB2YXIgeGkgPSBpZHhbMF07XG4gICAgdmFyIHlpID0gaWR4WzFdO1xuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgaWYoZWRnZUNsYW1wKXtcbiAgICAgICAgeGkgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIDIsIE1hdGgubWF4KDAsIHhpKSk7XG4gICAgICAgIHlpID0gTWF0aC5taW4oZGF0YVswXS5sZW5ndGggLSAyLCBNYXRoLm1heCgwLCB5aSkpO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50U2l6ZSA9IHRoaXMuZWxlbWVudFNpemU7XG4gICAgdmFyIGxvd2VyRGlzdDIgPSBNYXRoLnBvdyh4IC8gZWxlbWVudFNpemUgLSB4aSwgMikgKyBNYXRoLnBvdyh5IC8gZWxlbWVudFNpemUgLSB5aSwgMik7XG4gICAgdmFyIHVwcGVyRGlzdDIgPSBNYXRoLnBvdyh4IC8gZWxlbWVudFNpemUgLSAoeGkgKyAxKSwgMikgKyBNYXRoLnBvdyh5IC8gZWxlbWVudFNpemUgLSAoeWkgKyAxKSwgMik7XG4gICAgdmFyIHVwcGVyID0gbG93ZXJEaXN0MiA+IHVwcGVyRGlzdDI7XG4gICAgdGhpcy5nZXRUcmlhbmdsZSh4aSwgeWksIHVwcGVyLCBhLCBiLCBjKTtcbiAgICByZXR1cm4gdXBwZXI7XG59O1xuXG52YXIgZ2V0Tm9ybWFsQXRfYSA9IG5ldyBWZWMzKCk7XG52YXIgZ2V0Tm9ybWFsQXRfYiA9IG5ldyBWZWMzKCk7XG52YXIgZ2V0Tm9ybWFsQXRfYyA9IG5ldyBWZWMzKCk7XG52YXIgZ2V0Tm9ybWFsQXRfZTAgPSBuZXcgVmVjMygpO1xudmFyIGdldE5vcm1hbEF0X2UxID0gbmV3IFZlYzMoKTtcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXROb3JtYWxBdCA9IGZ1bmN0aW9uKHgsIHksIGVkZ2VDbGFtcCwgcmVzdWx0KXtcbiAgICB2YXIgYSA9IGdldE5vcm1hbEF0X2E7XG4gICAgdmFyIGIgPSBnZXROb3JtYWxBdF9iO1xuICAgIHZhciBjID0gZ2V0Tm9ybWFsQXRfYztcbiAgICB2YXIgZTAgPSBnZXROb3JtYWxBdF9lMDtcbiAgICB2YXIgZTEgPSBnZXROb3JtYWxBdF9lMTtcbiAgICB0aGlzLmdldFRyaWFuZ2xlQXQoeCwgeSwgZWRnZUNsYW1wLCBhLCBiLCBjKTtcbiAgICBiLnZzdWIoYSwgZTApO1xuICAgIGMudnN1YihhLCBlMSk7XG4gICAgZTAuY3Jvc3MoZTEsIHJlc3VsdCk7XG4gICAgcmVzdWx0Lm5vcm1hbGl6ZSgpO1xufTtcblxuXG4vKipcbiAqIEdldCBhbiBBQUJCIG9mIGEgc3F1YXJlIGluIHRoZSBoZWlnaHRmaWVsZFxuICogQHBhcmFtICB7bnVtYmVyfSB4aVxuICogQHBhcmFtICB7bnVtYmVyfSB5aVxuICogQHBhcmFtICB7QUFCQn0gcmVzdWx0XG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRBYWJiQXRJbmRleCA9IGZ1bmN0aW9uKHhpLCB5aSwgcmVzdWx0KXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZWxlbWVudFNpemUgPSB0aGlzLmVsZW1lbnRTaXplO1xuXG4gICAgcmVzdWx0Lmxvd2VyQm91bmQuc2V0KFxuICAgICAgICB4aSAqIGVsZW1lbnRTaXplLFxuICAgICAgICB5aSAqIGVsZW1lbnRTaXplLFxuICAgICAgICBkYXRhW3hpXVt5aV1cbiAgICApO1xuICAgIHJlc3VsdC51cHBlckJvdW5kLnNldChcbiAgICAgICAgKHhpICsgMSkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgZGF0YVt4aSArIDFdW3lpICsgMV1cbiAgICApO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgaGVpZ2h0IGluIHRoZSBoZWlnaHRmaWVsZCBhdCBhIGdpdmVuIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSAge251bWJlcn0geVxuICogQHBhcmFtICB7Ym9vbGVhbn0gZWRnZUNsYW1wXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRIZWlnaHRBdCA9IGZ1bmN0aW9uKHgsIHksIGVkZ2VDbGFtcCl7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGEgPSBnZXRIZWlnaHRBdF9hO1xuICAgIHZhciBiID0gZ2V0SGVpZ2h0QXRfYjtcbiAgICB2YXIgYyA9IGdldEhlaWdodEF0X2M7XG4gICAgdmFyIGlkeCA9IGdldEhlaWdodEF0X2lkeDtcblxuICAgIHRoaXMuZ2V0SW5kZXhPZlBvc2l0aW9uKHgsIHksIGlkeCwgZWRnZUNsYW1wKTtcbiAgICB2YXIgeGkgPSBpZHhbMF07XG4gICAgdmFyIHlpID0gaWR4WzFdO1xuICAgIGlmKGVkZ2VDbGFtcCl7XG4gICAgICAgIHhpID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSAyLCBNYXRoLm1heCgwLCB4aSkpO1xuICAgICAgICB5aSA9IE1hdGgubWluKGRhdGFbMF0ubGVuZ3RoIC0gMiwgTWF0aC5tYXgoMCwgeWkpKTtcbiAgICB9XG4gICAgdmFyIHVwcGVyID0gdGhpcy5nZXRUcmlhbmdsZUF0KHgsIHksIGVkZ2VDbGFtcCwgYSwgYiwgYyk7XG4gICAgYmFyeWNlbnRyaWNXZWlnaHRzKHgsIHksIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIGdldEhlaWdodEF0X3dlaWdodHMpO1xuXG4gICAgdmFyIHcgPSBnZXRIZWlnaHRBdF93ZWlnaHRzO1xuXG4gICAgaWYodXBwZXIpe1xuXG4gICAgICAgIC8vIFRvcCB0cmlhbmdsZSB2ZXJ0c1xuICAgICAgICByZXR1cm4gZGF0YVt4aSArIDFdW3lpICsgMV0gKiB3LnggKyBkYXRhW3hpXVt5aSArIDFdICogdy55ICsgZGF0YVt4aSArIDFdW3lpXSAqIHcuejtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgIHJldHVybiBkYXRhW3hpXVt5aV0gKiB3LnggKyBkYXRhW3hpICsgMV1beWldICogdy55ICsgZGF0YVt4aV1beWkgKyAxXSAqIHcuejtcbiAgICB9XG59O1xuXG4vLyBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JhcnljZW50cmljX2Nvb3JkaW5hdGVfc3lzdGVtXG5mdW5jdGlvbiBiYXJ5Y2VudHJpY1dlaWdodHMoeCwgeSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcmVzdWx0KXtcbiAgICByZXN1bHQueCA9ICgoYnkgLSBjeSkgKiAoeCAtIGN4KSArIChjeCAtIGJ4KSAqICh5IC0gY3kpKSAvICgoYnkgLSBjeSkgKiAoYXggLSBjeCkgKyAoY3ggLSBieCkgKiAoYXkgLSBjeSkpO1xuICAgIHJlc3VsdC55ID0gKChjeSAtIGF5KSAqICh4IC0gY3gpICsgKGF4IC0gY3gpICogKHkgLSBjeSkpIC8gKChieSAtIGN5KSAqIChheCAtIGN4KSArIChjeCAtIGJ4KSAqIChheSAtIGN5KSk7XG4gICAgcmVzdWx0LnogPSAxIC0gcmVzdWx0LnggLSByZXN1bHQueTtcbn1cblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldENhY2hlQ29udmV4VHJpYW5nbGVQaWxsYXJLZXkgPSBmdW5jdGlvbih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpe1xuICAgIHJldHVybiB4aSArICdfJyArIHlpICsgJ18nICsgKGdldFVwcGVyVHJpYW5nbGUgPyAxIDogMCk7XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIgPSBmdW5jdGlvbih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpe1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRQaWxsYXJzW3RoaXMuZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSh4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpXTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5zZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhciA9IGZ1bmN0aW9uKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSwgY29udmV4LCBvZmZzZXQpe1xuICAgIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldID0ge1xuICAgICAgICBjb252ZXg6IGNvbnZleCxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICB9O1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIgPSBmdW5jdGlvbih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpe1xuICAgIGRlbGV0ZSB0aGlzLl9jYWNoZWRQaWxsYXJzW3RoaXMuZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSh4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpXTtcbn07XG5cbi8qKlxuICogR2V0IGEgdHJpYW5nbGUgZnJvbSB0aGUgaGVpZ2h0ZmllbGRcbiAqIEBwYXJhbSAge251bWJlcn0geGlcbiAqIEBwYXJhbSAge251bWJlcn0geWlcbiAqIEBwYXJhbSAge2Jvb2xlYW59IHVwcGVyXG4gKiBAcGFyYW0gIHtWZWMzfSBhXG4gKiBAcGFyYW0gIHtWZWMzfSBiXG4gKiBAcGFyYW0gIHtWZWMzfSBjXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRUcmlhbmdsZSA9IGZ1bmN0aW9uKHhpLCB5aSwgdXBwZXIsIGEsIGIsIGMpe1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBlbGVtZW50U2l6ZSA9IHRoaXMuZWxlbWVudFNpemU7XG5cbiAgICBpZih1cHBlcil7XG5cbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgIGEuc2V0KFxuICAgICAgICAgICAgKHhpICsgMSkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICh5aSArIDEpICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICBkYXRhW3hpICsgMV1beWkgKyAxXVxuICAgICAgICApO1xuICAgICAgICBiLnNldChcbiAgICAgICAgICAgIHhpICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAoeWkgKyAxKSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aV1beWkgKyAxXVxuICAgICAgICApO1xuICAgICAgICBjLnNldChcbiAgICAgICAgICAgICh4aSArIDEpICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICB5aSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpXVxuICAgICAgICApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHNcbiAgICAgICAgYS5zZXQoXG4gICAgICAgICAgICB4aSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgeWkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGRhdGFbeGldW3lpXVxuICAgICAgICApO1xuICAgICAgICBiLnNldChcbiAgICAgICAgICAgICh4aSArIDEpICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICB5aSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpXVxuICAgICAgICApO1xuICAgICAgICBjLnNldChcbiAgICAgICAgICAgIHhpICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAoeWkgKyAxKSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aV1beWkgKyAxXVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGEgdHJpYW5nbGUgaW4gdGhlIHRlcnJhaW4gaW4gdGhlIGZvcm0gb2YgYSB0cmlhbmd1bGFyIGNvbnZleCBzaGFwZS5cbiAqIEBtZXRob2QgZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXJcbiAqIEBwYXJhbSAge2ludGVnZXJ9IGlcbiAqIEBwYXJhbSAge2ludGVnZXJ9IGpcbiAqIEBwYXJhbSAge2Jvb2xlYW59IGdldFVwcGVyVHJpYW5nbGVcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyID0gZnVuY3Rpb24oeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKXtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5waWxsYXJDb252ZXg7XG4gICAgdmFyIG9mZnNldFJlc3VsdCA9IHRoaXMucGlsbGFyT2Zmc2V0O1xuXG4gICAgaWYodGhpcy5jYWNoZUVuYWJsZWQpe1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKTtcbiAgICAgICAgaWYoZGF0YSl7XG4gICAgICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IGRhdGEuY29udmV4O1xuICAgICAgICAgICAgdGhpcy5waWxsYXJPZmZzZXQgPSBkYXRhLm9mZnNldDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7XG4gICAgICAgIG9mZnNldFJlc3VsdCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgdGhpcy5waWxsYXJDb252ZXggPSByZXN1bHQ7XG4gICAgICAgIHRoaXMucGlsbGFyT2Zmc2V0ID0gb2Zmc2V0UmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBlbGVtZW50U2l6ZSA9IHRoaXMuZWxlbWVudFNpemU7XG4gICAgdmFyIGZhY2VzID0gcmVzdWx0LmZhY2VzO1xuXG4gICAgLy8gUmV1c2UgdmVydHMgaWYgcG9zc2libGVcbiAgICByZXN1bHQudmVydGljZXMubGVuZ3RoID0gNjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICBpZighcmVzdWx0LnZlcnRpY2VzW2ldKXtcbiAgICAgICAgICAgIHJlc3VsdC52ZXJ0aWNlc1tpXSA9IG5ldyBWZWMzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXVzZSBmYWNlcyBpZiBwb3NzaWJsZVxuICAgIGZhY2VzLmxlbmd0aCA9IDU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgaWYoIWZhY2VzW2ldKXtcbiAgICAgICAgICAgIGZhY2VzW2ldID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmVydHMgPSByZXN1bHQudmVydGljZXM7XG5cbiAgICB2YXIgaCA9IChNYXRoLm1pbihcbiAgICAgICAgZGF0YVt4aV1beWldLFxuICAgICAgICBkYXRhW3hpKzFdW3lpXSxcbiAgICAgICAgZGF0YVt4aV1beWkrMV0sXG4gICAgICAgIGRhdGFbeGkrMV1beWkrMV1cbiAgICApIC0gdGhpcy5taW5WYWx1ZSApIC8gMiArIHRoaXMubWluVmFsdWU7XG5cbiAgICBpZiAoIWdldFVwcGVyVHJpYW5nbGUpIHtcblxuICAgICAgICAvLyBDZW50ZXIgb2YgdGhlIHRyaWFuZ2xlIHBpbGxhciAtIGFsbCBwb2x5Z29ucyBhcmUgZ2l2ZW4gcmVsYXRpdmUgdG8gdGhpcyBvbmVcbiAgICAgICAgb2Zmc2V0UmVzdWx0LnNldChcbiAgICAgICAgICAgICh4aSArIDAuMjUpICogZWxlbWVudFNpemUsIC8vIHNvcnQgb2YgY2VudGVyIG9mIGEgdHJpYW5nbGVcbiAgICAgICAgICAgICh5aSArIDAuMjUpICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICBoIC8vIHZlcnRpY2FsIGNlbnRlclxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFRvcCB0cmlhbmdsZSB2ZXJ0c1xuICAgICAgICB2ZXJ0c1swXS5zZXQoXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGRhdGFbeGldW3lpXSAtIGhcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHNbMV0uc2V0KFxuICAgICAgICAgICAgMC43NSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGRhdGFbeGkgKyAxXVt5aV0gLSBoXG4gICAgICAgICk7XG4gICAgICAgIHZlcnRzWzJdLnNldChcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAwLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICBkYXRhW3hpXVt5aSArIDFdIC0gaFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGJvdHRvbSB0cmlhbmdsZSB2ZXJ0c1xuICAgICAgICB2ZXJ0c1szXS5zZXQoXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIC1oLTFcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHNbNF0uc2V0KFxuICAgICAgICAgICAgMC43NSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIC1oLTFcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHNbNV0uc2V0KFxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIDAuNzUgICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtaC0xXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdG9wIHRyaWFuZ2xlXG4gICAgICAgIGZhY2VzWzBdWzBdID0gMDtcbiAgICAgICAgZmFjZXNbMF1bMV0gPSAxO1xuICAgICAgICBmYWNlc1swXVsyXSA9IDI7XG5cbiAgICAgICAgLy8gYm90dG9tIHRyaWFuZ2xlXG4gICAgICAgIGZhY2VzWzFdWzBdID0gNTtcbiAgICAgICAgZmFjZXNbMV1bMV0gPSA0O1xuICAgICAgICBmYWNlc1sxXVsyXSA9IDM7XG5cbiAgICAgICAgLy8gLXggZmFjaW5nIHF1YWRcbiAgICAgICAgZmFjZXNbMl1bMF0gPSAwO1xuICAgICAgICBmYWNlc1syXVsxXSA9IDI7XG4gICAgICAgIGZhY2VzWzJdWzJdID0gNTtcbiAgICAgICAgZmFjZXNbMl1bM10gPSAzO1xuXG4gICAgICAgIC8vIC15IGZhY2luZyBxdWFkXG4gICAgICAgIGZhY2VzWzNdWzBdID0gMTtcbiAgICAgICAgZmFjZXNbM11bMV0gPSAwO1xuICAgICAgICBmYWNlc1szXVsyXSA9IDM7XG4gICAgICAgIGZhY2VzWzNdWzNdID0gNDtcblxuICAgICAgICAvLyAreHkgZmFjaW5nIHF1YWRcbiAgICAgICAgZmFjZXNbNF1bMF0gPSA0O1xuICAgICAgICBmYWNlc1s0XVsxXSA9IDU7XG4gICAgICAgIGZhY2VzWzRdWzJdID0gMjtcbiAgICAgICAgZmFjZXNbNF1bM10gPSAxO1xuXG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIENlbnRlciBvZiB0aGUgdHJpYW5nbGUgcGlsbGFyIC0gYWxsIHBvbHlnb25zIGFyZSBnaXZlbiByZWxhdGl2ZSB0byB0aGlzIG9uZVxuICAgICAgICBvZmZzZXRSZXN1bHQuc2V0KFxuICAgICAgICAgICAgKHhpICsgMC43NSkgKiBlbGVtZW50U2l6ZSwgLy8gc29ydCBvZiBjZW50ZXIgb2YgYSB0cmlhbmdsZVxuICAgICAgICAgICAgKHlpICsgMC43NSkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGggLy8gdmVydGljYWwgY2VudGVyXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgIHZlcnRzWzBdLnNldChcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGRhdGFbeGkgKyAxXVt5aSArIDFdIC0gaFxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1sxXS5zZXQoXG4gICAgICAgICAgICAtMC43NSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aV1beWkgKyAxXSAtIGhcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHNbMl0uc2V0KFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLTAuNzUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGRhdGFbeGkgKyAxXVt5aV0gLSBoXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYm90dG9tIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgIHZlcnRzWzNdLnNldChcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIC0gaC0xXG4gICAgICAgICk7XG4gICAgICAgIHZlcnRzWzRdLnNldChcbiAgICAgICAgICAgIC0wLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtIGgtMVxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1s1XS5zZXQoXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC43NSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLSBoLTFcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBUb3AgdHJpYW5nbGVcbiAgICAgICAgZmFjZXNbMF1bMF0gPSAwO1xuICAgICAgICBmYWNlc1swXVsxXSA9IDE7XG4gICAgICAgIGZhY2VzWzBdWzJdID0gMjtcblxuICAgICAgICAvLyBib3R0b20gdHJpYW5nbGVcbiAgICAgICAgZmFjZXNbMV1bMF0gPSA1O1xuICAgICAgICBmYWNlc1sxXVsxXSA9IDQ7XG4gICAgICAgIGZhY2VzWzFdWzJdID0gMztcblxuICAgICAgICAvLyAreCBmYWNpbmcgcXVhZFxuICAgICAgICBmYWNlc1syXVswXSA9IDI7XG4gICAgICAgIGZhY2VzWzJdWzFdID0gNTtcbiAgICAgICAgZmFjZXNbMl1bMl0gPSAzO1xuICAgICAgICBmYWNlc1syXVszXSA9IDA7XG5cbiAgICAgICAgLy8gK3kgZmFjaW5nIHF1YWRcbiAgICAgICAgZmFjZXNbM11bMF0gPSAzO1xuICAgICAgICBmYWNlc1szXVsxXSA9IDQ7XG4gICAgICAgIGZhY2VzWzNdWzJdID0gMTtcbiAgICAgICAgZmFjZXNbM11bM10gPSAwO1xuXG4gICAgICAgIC8vIC14eSBmYWNpbmcgcXVhZFxuICAgICAgICBmYWNlc1s0XVswXSA9IDE7XG4gICAgICAgIGZhY2VzWzRdWzFdID0gNDtcbiAgICAgICAgZmFjZXNbNF1bMl0gPSA1O1xuICAgICAgICBmYWNlc1s0XVszXSA9IDI7XG4gICAgfVxuXG4gICAgcmVzdWx0LmNvbXB1dGVOb3JtYWxzKCk7XG4gICAgcmVzdWx0LmNvbXB1dGVFZGdlcygpO1xuICAgIHJlc3VsdC51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xuXG4gICAgdGhpcy5zZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUsIHJlc3VsdCwgb2Zmc2V0UmVzdWx0KTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLCB0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHRhcmdldC5zZXQoMCwgMCwgMCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFOyAvLyBUaGUgdGVycmFpbiBpcyBpbmZpbml0ZVxufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcywgcXVhdCwgbWluLCBtYXgpe1xuICAgIC8vIFRPRE86IGRvIGl0IHByb3Blcmx5XG4gICAgbWluLnNldCgtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICBtYXguc2V0KE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICAvLyBVc2UgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgbWluL21heCB2YWx1ZXNcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgcyA9IHRoaXMuZWxlbWVudFNpemU7XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IG5ldyBWZWMzKGRhdGEubGVuZ3RoICogcywgZGF0YVswXS5sZW5ndGggKiBzLCBNYXRoLm1heChNYXRoLmFicyh0aGlzLm1heFZhbHVlKSwgTWF0aC5hYnModGhpcy5taW5WYWx1ZSkpKS5ub3JtKCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGhlaWdodCB2YWx1ZXMgZnJvbSBhbiBpbWFnZS4gQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXIuXG4gKiBAbWV0aG9kIHNldEhlaWdodHNGcm9tSW1hZ2VcbiAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gKiBAcGFyYW0ge1ZlYzN9IHNjYWxlXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5zZXRIZWlnaHRzRnJvbUltYWdlID0gZnVuY3Rpb24oaW1hZ2UsIHNjYWxlKXtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICB2YXIgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG5cbiAgICB2YXIgbWF0cml4ID0gdGhpcy5kYXRhO1xuICAgIG1hdHJpeC5sZW5ndGggPSAwO1xuICAgIHRoaXMuZWxlbWVudFNpemUgPSBNYXRoLmFicyhzY2FsZS54KSAvIGltYWdlRGF0YS53aWR0aDtcbiAgICBmb3IodmFyIGk9MDsgaTxpbWFnZURhdGEuaGVpZ2h0OyBpKyspe1xuICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPGltYWdlRGF0YS53aWR0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBhID0gaW1hZ2VEYXRhLmRhdGFbKGkqaW1hZ2VEYXRhLmhlaWdodCArIGopICogNF07XG4gICAgICAgICAgICB2YXIgYiA9IGltYWdlRGF0YS5kYXRhWyhpKmltYWdlRGF0YS5oZWlnaHQgKyBqKSAqIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciBjID0gaW1hZ2VEYXRhLmRhdGFbKGkqaW1hZ2VEYXRhLmhlaWdodCArIGopICogNCArIDJdO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IChhICsgYiArIGMpIC8gNCAvIDI1NSAqIHNjYWxlLno7XG4gICAgICAgICAgICBpZihzY2FsZS54IDwgMCl7XG4gICAgICAgICAgICAgICAgcm93LnB1c2goaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93LnVuc2hpZnQoaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZihzY2FsZS55IDwgMCl7XG4gICAgICAgICAgICBtYXRyaXgudW5zaGlmdChyb3cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0cml4LnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU1heFZhbHVlKCk7XG4gICAgdGhpcy51cGRhdGVNaW5WYWx1ZSgpO1xuICAgIHRoaXMudXBkYXRlKCk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gUGFydGljbGU7XG5cbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4vU2hhcGUnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG5cbi8qKlxuICogUGFydGljbGUgc2hhcGUuXG4gKiBAY2xhc3MgUGFydGljbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqL1xuZnVuY3Rpb24gUGFydGljbGUoKXtcbiAgICBTaGFwZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuUEFSVElDTEVcbiAgICB9KTtcbn1cblBhcnRpY2xlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuUGFydGljbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGljbGU7XG5cbi8qKlxuICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHRhcmdldC5zZXQoMCwgMCwgMCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cblBhcnRpY2xlLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAwO1xufTtcblxuUGFydGljbGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gMDtcbn07XG5cblBhcnRpY2xlLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MscXVhdCxtaW4sbWF4KXtcbiAgICAvLyBHZXQgZWFjaCBheGlzIG1heFxuICAgIG1pbi5jb3B5KHBvcyk7XG4gICAgbWF4LmNvcHkocG9zKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFBsYW5lO1xuXG52YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xuXG4vKipcbiAqIEEgcGxhbmUsIGZhY2luZyBpbiB0aGUgWiBkaXJlY3Rpb24uIFRoZSBwbGFuZSBoYXMgaXRzIHN1cmZhY2UgYXQgej0wIGFuZCBldmVyeXRoaW5nIGJlbG93IHo9MCBpcyBhc3N1bWVkIHRvIGJlIHNvbGlkIHBsYW5lLiBUbyBtYWtlIHRoZSBwbGFuZSBmYWNlIGluIHNvbWUgb3RoZXIgZGlyZWN0aW9uIHRoYW4geiwgeW91IG11c3QgcHV0IGl0IGluc2lkZSBhIEJvZHkgYW5kIHJvdGF0ZSB0aGF0IGJvZHkuIFNlZSB0aGUgZGVtb3MuXG4gKiBAY2xhc3MgUGxhbmVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gUGxhbmUoKXtcbiAgICBTaGFwZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuUExBTkVcbiAgICB9KTtcblxuICAgIC8vIFdvcmxkIG9yaWVudGVkIG5vcm1hbFxuICAgIHRoaXMud29ybGROb3JtYWwgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMud29ybGROb3JtYWxOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn1cblBsYW5lLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuUGxhbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxhbmU7XG5cblBsYW5lLnByb3RvdHlwZS5jb21wdXRlV29ybGROb3JtYWwgPSBmdW5jdGlvbihxdWF0KXtcbiAgICB2YXIgbiA9IHRoaXMud29ybGROb3JtYWw7XG4gICAgbi5zZXQoMCwwLDEpO1xuICAgIHF1YXQudm11bHQobixuKTtcbiAgICB0aGlzLndvcmxkTm9ybWFsTmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cblBsYW5lLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cblBsYW5lLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFOyAvLyBUaGUgcGxhbmUgaXMgaW5maW5pdGUuLi5cbn07XG5cbnZhciB0ZW1wTm9ybWFsID0gbmV3IFZlYzMoKTtcblBsYW5lLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MsIHF1YXQsIG1pbiwgbWF4KXtcbiAgICAvLyBUaGUgcGxhbmUgQUFCQiBpcyBpbmZpbml0ZSwgZXhjZXB0IGlmIHRoZSBub3JtYWwgaXMgcG9pbnRpbmcgYWxvbmcgYW55IGF4aXNcbiAgICB0ZW1wTm9ybWFsLnNldCgwLDAsMSk7IC8vIERlZmF1bHQgcGxhbmUgbm9ybWFsIGlzIHpcbiAgICBxdWF0LnZtdWx0KHRlbXBOb3JtYWwsdGVtcE5vcm1hbCk7XG4gICAgdmFyIG1heFZhbCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgbWluLnNldCgtbWF4VmFsLCAtbWF4VmFsLCAtbWF4VmFsKTtcbiAgICBtYXguc2V0KG1heFZhbCwgbWF4VmFsLCBtYXhWYWwpO1xuXG4gICAgaWYodGVtcE5vcm1hbC54ID09PSAxKXsgbWF4LnggPSBwb3MueDsgfVxuICAgIGlmKHRlbXBOb3JtYWwueSA9PT0gMSl7IG1heC55ID0gcG9zLnk7IH1cbiAgICBpZih0ZW1wTm9ybWFsLnogPT09IDEpeyBtYXgueiA9IHBvcy56OyB9XG5cbiAgICBpZih0ZW1wTm9ybWFsLnggPT09IC0xKXsgbWluLnggPSBwb3MueDsgfVxuICAgIGlmKHRlbXBOb3JtYWwueSA9PT0gLTEpeyBtaW4ueSA9IHBvcy55OyB9XG4gICAgaWYodGVtcE5vcm1hbC56ID09PSAtMSl7IG1pbi56ID0gcG9zLno7IH1cbn07XG5cblBsYW5lLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gU2hhcGU7XG5cbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4vU2hhcGUnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIE1hdGVyaWFsID0gcmVxdWlyZSgnLi4vbWF0ZXJpYWwvTWF0ZXJpYWwnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBzaGFwZXNcbiAqIEBjbGFzcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrPS0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF0ZXJpYWw9bnVsbF1cbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gU2hhcGUob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmeWVyIG9mIHRoZSBTaGFwZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaWRcbiAgICAgKi9cbiAgICB0aGlzLmlkID0gU2hhcGUuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIHNoYXBlLiBNdXN0IGJlIHNldCB0byBhbiBpbnQgPiAwIGJ5IHN1YmNsYXNzZXMuXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBzZWUgU2hhcGUudHlwZXNcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbCBib3VuZGluZyBzcGhlcmUgcmFkaXVzIG9mIHRoaXMgc2hhcGUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGJvdW5kaW5nU3BoZXJlUmFkaXVzXG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBjb2xsaXNpb25SZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlID8gb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29sbGlzaW9uRmlsdGVyR3JvdXBcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwID0gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29sbGlzaW9uRmlsdGVyTWFza1xuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrIDogLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge01hdGVyaWFsfSBtYXRlcmlhbFxuICAgICAqL1xuICAgIHRoaXMubWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsID8gb3B0aW9ucy5tYXRlcmlhbCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlcbiAgICAgKi9cbiAgICB0aGlzLmJvZHkgPSBudWxsO1xufVxuU2hhcGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGU7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMuIFRoZSByZXN1bHQgaXMgc3RvcmVkIGluIHRoZSBwcm9wZXJ0eSAuYm91bmRpbmdTcGhlcmVSYWRpdXNcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXNcbiAqL1xuU2hhcGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBcImNvbXB1dGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSBcIit0aGlzLnR5cGU7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdm9sdW1lIG9mIHRoaXMgc2hhcGVcbiAqIEBtZXRob2Qgdm9sdW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblNoYXBlLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHRocm93IFwidm9sdW1lKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlIFwiK3RoaXMudHlwZTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW5lcnRpYSBpbiB0aGUgbG9jYWwgZnJhbWUgZm9yIHRoaXMgc2hhcGUuXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxuICogQHBhcmFtIHtOdW1iZXJ9IG1hc3NcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XG4gKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcbiAqL1xuU2hhcGUucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsdGFyZ2V0KXtcbiAgICB0aHJvdyBcImNhbGN1bGF0ZUxvY2FsSW5lcnRpYSgpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSBcIit0aGlzLnR5cGU7XG59O1xuXG5TaGFwZS5pZENvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFRoZSBhdmFpbGFibGUgc2hhcGUgdHlwZXMuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkgdHlwZXNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblNoYXBlLnR5cGVzID0ge1xuICAgIFNQSEVSRToxLFxuICAgIFBMQU5FOjIsXG4gICAgQk9YOjQsXG4gICAgQ09NUE9VTkQ6OCxcbiAgICBDT05WRVhQT0xZSEVEUk9OOjE2LFxuICAgIEhFSUdIVEZJRUxEOjMyLFxuICAgIFBBUlRJQ0xFOjY0LFxuICAgIENZTElOREVSOjEyOCxcbiAgICBUUklNRVNIOjI1NlxufTtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSBTcGhlcmU7XG5cbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4vU2hhcGUnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG5cbi8qKlxuICogU3BoZXJpY2FsIHNoYXBlXG4gKiBAY2xhc3MgU3BoZXJlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFRoZSByYWRpdXMgb2YgdGhlIHNwaGVyZSwgYSBub24tbmVnYXRpdmUgbnVtYmVyLlxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHA6Ly9naXRodWIuY29tL3NjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIFNwaGVyZShyYWRpdXMpe1xuICAgIFNoYXBlLmNhbGwodGhpcywge1xuICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5TUEhFUkVcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyAhPT0gdW5kZWZpbmVkID8gcmFkaXVzIDogMS4wO1xuXG4gICAgaWYodGhpcy5yYWRpdXMgPCAwKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3BoZXJlIHJhZGl1cyBjYW5ub3QgYmUgbmVnYXRpdmUuJyk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xufVxuU3BoZXJlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuU3BoZXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwaGVyZTtcblxuU3BoZXJlLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdmFyIEkgPSAyLjAqbWFzcyp0aGlzLnJhZGl1cyp0aGlzLnJhZGl1cy81LjA7XG4gICAgdGFyZ2V0LnggPSBJO1xuICAgIHRhcmdldC55ID0gSTtcbiAgICB0YXJnZXQueiA9IEk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cblNwaGVyZS5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gNC4wICogTWF0aC5QSSAqIHRoaXMucmFkaXVzIC8gMy4wO1xufTtcblxuU3BoZXJlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IHRoaXMucmFkaXVzO1xufTtcblxuU3BoZXJlLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MscXVhdCxtaW4sbWF4KXtcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xuICAgIHZhciBheGVzID0gWyd4JywneScsJ3onXTtcbiAgICBmb3IodmFyIGk9MDsgaTxheGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGF4ID0gYXhlc1tpXTtcbiAgICAgICAgbWluW2F4XSA9IHBvc1theF0gLSByO1xuICAgICAgICBtYXhbYXhdID0gcG9zW2F4XSArIHI7XG4gICAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gVHJpbWVzaDtcblxudmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcbnZhciBBQUJCID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL0FBQkInKTtcbnZhciBPY3RyZWUgPSByZXF1aXJlKCcuLi91dGlscy9PY3RyZWUnKTtcblxuLyoqXG4gKiBAY2xhc3MgVHJpbWVzaFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2FycmF5fSB2ZXJ0aWNlc1xuICogQHBhcmFtIHthcnJheX0gaW5kaWNlc1xuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gSG93IHRvIG1ha2UgYSBtZXNoIHdpdGggYSBzaW5nbGUgdHJpYW5nbGVcbiAqICAgICB2YXIgdmVydGljZXMgPSBbXG4gKiAgICAgICAgIDAsIDAsIDAsIC8vIHZlcnRleCAwXG4gKiAgICAgICAgIDEsIDAsIDAsIC8vIHZlcnRleCAxXG4gKiAgICAgICAgIDAsIDEsIDAgIC8vIHZlcnRleCAyXG4gKiAgICAgXTtcbiAqICAgICB2YXIgaW5kaWNlcyA9IFtcbiAqICAgICAgICAgMCwgMSwgMiAgLy8gdHJpYW5nbGUgMFxuICogICAgIF07XG4gKiAgICAgdmFyIHRyaW1lc2hTaGFwZSA9IG5ldyBUcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAqL1xuZnVuY3Rpb24gVHJpbWVzaCh2ZXJ0aWNlcywgaW5kaWNlcykge1xuICAgIFNoYXBlLmNhbGwodGhpcywge1xuICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5UUklNRVNIXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgaW50ZWdlcnMsIGluZGljYXRpbmcgd2hpY2ggdmVydGljZXMgZWFjaCB0cmlhbmdsZSBjb25zaXN0cyBvZi4gVGhlIGxlbmd0aCBvZiB0aGlzIGFycmF5IGlzIHRodXMgMyB0aW1lcyB0aGUgbnVtYmVyIG9mIHRyaWFuZ2xlcy5cbiAgICAgKiBAcHJvcGVydHkgaW5kaWNlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmluZGljZXMgPSBuZXcgSW50MTZBcnJheShpbmRpY2VzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBub3JtYWxzIGRhdGEuXG4gICAgICogQHByb3BlcnR5IG5vcm1hbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShpbmRpY2VzLmxlbmd0aCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWwgQUFCQiBvZiB0aGUgbWVzaC5cbiAgICAgKiBAcHJvcGVydHkgYWFiYlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlcyB0byB2ZXJ0ZXggcGFpcnMsIG1ha2luZyB1cCBhbGwgdW5pcXVlIGVkZ2VzIGluIHRoZSB0cmltZXNoLlxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGVkZ2VzXG4gICAgICovXG4gICAgdGhpcy5lZGdlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCBzY2FsaW5nIG9mIHRoZSBtZXNoLiBVc2UgLnNldFNjYWxlKCkgdG8gc2V0IGl0LlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gc2NhbGVcbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlID0gbmV3IFZlYzMoMSwgMSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXhlZCB0cmlhbmdsZXMuIFVzZSAudXBkYXRlVHJlZSgpIHRvIHVwZGF0ZSBpdC5cbiAgICAgKiBAcHJvcGVydHkge09jdHJlZX0gdHJlZVxuICAgICAqL1xuICAgIHRoaXMudHJlZSA9IG5ldyBPY3RyZWUoKTtcblxuICAgIHRoaXMudXBkYXRlRWRnZXMoKTtcbiAgICB0aGlzLnVwZGF0ZU5vcm1hbHMoKTtcbiAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVUcmVlKCk7XG59XG5UcmltZXNoLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuVHJpbWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmltZXNoO1xuXG52YXIgY29tcHV0ZU5vcm1hbHNfbiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVUcmVlXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZVRyZWUgPSBmdW5jdGlvbigpe1xuICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuXG4gICAgdHJlZS5yZXNldCgpO1xuICAgIHRyZWUuYWFiYi5jb3B5KHRoaXMuYWFiYik7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTsgLy8gVGhlIGxvY2FsIG1lc2ggQUFCQiBpcyBzY2FsZWQsIGJ1dCB0aGUgb2N0cmVlIEFBQkIgc2hvdWxkIGJlIHVuc2NhbGVkXG4gICAgdHJlZS5hYWJiLmxvd2VyQm91bmQueCAqPSAxIC8gc2NhbGUueDtcbiAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55O1xuICAgIHRyZWUuYWFiYi5sb3dlckJvdW5kLnogKj0gMSAvIHNjYWxlLno7XG4gICAgdHJlZS5hYWJiLnVwcGVyQm91bmQueCAqPSAxIC8gc2NhbGUueDtcbiAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55O1xuICAgIHRyZWUuYWFiYi51cHBlckJvdW5kLnogKj0gMSAvIHNjYWxlLno7XG5cbiAgICAvLyBJbnNlcnQgYWxsIHRyaWFuZ2xlc1xuICAgIHZhciB0cmlhbmdsZUFBQkIgPSBuZXcgQUFCQigpO1xuICAgIHZhciBhID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgYiA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIGMgPSBuZXcgVmVjMygpO1xuICAgIHZhciBwb2ludHMgPSBbYSwgYiwgY107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7XG4gICAgICAgIC8vdGhpcy5nZXRUcmlhbmdsZVZlcnRpY2VzKGksIGEsIGIsIGMpO1xuXG4gICAgICAgIC8vIEdldCB1bnNjYWxlZCB0cmlhbmdsZSB2ZXJ0c1xuICAgICAgICB2YXIgaTMgPSBpICogMztcbiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7XG4gICAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDFdLCBiKTtcbiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMl0sIGMpO1xuXG4gICAgICAgIHRyaWFuZ2xlQUFCQi5zZXRGcm9tUG9pbnRzKHBvaW50cyk7XG4gICAgICAgIHRyZWUuaW5zZXJ0KHRyaWFuZ2xlQUFCQiwgaSk7XG4gICAgfVxuICAgIHRyZWUucmVtb3ZlRW1wdHlOb2RlcygpO1xufTtcblxudmFyIHVuc2NhbGVkQUFCQiA9IG5ldyBBQUJCKCk7XG5cbi8qKlxuICogR2V0IHRyaWFuZ2xlcyBpbiBhIGxvY2FsIEFBQkIgZnJvbSB0aGUgdHJpbWVzaC5cbiAqIEBtZXRob2QgZ2V0VHJpYW5nbGVzSW5BQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IG9mIGludGVnZXJzLCByZWZlcmVuY2luZyB0aGUgcXVlcmllZCB0cmlhbmdsZXMuXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldFRyaWFuZ2xlc0luQUFCQiA9IGZ1bmN0aW9uKGFhYmIsIHJlc3VsdCl7XG4gICAgdW5zY2FsZWRBQUJCLmNvcHkoYWFiYik7XG5cbiAgICAvLyBTY2FsZSBpdCB0byBsb2NhbFxuICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgdmFyIGlzeCA9IHNjYWxlLng7XG4gICAgdmFyIGlzeSA9IHNjYWxlLnk7XG4gICAgdmFyIGlzeiA9IHNjYWxlLno7XG4gICAgdmFyIGwgPSB1bnNjYWxlZEFBQkIubG93ZXJCb3VuZDtcbiAgICB2YXIgdSA9IHVuc2NhbGVkQUFCQi51cHBlckJvdW5kO1xuICAgIGwueCAvPSBpc3g7XG4gICAgbC55IC89IGlzeTtcbiAgICBsLnogLz0gaXN6O1xuICAgIHUueCAvPSBpc3g7XG4gICAgdS55IC89IGlzeTtcbiAgICB1LnogLz0gaXN6O1xuXG4gICAgcmV0dXJuIHRoaXMudHJlZS5hYWJiUXVlcnkodW5zY2FsZWRBQUJCLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFNjYWxlXG4gKiBAcGFyYW0ge1ZlYzN9IHNjYWxlXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24oc2NhbGUpe1xuICAgIHZhciB3YXNVbmlmb3JtID0gdGhpcy5zY2FsZS54ID09PSB0aGlzLnNjYWxlLnkgPT09IHRoaXMuc2NhbGUuejtcbiAgICB2YXIgaXNVbmlmb3JtID0gc2NhbGUueCA9PT0gc2NhbGUueSA9PT0gc2NhbGUuejtcblxuICAgIGlmKCEod2FzVW5pZm9ybSAmJiBpc1VuaWZvcm0pKXtcbiAgICAgICAgLy8gTm9uLXVuaWZvcm0gc2NhbGluZy4gTmVlZCB0byB1cGRhdGUgbm9ybWFscy5cbiAgICAgICAgdGhpcy51cGRhdGVOb3JtYWxzKCk7XG4gICAgfVxuICAgIHRoaXMuc2NhbGUuY29weShzY2FsZSk7XG4gICAgdGhpcy51cGRhdGVBQUJCKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBub3JtYWxzIG9mIHRoZSBmYWNlcy4gV2lsbCBzYXZlIGluIHRoZSAubm9ybWFscyBhcnJheS5cbiAqIEBtZXRob2QgdXBkYXRlTm9ybWFsc1xuICovXG5UcmltZXNoLnByb3RvdHlwZS51cGRhdGVOb3JtYWxzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbiA9IGNvbXB1dGVOb3JtYWxzX247XG5cbiAgICAvLyBHZW5lcmF0ZSBub3JtYWxzXG4gICAgdmFyIG5vcm1hbHMgPSB0aGlzLm5vcm1hbHM7XG4gICAgZm9yKHZhciBpPTA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKXtcbiAgICAgICAgdmFyIGkzID0gaSAqIDM7XG5cbiAgICAgICAgdmFyIGEgPSB0aGlzLmluZGljZXNbaTNdLFxuICAgICAgICAgICAgYiA9IHRoaXMuaW5kaWNlc1tpMyArIDFdLFxuICAgICAgICAgICAgYyA9IHRoaXMuaW5kaWNlc1tpMyArIDJdO1xuXG4gICAgICAgIHRoaXMuZ2V0VmVydGV4KGEsIHZhKTtcbiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoYiwgdmIpO1xuICAgICAgICB0aGlzLmdldFZlcnRleChjLCB2Yyk7XG5cbiAgICAgICAgVHJpbWVzaC5jb21wdXRlTm9ybWFsKHZiLCB2YSwgdmMsIG4pO1xuXG4gICAgICAgIG5vcm1hbHNbaTNdID0gbi54O1xuICAgICAgICBub3JtYWxzW2kzICsgMV0gPSBuLnk7XG4gICAgICAgIG5vcm1hbHNbaTMgKyAyXSA9IG4uejtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLmVkZ2VzIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZUVkZ2VzXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZUVkZ2VzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWRnZXMgPSB7fTtcbiAgICB2YXIgYWRkID0gZnVuY3Rpb24oaW5kZXhBLCBpbmRleEIpe1xuICAgICAgICB2YXIga2V5ID0gYSA8IGIgPyBhICsgJ18nICsgYiA6IGIgKyAnXycgKyBhO1xuICAgICAgICBlZGdlc1trZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIGZvcih2YXIgaT0wOyBpIDwgdGhpcy5pbmRpY2VzLmxlbmd0aCAvIDM7IGkrKyl7XG4gICAgICAgIHZhciBpMyA9IGkgKiAzO1xuICAgICAgICB2YXIgYSA9IHRoaXMuaW5kaWNlc1tpM10sXG4gICAgICAgICAgICBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV0sXG4gICAgICAgICAgICBjID0gdGhpcy5pbmRpY2VzW2kzICsgMl07XG4gICAgICAgIGFkZChhLGIpO1xuICAgICAgICBhZGQoYixjKTtcbiAgICAgICAgYWRkKGMsYSk7XG4gICAgfVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZWRnZXMpO1xuICAgIHRoaXMuZWRnZXMgPSBuZXcgSW50MTZBcnJheShrZXlzLmxlbmd0aCAqIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IGtleXNbaV0uc3BsaXQoJ18nKTtcbiAgICAgICAgdGhpcy5lZGdlc1syICogaV0gPSBwYXJzZUludChpbmRpY2VzWzBdLCAxMCk7XG4gICAgICAgIHRoaXMuZWRnZXNbMiAqIGkgKyAxXSA9IHBhcnNlSW50KGluZGljZXNbMV0sIDEwKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBhbiBlZGdlIHZlcnRleFxuICogQG1ldGhvZCBnZXRFZGdlVmVydGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGVkZ2VJbmRleFxuICogQHBhcmFtICB7bnVtYmVyfSBmaXJzdE9yU2Vjb25kIDAgb3IgMSwgZGVwZW5kaW5nIG9uIHdoaWNoIG9uZSBvZiB0aGUgdmVydGljZXMgeW91IG5lZWQuXG4gKiBAcGFyYW0gIHtWZWMzfSB2ZXJ0ZXhTdG9yZSBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldEVkZ2VWZXJ0ZXggPSBmdW5jdGlvbihlZGdlSW5kZXgsIGZpcnN0T3JTZWNvbmQsIHZlcnRleFN0b3JlKXtcbiAgICB2YXIgdmVydGV4SW5kZXggPSB0aGlzLmVkZ2VzW2VkZ2VJbmRleCAqIDIgKyAoZmlyc3RPclNlY29uZCA/IDEgOiAwKV07XG4gICAgdGhpcy5nZXRWZXJ0ZXgodmVydGV4SW5kZXgsIHZlcnRleFN0b3JlKTtcbn07XG5cbnZhciBnZXRFZGdlVmVjdG9yX3ZhID0gbmV3IFZlYzMoKTtcbnZhciBnZXRFZGdlVmVjdG9yX3ZiID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBHZXQgYSB2ZWN0b3IgYWxvbmcgYW4gZWRnZS5cbiAqIEBtZXRob2QgZ2V0RWRnZVZlY3RvclxuICogQHBhcmFtICB7bnVtYmVyfSBlZGdlSW5kZXhcbiAqIEBwYXJhbSAge1ZlYzN9IHZlY3RvclN0b3JlXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldEVkZ2VWZWN0b3IgPSBmdW5jdGlvbihlZGdlSW5kZXgsIHZlY3RvclN0b3JlKXtcbiAgICB2YXIgdmEgPSBnZXRFZGdlVmVjdG9yX3ZhO1xuICAgIHZhciB2YiA9IGdldEVkZ2VWZWN0b3JfdmI7XG4gICAgdGhpcy5nZXRFZGdlVmVydGV4KGVkZ2VJbmRleCwgMCwgdmEpO1xuICAgIHRoaXMuZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIDEsIHZiKTtcbiAgICB2Yi52c3ViKHZhLCB2ZWN0b3JTdG9yZSk7XG59O1xuXG4vKipcbiAqIEdldCBmYWNlIG5vcm1hbCBnaXZlbiAzIHZlcnRpY2VzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNvbXB1dGVOb3JtYWxcbiAqIEBwYXJhbSB7VmVjM30gdmFcbiAqIEBwYXJhbSB7VmVjM30gdmJcbiAqIEBwYXJhbSB7VmVjM30gdmNcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XG4gKi9cbnZhciBjYiA9IG5ldyBWZWMzKCk7XG52YXIgYWIgPSBuZXcgVmVjMygpO1xuVHJpbWVzaC5jb21wdXRlTm9ybWFsID0gZnVuY3Rpb24gKCB2YSwgdmIsIHZjLCB0YXJnZXQgKSB7XG4gICAgdmIudnN1Yih2YSxhYik7XG4gICAgdmMudnN1Yih2YixjYik7XG4gICAgY2IuY3Jvc3MoYWIsdGFyZ2V0KTtcbiAgICBpZiAoICF0YXJnZXQuaXNaZXJvKCkgKSB7XG4gICAgICAgIHRhcmdldC5ub3JtYWxpemUoKTtcbiAgICB9XG59O1xuXG52YXIgdmEgPSBuZXcgVmVjMygpO1xudmFyIHZiID0gbmV3IFZlYzMoKTtcbnZhciB2YyA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogR2V0IHZlcnRleCBpLlxuICogQG1ldGhvZCBnZXRWZXJ0ZXhcbiAqIEBwYXJhbSAge251bWJlcn0gaVxuICogQHBhcmFtICB7VmVjM30gb3V0XG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldFZlcnRleCA9IGZ1bmN0aW9uKGksIG91dCl7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICB0aGlzLl9nZXRVbnNjYWxlZFZlcnRleChpLCBvdXQpO1xuICAgIG91dC54ICo9IHNjYWxlLng7XG4gICAgb3V0LnkgKj0gc2NhbGUueTtcbiAgICBvdXQueiAqPSBzY2FsZS56O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdldCByYXcgdmVydGV4IGlcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIF9nZXRVbnNjYWxlZFZlcnRleFxuICogQHBhcmFtICB7bnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtWZWMzfSBvdXRcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcIm91dFwiIHZlY3RvciBvYmplY3RcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuX2dldFVuc2NhbGVkVmVydGV4ID0gZnVuY3Rpb24oaSwgb3V0KXtcbiAgICB2YXIgaTMgPSBpICogMztcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHJldHVybiBvdXQuc2V0KFxuICAgICAgICB2ZXJ0aWNlc1tpM10sXG4gICAgICAgIHZlcnRpY2VzW2kzICsgMV0sXG4gICAgICAgIHZlcnRpY2VzW2kzICsgMl1cbiAgICApO1xufTtcblxuLyoqXG4gKiBHZXQgYSB2ZXJ0ZXggZnJvbSB0aGUgdHJpbWVzaCx0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHF1YXRlcm5pb24uXG4gKiBAbWV0aG9kIGdldFdvcmxkVmVydGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc1xuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICogQHBhcmFtICB7VmVjM30gb3V0XG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldFdvcmxkVmVydGV4ID0gZnVuY3Rpb24oaSwgcG9zLCBxdWF0LCBvdXQpe1xuICAgIHRoaXMuZ2V0VmVydGV4KGksIG91dCk7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHBvcywgcXVhdCwgb3V0LCBvdXQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdGhyZWUgdmVydGljZXMgZm9yIHRyaWFuZ2xlIGkuXG4gKiBAbWV0aG9kIGdldFRyaWFuZ2xlVmVydGljZXNcbiAqIEBwYXJhbSAge251bWJlcn0gaVxuICogQHBhcmFtICB7VmVjM30gYVxuICogQHBhcmFtICB7VmVjM30gYlxuICogQHBhcmFtICB7VmVjM30gY1xuICovXG5UcmltZXNoLnByb3RvdHlwZS5nZXRUcmlhbmdsZVZlcnRpY2VzID0gZnVuY3Rpb24oaSwgYSwgYiwgYyl7XG4gICAgdmFyIGkzID0gaSAqIDM7XG4gICAgdGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7XG4gICAgdGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMV0sIGIpO1xuICAgIHRoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDJdLCBjKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbm9ybWFsIG9mIHRyaWFuZ2xlIGkuXG4gKiBAbWV0aG9kIGdldE5vcm1hbFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcInRhcmdldFwiIHZlY3RvciBvYmplY3RcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuZ2V0Tm9ybWFsID0gZnVuY3Rpb24oaSwgdGFyZ2V0KXtcbiAgICB2YXIgaTMgPSBpICogMztcbiAgICByZXR1cm4gdGFyZ2V0LnNldChcbiAgICAgICAgdGhpcy5ub3JtYWxzW2kzXSxcbiAgICAgICAgdGhpcy5ub3JtYWxzW2kzICsgMV0sXG4gICAgICAgIHRoaXMubm9ybWFsc1tpMyArIDJdXG4gICAgKTtcbn07XG5cbnZhciBjbGlfYWFiYiA9IG5ldyBBQUJCKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJ0YXJnZXRcIiB2ZWN0b3Igb2JqZWN0XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsdGFyZ2V0KXtcbiAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhXG4gICAgLy8gRXhhY3QgaW5lcnRpYSBjYWxjdWxhdGlvbiBpcyBvdmVya2lsbCwgYnV0IHNlZSBodHRwOi8vZ2VvbWV0cmljdG9vbHMuY29tL0RvY3VtZW50YXRpb24vUG9seWhlZHJhbE1hc3NQcm9wZXJ0aWVzLnBkZiBmb3IgdGhlIGNvcnJlY3Qgd2F5IHRvIGRvIGl0XG4gICAgdGhpcy5jb21wdXRlTG9jYWxBQUJCKGNsaV9hYWJiKTtcbiAgICB2YXIgeCA9IGNsaV9hYWJiLnVwcGVyQm91bmQueCAtIGNsaV9hYWJiLmxvd2VyQm91bmQueCxcbiAgICAgICAgeSA9IGNsaV9hYWJiLnVwcGVyQm91bmQueSAtIGNsaV9hYWJiLmxvd2VyQm91bmQueSxcbiAgICAgICAgeiA9IGNsaV9hYWJiLnVwcGVyQm91bmQueiAtIGNsaV9hYWJiLmxvd2VyQm91bmQuejtcbiAgICByZXR1cm4gdGFyZ2V0LnNldChcbiAgICAgICAgMS4wIC8gMTIuMCAqIG1hc3MgKiAoIDIqeSoyKnkgKyAyKnoqMip6ICksXG4gICAgICAgIDEuMCAvIDEyLjAgKiBtYXNzICogKCAyKngqMip4ICsgMip6KjIqeiApLFxuICAgICAgICAxLjAgLyAxMi4wICogbWFzcyAqICggMip5KjIqeSArIDIqeCoyKnggKVxuICAgICk7XG59O1xuXG52YXIgY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxvY2FsIEFBQkIgZm9yIHRoZSB0cmltZXNoXG4gKiBAbWV0aG9kIGNvbXB1dGVMb2NhbEFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuY29tcHV0ZUxvY2FsQUFCQiA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZhciBsID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICB1ID0gYWFiYi51cHBlckJvdW5kLFxuICAgICAgICBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgdiA9IGNvbXB1dGVMb2NhbEFBQkJfd29ybGRWZXJ0O1xuXG4gICAgdGhpcy5nZXRWZXJ0ZXgoMCwgdik7XG4gICAgbC5jb3B5KHYpO1xuICAgIHUuY29weSh2KTtcblxuICAgIGZvcih2YXIgaT0wOyBpICE9PSBuOyBpKyspe1xuICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTtcblxuICAgICAgICBpZih2LnggPCBsLngpe1xuICAgICAgICAgICAgbC54ID0gdi54O1xuICAgICAgICB9IGVsc2UgaWYodi54ID4gdS54KXtcbiAgICAgICAgICAgIHUueCA9IHYueDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHYueSA8IGwueSl7XG4gICAgICAgICAgICBsLnkgPSB2Lnk7XG4gICAgICAgIH0gZWxzZSBpZih2LnkgPiB1Lnkpe1xuICAgICAgICAgICAgdS55ID0gdi55O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodi56IDwgbC56KXtcbiAgICAgICAgICAgIGwueiA9IHYuejtcbiAgICAgICAgfSBlbHNlIGlmKHYueiA+IHUueil7XG4gICAgICAgICAgICB1LnogPSB2Lno7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSAuYWFiYiBwcm9wZXJ0eVxuICogQG1ldGhvZCB1cGRhdGVBQUJCXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZUFBQkIgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQih0aGlzLmFhYmIpO1xufTtcblxuLyoqXG4gKiBXaWxsIHVwZGF0ZSB0aGUgLmJvdW5kaW5nU3BoZXJlUmFkaXVzIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICAvLyBBc3N1bWUgcG9pbnRzIGFyZSBkaXN0cmlidXRlZCB3aXRoIGxvY2FsICgwLDAsMCkgYXMgY2VudGVyXG4gICAgdmFyIG1heDIgPSAwO1xuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIHYgPSBuZXcgVmVjMygpO1xuICAgIGZvcih2YXIgaT0wLCBOPXZlcnRpY2VzLmxlbmd0aCAvIDM7IGkgIT09IE47IGkrKykge1xuICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTtcbiAgICAgICAgdmFyIG5vcm0yID0gdi5ub3JtMigpO1xuICAgICAgICBpZihub3JtMiA+IG1heDIpe1xuICAgICAgICAgICAgbWF4MiA9IG5vcm0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBNYXRoLnNxcnQobWF4Mik7XG59O1xuXG52YXIgdGVtcFdvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTtcbnZhciBjYWxjdWxhdGVXb3JsZEFBQkJfZnJhbWUgPSBuZXcgVHJhbnNmb3JtKCk7XG52YXIgY2FsY3VsYXRlV29ybGRBQUJCX2FhYmIgPSBuZXcgQUFCQigpO1xuXG4vKipcbiAqIEBtZXRob2QgY2FsY3VsYXRlV29ybGRBQUJCXG4gKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBwb3NcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gIHF1YXRcbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIG1pblxuICogQHBhcmFtIHtWZWMzfSAgICAgICAgbWF4XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcyxxdWF0LG1pbixtYXgpe1xuICAgIC8qXG4gICAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAvIDMsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICB2YXIgbWlueCxtaW55LG1pbnosbWF4eCxtYXh5LG1heHo7XG5cbiAgICB2YXIgdiA9IHRlbXBXb3JsZFZlcnRleDtcbiAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTtcbiAgICAgICAgcXVhdC52bXVsdCh2LCB2KTtcbiAgICAgICAgcG9zLnZhZGQodiwgdik7XG4gICAgICAgIGlmICh2LnggPCBtaW54IHx8IG1pbng9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgbWlueCA9IHYueDtcbiAgICAgICAgfSBlbHNlIGlmKHYueCA+IG1heHggfHwgbWF4eD09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtYXh4ID0gdi54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYueSA8IG1pbnkgfHwgbWlueT09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW55ID0gdi55O1xuICAgICAgICB9IGVsc2UgaWYodi55ID4gbWF4eSB8fCBtYXh5PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHkgPSB2Lnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodi56IDwgbWlueiB8fCBtaW56PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1pbnogPSB2Lno7XG4gICAgICAgIH0gZWxzZSBpZih2LnogPiBtYXh6IHx8IG1heHo9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgbWF4eiA9IHYuejtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4uc2V0KG1pbngsbWlueSxtaW56KTtcbiAgICBtYXguc2V0KG1heHgsbWF4eSxtYXh6KTtcbiAgICAqL1xuXG4gICAgLy8gRmFzdGVyIGFwcHJveGltYXRpb24gdXNpbmcgbG9jYWwgQUFCQlxuICAgIHZhciBmcmFtZSA9IGNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZTtcbiAgICB2YXIgcmVzdWx0ID0gY2FsY3VsYXRlV29ybGRBQUJCX2FhYmI7XG4gICAgZnJhbWUucG9zaXRpb24gPSBwb3M7XG4gICAgZnJhbWUucXVhdGVybmlvbiA9IHF1YXQ7XG4gICAgdGhpcy5hYWJiLnRvV29ybGRGcmFtZShmcmFtZSwgcmVzdWx0KTtcbiAgICBtaW4uY29weShyZXN1bHQubG93ZXJCb3VuZCk7XG4gICAgbWF4LmNvcHkocmVzdWx0LnVwcGVyQm91bmQpO1xufTtcblxuLyoqXG4gKiBHZXQgYXBwcm94aW1hdGUgdm9sdW1lXG4gKiBAbWV0aG9kIHZvbHVtZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5UcmltZXNoLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyAvIDMuMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgVHJpbWVzaCBpbnN0YW5jZSwgc2hhcGVkIGFzIGEgdG9ydXMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNyZWF0ZVRvcnVzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtyYWRpdXM9MV1cbiAqIEBwYXJhbSAge251bWJlcn0gW3R1YmU9MC41XVxuICogQHBhcmFtICB7bnVtYmVyfSBbcmFkaWFsU2VnbWVudHM9OF1cbiAqIEBwYXJhbSAge251bWJlcn0gW3R1YnVsYXJTZWdtZW50cz02XVxuICogQHBhcmFtICB7bnVtYmVyfSBbYXJjPTYuMjgzMTg1MzA3MTc5NTg2XVxuICogQHJldHVybiB7VHJpbWVzaH0gQSB0b3J1c1xuICovXG5UcmltZXNoLmNyZWF0ZVRvcnVzID0gZnVuY3Rpb24gKHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjKSB7XG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDE7XG4gICAgdHViZSA9IHR1YmUgfHwgMC41O1xuICAgIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcbiAgICB0dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgNjtcbiAgICBhcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XG5cbiAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuICAgICAgICAgICAgdmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xuICAgICAgICAgICAgdmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblxuICAgICAgICAgICAgdmFyIHggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xuICAgICAgICAgICAgdmFyIHkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuICAgICAgICAgICAgdmFyIHogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuICAgICAgICAgICAgdmVydGljZXMucHVzaCggeCwgeSwgeiApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICggdmFyIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuICAgICAgICAgICAgdmFyIGEgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcbiAgICAgICAgICAgIHZhciBiID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcbiAgICAgICAgICAgIHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xuICAgICAgICAgICAgdmFyIGQgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goYSwgYiwgZCk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goYiwgYywgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRyaW1lc2godmVydGljZXMsIGluZGljZXMpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gR1NTb2x2ZXI7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFNvbHZlciA9IHJlcXVpcmUoJy4vU29sdmVyJyk7XG5cbi8qKlxuICogQ29uc3RyYWludCBlcXVhdGlvbiBHYXVzcy1TZWlkZWwgc29sdmVyLlxuICogQGNsYXNzIEdTU29sdmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0b2RvIFRoZSBzcG9vayBwYXJhbWV0ZXJzIHNob3VsZCBiZSBzcGVjaWZpZWQgZm9yIGVhY2ggY29uc3RyYWludCwgbm90IGdsb2JhbGx5LlxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxuICogQHNlZSBodHRwczovL3d3dzguY3MudW11LnNlL2t1cnNlci81RFYwNTgvVlQwOS9sZWN0dXJlcy9zcG9va25vdGVzLnBkZlxuICogQGV4dGVuZHMgU29sdmVyXG4gKi9cbmZ1bmN0aW9uIEdTU29sdmVyKCl7XG4gICAgU29sdmVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHNvbHZlciBpdGVyYXRpb25zIGRldGVybWluZXMgcXVhbGl0eSBvZiB0aGUgY29uc3RyYWludHMgaW4gdGhlIHdvcmxkLiBUaGUgbW9yZSBpdGVyYXRpb25zLCB0aGUgbW9yZSBjb3JyZWN0IHNpbXVsYXRpb24uIE1vcmUgaXRlcmF0aW9ucyBuZWVkIG1vcmUgY29tcHV0YXRpb25zIHRob3VnaC4gSWYgeW91IGhhdmUgYSBsYXJnZSBncmF2aXR5IGZvcmNlIGluIHlvdXIgd29ybGQsIHlvdSB3aWxsIG5lZWQgbW9yZSBpdGVyYXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBpdGVyYXRpb25zXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAdG9kbyB3cml0ZSBtb3JlIGFib3V0IHNvbHZlciBhbmQgaXRlcmF0aW9ucyBpbiB0aGUgd2lraVxuICAgICAqL1xuICAgIHRoaXMuaXRlcmF0aW9ucyA9IDEwO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0b2xlcmFuY2UgaXMgcmVhY2hlZCwgdGhlIHN5c3RlbSBpcyBhc3N1bWVkIHRvIGJlIGNvbnZlcmdlZC5cbiAgICAgKiBAcHJvcGVydHkgdG9sZXJhbmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRvbGVyYW5jZSA9IDFlLTc7XG59XG5HU1NvbHZlci5wcm90b3R5cGUgPSBuZXcgU29sdmVyKCk7XG5cbnZhciBHU1NvbHZlcl9zb2x2ZV9sYW1iZGEgPSBbXTsgLy8gSnVzdCB0ZW1wb3JhcnkgbnVtYmVyIGhvbGRlcnMgdGhhdCB3ZSB3YW50IHRvIHJldXNlIGVhY2ggc29sdmUuXG52YXIgR1NTb2x2ZXJfc29sdmVfaW52Q3MgPSBbXTtcbnZhciBHU1NvbHZlcl9zb2x2ZV9CcyA9IFtdO1xuR1NTb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oZHQsd29ybGQpe1xuICAgIHZhciBpdGVyID0gMCxcbiAgICAgICAgbWF4SXRlciA9IHRoaXMuaXRlcmF0aW9ucyxcbiAgICAgICAgdG9sU3F1YXJlZCA9IHRoaXMudG9sZXJhbmNlKnRoaXMudG9sZXJhbmNlLFxuICAgICAgICBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgTmVxID0gZXF1YXRpb25zLmxlbmd0aCxcbiAgICAgICAgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICBOYm9kaWVzID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgaCA9IGR0LFxuICAgICAgICBxLCBCLCBpbnZDLCBkZWx0YWxhbWJkYSwgZGVsdGFsYW1iZGFUb3QsIEdXbGFtYmRhLCBsYW1iZGFqO1xuXG4gICAgLy8gVXBkYXRlIHNvbHZlIG1hc3NcbiAgICBpZihOZXEgIT09IDApe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICBib2RpZXNbaV0udXBkYXRlU29sdmVNYXNzUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpbmdzIHRoYXQgZG9lcyBub3QgY2hhbmdlIGR1cmluZyBpdGVyYXRpb24gY2FuIGJlIGNvbXB1dGVkIG9uY2VcbiAgICB2YXIgaW52Q3MgPSBHU1NvbHZlcl9zb2x2ZV9pbnZDcyxcbiAgICAgICAgQnMgPSBHU1NvbHZlcl9zb2x2ZV9CcyxcbiAgICAgICAgbGFtYmRhID0gR1NTb2x2ZXJfc29sdmVfbGFtYmRhO1xuICAgIGludkNzLmxlbmd0aCA9IE5lcTtcbiAgICBCcy5sZW5ndGggPSBOZXE7XG4gICAgbGFtYmRhLmxlbmd0aCA9IE5lcTtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5lcTsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBlcXVhdGlvbnNbaV07XG4gICAgICAgIGxhbWJkYVtpXSA9IDAuMDtcbiAgICAgICAgQnNbaV0gPSBjLmNvbXB1dGVCKGgpO1xuICAgICAgICBpbnZDc1tpXSA9IDEuMCAvIGMuY29tcHV0ZUMoKTtcbiAgICB9XG5cbiAgICBpZihOZXEgIT09IDApe1xuXG4gICAgICAgIC8vIFJlc2V0IHZsYW1iZGFcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgdmFyIGI9Ym9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIHZsYW1iZGE9Yi52bGFtYmRhLFxuICAgICAgICAgICAgICAgIHdsYW1iZGE9Yi53bGFtYmRhO1xuICAgICAgICAgICAgdmxhbWJkYS5zZXQoMCwwLDApO1xuICAgICAgICAgICAgd2xhbWJkYS5zZXQoMCwwLDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGVxdWF0aW9uc1xuICAgICAgICBmb3IoaXRlcj0wOyBpdGVyIT09bWF4SXRlcjsgaXRlcisrKXtcblxuICAgICAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgdG90YWwgZXJyb3IgZm9yIGVhY2ggaXRlcmF0aW9uLlxuICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgPSAwLjA7XG5cbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqIT09TmVxOyBqKyspe1xuXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBlcXVhdGlvbnNbal07XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIEIgPSBCc1tqXTtcbiAgICAgICAgICAgICAgICBpbnZDID0gaW52Q3Nbal07XG4gICAgICAgICAgICAgICAgbGFtYmRhaiA9IGxhbWJkYVtqXTtcbiAgICAgICAgICAgICAgICBHV2xhbWJkYSA9IGMuY29tcHV0ZUdXbGFtYmRhKCk7XG4gICAgICAgICAgICAgICAgZGVsdGFsYW1iZGEgPSBpbnZDICogKCBCIC0gR1dsYW1iZGEgLSBjLmVwcyAqIGxhbWJkYWogKTtcblxuICAgICAgICAgICAgICAgIC8vIENsYW1wIGlmIHdlIGFyZSBub3Qgd2l0aGluIHRoZSBtaW4vbWF4IGludGVydmFsXG4gICAgICAgICAgICAgICAgaWYobGFtYmRhaiArIGRlbHRhbGFtYmRhIDwgYy5taW5Gb3JjZSl7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhID0gYy5taW5Gb3JjZSAtIGxhbWJkYWo7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGxhbWJkYWogKyBkZWx0YWxhbWJkYSA+IGMubWF4Rm9yY2Upe1xuICAgICAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGMubWF4Rm9yY2UgLSBsYW1iZGFqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYW1iZGFbal0gKz0gZGVsdGFsYW1iZGE7XG5cbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBkZWx0YWxhbWJkYSA+IDAuMCA/IGRlbHRhbGFtYmRhIDogLWRlbHRhbGFtYmRhOyAvLyBhYnMoZGVsdGFsYW1iZGEpXG5cbiAgICAgICAgICAgICAgICBjLmFkZFRvV2xhbWJkYShkZWx0YWxhbWJkYSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB0b3RhbCBlcnJvciBpcyBzbWFsbCBlbm91Z2ggLSBzdG9wIGl0ZXJhdGVcbiAgICAgICAgICAgIGlmKGRlbHRhbGFtYmRhVG90KmRlbHRhbGFtYmRhVG90IDwgdG9sU3F1YXJlZCl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgcmVzdWx0IHRvIHZlbG9jaXR5XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBiPWJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICB2PWIudmVsb2NpdHksXG4gICAgICAgICAgICAgICAgdz1iLmFuZ3VsYXJWZWxvY2l0eTtcblxuICAgICAgICAgICAgYi52bGFtYmRhLnZtdWwoYi5saW5lYXJGYWN0b3IsIGIudmxhbWJkYSk7XG4gICAgICAgICAgICB2LnZhZGQoYi52bGFtYmRhLCB2KTtcblxuICAgICAgICAgICAgYi53bGFtYmRhLnZtdWwoYi5hbmd1bGFyRmFjdG9yLCBiLndsYW1iZGEpO1xuICAgICAgICAgICAgdy52YWRkKGIud2xhbWJkYSwgdyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIC5tdWx0aXBsaWVyIHByb3BlcnR5IG9mIGVhY2ggZXF1YXRpb25cbiAgICAgICAgdmFyIGwgPSBlcXVhdGlvbnMubGVuZ3RoO1xuICAgICAgICB2YXIgaW52RHQgPSAxIC8gaDtcbiAgICAgICAgd2hpbGUobC0tKXtcbiAgICAgICAgICAgIGVxdWF0aW9uc1tsXS5tdWx0aXBsaWVyID0gbGFtYmRhW2xdICogaW52RHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFNvbHZlcjtcblxuLyoqXG4gKiBDb25zdHJhaW50IGVxdWF0aW9uIHNvbHZlciBiYXNlIGNsYXNzLlxuICogQGNsYXNzIFNvbHZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlIC8gaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIFNvbHZlcigpe1xuICAgIC8qKlxuICAgICAqIEFsbCBlcXVhdGlvbnMgdG8gYmUgc29sdmVkXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZXF1YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3NlcyFcbiAqIEBtZXRob2Qgc29sdmVcbiAqIEBwYXJhbSAge051bWJlcn0gZHRcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICovXG5Tb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oZHQsd29ybGQpe1xuICAgIC8vIFNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVyYXRpb25zIGRvbmUhXG4gICAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBlcXVhdGlvblxuICogQG1ldGhvZCBhZGRFcXVhdGlvblxuICogQHBhcmFtIHtFcXVhdGlvbn0gZXFcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5hZGRFcXVhdGlvbiA9IGZ1bmN0aW9uKGVxKXtcbiAgICBpZiAoZXEuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBlcXVhdGlvblxuICogQG1ldGhvZCByZW1vdmVFcXVhdGlvblxuICogQHBhcmFtIHtFcXVhdGlvbn0gZXFcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5yZW1vdmVFcXVhdGlvbiA9IGZ1bmN0aW9uKGVxKXtcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgdmFyIGkgPSBlcXMuaW5kZXhPZihlcSk7XG4gICAgaWYoaSAhPT0gLTEpe1xuICAgICAgICBlcXMuc3BsaWNlKGksMSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgYWxsIGVxdWF0aW9uc1xuICogQG1ldGhvZCByZW1vdmVBbGxFcXVhdGlvbnNcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5yZW1vdmVBbGxFcXVhdGlvbnMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IDA7XG59O1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFNwbGl0U29sdmVyO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBTb2x2ZXIgPSByZXF1aXJlKCcuL1NvbHZlcicpO1xudmFyIEJvZHkgPSByZXF1aXJlKCcuLi9vYmplY3RzL0JvZHknKTtcblxuLyoqXG4gKiBTcGxpdHMgdGhlIGVxdWF0aW9ucyBpbnRvIGlzbGFuZHMgYW5kIHNvbHZlcyB0aGVtIGluZGVwZW5kZW50bHkuIENhbiBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICogQGNsYXNzIFNwbGl0U29sdmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFNvbHZlclxuICogQHBhcmFtIHtTb2x2ZXJ9IHN1YnNvbHZlclxuICovXG5mdW5jdGlvbiBTcGxpdFNvbHZlcihzdWJzb2x2ZXIpe1xuICAgIFNvbHZlci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaXRlcmF0aW9ucyA9IDEwO1xuICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNztcbiAgICB0aGlzLnN1YnNvbHZlciA9IHN1YnNvbHZlcjtcbiAgICB0aGlzLm5vZGVzID0gW107XG4gICAgdGhpcy5ub2RlUG9vbCA9IFtdO1xuXG4gICAgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGVcbiAgICB3aGlsZSh0aGlzLm5vZGVQb29sLmxlbmd0aCA8IDEyOCl7XG4gICAgICAgIHRoaXMubm9kZVBvb2wucHVzaCh0aGlzLmNyZWF0ZU5vZGUoKSk7XG4gICAgfVxufVxuU3BsaXRTb2x2ZXIucHJvdG90eXBlID0gbmV3IFNvbHZlcigpO1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc3Vic3lzdGVtc1xudmFyIFNwbGl0U29sdmVyX3NvbHZlX25vZGVzID0gW107IC8vIEFsbCBhbGxvY2F0ZWQgbm9kZSBvYmplY3RzXG52YXIgU3BsaXRTb2x2ZXJfc29sdmVfbm9kZVBvb2wgPSBbXTsgLy8gQWxsIGFsbG9jYXRlZCBub2RlIG9iamVjdHNcbnZhciBTcGxpdFNvbHZlcl9zb2x2ZV9lcXMgPSBbXTsgICAvLyBUZW1wIGFycmF5XG52YXIgU3BsaXRTb2x2ZXJfc29sdmVfYmRzID0gW107ICAgLy8gVGVtcCBhcnJheVxudmFyIFNwbGl0U29sdmVyX3NvbHZlX2R1bW15V29ybGQgPSB7Ym9kaWVzOltdfTsgLy8gVGVtcCBvYmplY3RcblxudmFyIFNUQVRJQyA9IEJvZHkuU1RBVElDO1xuZnVuY3Rpb24gZ2V0VW52aXNpdGVkTm9kZShub2Rlcyl7XG4gICAgdmFyIE5ub2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ub2RlczsgaSsrKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYoIW5vZGUudmlzaXRlZCAmJiAhKG5vZGUuYm9keS50eXBlICYgU1RBVElDKSl7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBxdWV1ZSA9IFtdO1xuZnVuY3Rpb24gYmZzKHJvb3QsdmlzaXRGdW5jLGJkcyxlcXMpe1xuICAgIHF1ZXVlLnB1c2gocm9vdCk7XG4gICAgcm9vdC52aXNpdGVkID0gdHJ1ZTtcbiAgICB2aXNpdEZ1bmMocm9vdCxiZHMsZXFzKTtcbiAgICB3aGlsZShxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgLy8gTG9vcCBvdmVyIHVudmlzaXRlZCBjaGlsZCBub2Rlc1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIHdoaWxlKChjaGlsZCA9IGdldFVudmlzaXRlZE5vZGUobm9kZS5jaGlsZHJlbikpKSB7XG4gICAgICAgICAgICBjaGlsZC52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpc2l0RnVuYyhjaGlsZCxiZHMsZXFzKTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2aXNpdEZ1bmMobm9kZSxiZHMsZXFzKXtcbiAgICBiZHMucHVzaChub2RlLmJvZHkpO1xuICAgIHZhciBOZXFzID0gbm9kZS5lcXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmVxczsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gbm9kZS5lcXNbaV07XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKGVxKSA9PT0gLTEpe1xuICAgICAgICAgICAgZXFzLnB1c2goZXEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5TcGxpdFNvbHZlci5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHsgYm9keTpudWxsLCBjaGlsZHJlbjpbXSwgZXFzOltdLCB2aXNpdGVkOmZhbHNlIH07XG59O1xuXG4vKipcbiAqIFNvbHZlIHRoZSBzdWJzeXN0ZW1zXG4gKiBAbWV0aG9kIHNvbHZlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGR0XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqL1xuU3BsaXRTb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oZHQsd29ybGQpe1xuICAgIHZhciBub2Rlcz1TcGxpdFNvbHZlcl9zb2x2ZV9ub2RlcyxcbiAgICAgICAgbm9kZVBvb2w9dGhpcy5ub2RlUG9vbCxcbiAgICAgICAgYm9kaWVzPXdvcmxkLmJvZGllcyxcbiAgICAgICAgZXF1YXRpb25zPXRoaXMuZXF1YXRpb25zLFxuICAgICAgICBOZXE9ZXF1YXRpb25zLmxlbmd0aCxcbiAgICAgICAgTmJvZGllcz1ib2RpZXMubGVuZ3RoLFxuICAgICAgICBzdWJzb2x2ZXI9dGhpcy5zdWJzb2x2ZXI7XG5cbiAgICAvLyBDcmVhdGUgbmVlZGVkIG5vZGVzLCByZXVzZSBpZiBwb3NzaWJsZVxuICAgIHdoaWxlKG5vZGVQb29sLmxlbmd0aCA8IE5ib2RpZXMpe1xuICAgICAgICBub2RlUG9vbC5wdXNoKHRoaXMuY3JlYXRlTm9kZSgpKTtcbiAgICB9XG4gICAgbm9kZXMubGVuZ3RoID0gTmJvZGllcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5ib2RpZXM7IGkrKykge1xuICAgICAgICBub2Rlc1tpXSA9IG5vZGVQb29sW2ldO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IG5vZGUgdmFsdWVzXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlLmJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICAgICAgbm9kZS5lcXMubGVuZ3RoID0gMDtcbiAgICAgICAgbm9kZS52aXNpdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGZvcih2YXIgaz0wOyBrIT09TmVxOyBrKyspe1xuICAgICAgICB2YXIgZXE9ZXF1YXRpb25zW2tdLFxuICAgICAgICAgICAgaT1ib2RpZXMuaW5kZXhPZihlcS5iaSksXG4gICAgICAgICAgICBqPWJvZGllcy5pbmRleE9mKGVxLmJqKSxcbiAgICAgICAgICAgIG5pPW5vZGVzW2ldLFxuICAgICAgICAgICAgbmo9bm9kZXNbal07XG4gICAgICAgIG5pLmNoaWxkcmVuLnB1c2gobmopO1xuICAgICAgICBuaS5lcXMucHVzaChlcSk7XG4gICAgICAgIG5qLmNoaWxkcmVuLnB1c2gobmkpO1xuICAgICAgICBuai5lcXMucHVzaChlcSk7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkLCBuPTAsIGVxcz1TcGxpdFNvbHZlcl9zb2x2ZV9lcXM7XG5cbiAgICBzdWJzb2x2ZXIudG9sZXJhbmNlID0gdGhpcy50b2xlcmFuY2U7XG4gICAgc3Vic29sdmVyLml0ZXJhdGlvbnMgPSB0aGlzLml0ZXJhdGlvbnM7XG5cbiAgICB2YXIgZHVtbXlXb3JsZCA9IFNwbGl0U29sdmVyX3NvbHZlX2R1bW15V29ybGQ7XG4gICAgd2hpbGUoKGNoaWxkID0gZ2V0VW52aXNpdGVkTm9kZShub2RlcykpKXtcbiAgICAgICAgZXFzLmxlbmd0aCA9IDA7XG4gICAgICAgIGR1bW15V29ybGQuYm9kaWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGJmcyhjaGlsZCwgdmlzaXRGdW5jLCBkdW1teVdvcmxkLmJvZGllcywgZXFzKTtcblxuICAgICAgICB2YXIgTmVxcyA9IGVxcy5sZW5ndGg7XG5cbiAgICAgICAgZXFzID0gZXFzLnNvcnQoc29ydEJ5SWQpO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmVxczsgaSsrKXtcbiAgICAgICAgICAgIHN1YnNvbHZlci5hZGRFcXVhdGlvbihlcXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXIgPSBzdWJzb2x2ZXIuc29sdmUoZHQsZHVtbXlXb3JsZCk7XG4gICAgICAgIHN1YnNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcbiAgICAgICAgbisrO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xufTtcblxuZnVuY3Rpb24gc29ydEJ5SWQoYSwgYil7XG4gICAgcmV0dXJuIGIuaWQgLSBhLmlkO1xufSIsIi8qKlxuICogQmFzZSBjbGFzcyBmb3Igb2JqZWN0cyB0aGF0IGRpc3BhdGNoZXMgZXZlbnRzLlxuICogQGNsYXNzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IEV2ZW50VGFyZ2V0LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7RXZlbnRUYXJnZXR9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7IHRoaXMuX2xpc3RlbmVycyA9IHt9OyB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBldmVudCBsaXN0ZW5lciBpcyBhZGRlZFxuICAgICAqIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMSApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW55IGV2ZW50IGxpc3RlbmVyIG9mIHRoZSBnaXZlbiB0eXBlIGlzIGFkZGVkXG4gICAgICogQG1ldGhvZCBoYXNBbnlFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNBbnlFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIHJldHVybiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7RXZlbnRUYXJnZXR9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmICggbGlzdGVuZXJzW3R5cGVdID09PSB1bmRlZmluZWQgKXsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKTtcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0uc3BsaWNlKCBpbmRleCwgMSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbWl0IGFuIGV2ZW50LlxuICAgICAqIEBtZXRob2QgZGlzcGF0Y2hFdmVudFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50LnR5cGVcbiAgICAgKiBAcmV0dXJuIHtFdmVudFRhcmdldH0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcbiAgICAgICAgaWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyQXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG4iLCJ2YXIgQUFCQiA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9BQUJCJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9jdHJlZTtcblxuLyoqXG4gKiBAY2xhc3MgT2N0cmVlTm9kZVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtPY3RyZWV9IFtvcHRpb25zLnJvb3RdXG4gKiBAcGFyYW0ge0FBQkJ9IFtvcHRpb25zLmFhYmJdXG4gKi9cbmZ1bmN0aW9uIE9jdHJlZU5vZGUob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm9vdCBub2RlXG4gICAgICogQHByb3BlcnR5IHtPY3RyZWVOb2RlfSByb290XG4gICAgICovXG4gICAgdGhpcy5yb290ID0gb3B0aW9ucy5yb290IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBCb3VuZGFyeSBvZiB0aGlzIG5vZGVcbiAgICAgKiBAcHJvcGVydHkge0FBQkJ9IGFhYmJcbiAgICAgKi9cbiAgICB0aGlzLmFhYmIgPSBvcHRpb25zLmFhYmIgPyBvcHRpb25zLmFhYmIuY2xvbmUoKSA6IG5ldyBBQUJCKCk7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWluZWQgZGF0YSBhdCB0aGUgY3VycmVudCBub2RlIGxldmVsLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGRhdGFcbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIENoaWxkcmVuIHRvIHRoaXMgbm9kZVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNoaWxkcmVuXG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xufVxuXG4vKipcbiAqIEBjbGFzcyBPY3RyZWVcbiAqIEBwYXJhbSB7QUFCQn0gYWFiYiBUaGUgdG90YWwgQUFCQiBvZiB0aGUgdHJlZVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heERlcHRoPThdXG4gKiBAZXh0ZW5kcyBPY3RyZWVOb2RlXG4gKi9cbmZ1bmN0aW9uIE9jdHJlZShhYWJiLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnJvb3QgPSBudWxsO1xuICAgIG9wdGlvbnMuYWFiYiA9IGFhYmI7XG4gICAgT2N0cmVlTm9kZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBzdWJkaXZpc2lvbiBkZXB0aFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhEZXB0aFxuICAgICAqL1xuICAgIHRoaXMubWF4RGVwdGggPSB0eXBlb2Yob3B0aW9ucy5tYXhEZXB0aCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhEZXB0aCA6IDg7XG59XG5PY3RyZWUucHJvdG90eXBlID0gbmV3IE9jdHJlZU5vZGUoKTtcblxuT2N0cmVlTm9kZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihhYWJiLCBvcHRpb25zKXtcbiAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBJbnNlcnQgZGF0YSBpbnRvIHRoaXMgbm9kZVxuICogQG1ldGhvZCBpbnNlcnRcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqIEBwYXJhbSAge29iamVjdH0gZWxlbWVudERhdGFcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbk9jdHJlZU5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGFhYmIsIGVsZW1lbnREYXRhLCBsZXZlbCl7XG4gICAgdmFyIG5vZGVEYXRhID0gdGhpcy5kYXRhO1xuICAgIGxldmVsID0gbGV2ZWwgfHwgMDtcblxuICAgIC8vIElnbm9yZSBvYmplY3RzIHRoYXQgZG8gbm90IGJlbG9uZyBpbiB0aGlzIG5vZGVcbiAgICBpZiAoIXRoaXMuYWFiYi5jb250YWlucyhhYWJiKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gb2JqZWN0IGNhbm5vdCBiZSBhZGRlZFxuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICBpZihsZXZlbCA8ICh0aGlzLm1heERlcHRoIHx8IHRoaXMucm9vdC5tYXhEZXB0aCkpe1xuICAgICAgICAvLyBTdWJkaXZpZGUgaWYgdGhlcmUgYXJlIG5vIGNoaWxkcmVuIHlldFxuICAgICAgICB2YXIgc3ViZGl2aWRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCl7XG4gICAgICAgICAgICB0aGlzLnN1YmRpdmlkZSgpO1xuICAgICAgICAgICAgc3ViZGl2aWRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdG8gd2hpY2hldmVyIG5vZGUgd2lsbCBhY2NlcHQgaXRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IDg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLmluc2VydChhYWJiLCBlbGVtZW50RGF0YSwgbGV2ZWwgKyAxKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihzdWJkaXZpZGVkKXtcbiAgICAgICAgICAgIC8vIE5vIGNoaWxkcmVuIGFjY2VwdGVkISBNaWdodCBhcyB3ZWxsIGp1c3QgcmVtb3ZlIGVtIHNpbmNlIHRoZXkgY29udGFpbiBub25lXG4gICAgICAgICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVG9vIGRlZXAsIG9yIGNoaWxkcmVuIGRpZG50IHdhbnQgaXQuIGFkZCBpdCBpbiBjdXJyZW50IG5vZGVcbiAgICBub2RlRGF0YS5wdXNoKGVsZW1lbnREYXRhKTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxudmFyIGhhbGZEaWFnb25hbCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQ3JlYXRlIDggZXF1YWxseSBzaXplZCBjaGlsZHJlbiBub2RlcyBhbmQgcHV0IHRoZW0gaW4gdGhlIC5jaGlsZHJlbiBhcnJheS5cbiAqIEBtZXRob2Qgc3ViZGl2aWRlXG4gKi9cbk9jdHJlZU5vZGUucHJvdG90eXBlLnN1YmRpdmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhYWJiID0gdGhpcy5hYWJiO1xuICAgIHZhciBsID0gYWFiYi5sb3dlckJvdW5kO1xuICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuICAgIGNoaWxkcmVuLnB1c2goXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygwLDAsMCkgfSkgfSksXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygxLDAsMCkgfSkgfSksXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygxLDEsMCkgfSkgfSksXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygxLDEsMSkgfSkgfSksXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygwLDEsMSkgfSkgfSksXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygwLDAsMSkgfSkgfSksXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygxLDAsMSkgfSkgfSksXG4gICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygwLDEsMCkgfSkgfSlcbiAgICApO1xuXG4gICAgdS52c3ViKGwsIGhhbGZEaWFnb25hbCk7XG4gICAgaGFsZkRpYWdvbmFsLnNjYWxlKDAuNSwgaGFsZkRpYWdvbmFsKTtcblxuICAgIHZhciByb290ID0gdGhpcy5yb290IHx8IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gODsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgIC8vIFNldCBjdXJyZW50IG5vZGUgYXMgcm9vdFxuICAgICAgICBjaGlsZC5yb290ID0gcm9vdDtcblxuICAgICAgICAvLyBDb21wdXRlIGJvdW5kc1xuICAgICAgICB2YXIgbG93ZXJCb3VuZCA9IGNoaWxkLmFhYmIubG93ZXJCb3VuZDtcbiAgICAgICAgbG93ZXJCb3VuZC54ICo9IGhhbGZEaWFnb25hbC54O1xuICAgICAgICBsb3dlckJvdW5kLnkgKj0gaGFsZkRpYWdvbmFsLnk7XG4gICAgICAgIGxvd2VyQm91bmQueiAqPSBoYWxmRGlhZ29uYWwuejtcblxuICAgICAgICBsb3dlckJvdW5kLnZhZGQobCwgbG93ZXJCb3VuZCk7XG5cbiAgICAgICAgLy8gVXBwZXIgYm91bmQgaXMgYWx3YXlzIGxvd2VyIGJvdW5kICsgaGFsZkRpYWdvbmFsXG4gICAgICAgIGxvd2VyQm91bmQudmFkZChoYWxmRGlhZ29uYWwsIGNoaWxkLmFhYmIudXBwZXJCb3VuZCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgYWxsIGRhdGEsIHBvdGVudGlhbGx5IHdpdGhpbiBhbiBBQUJCXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtICB7YXJyYXl9IHJlc3VsdFxuICogQHJldHVybiB7YXJyYXl9IFRoZSBcInJlc3VsdFwiIG9iamVjdFxuICovXG5PY3RyZWVOb2RlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbihhYWJiLCByZXN1bHQpIHtcblxuICAgIHZhciBub2RlRGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIC8vIGFib3J0IGlmIHRoZSByYW5nZSBkb2VzIG5vdCBpbnRlcnNlY3QgdGhpcyBub2RlXG4gICAgLy8gaWYgKCF0aGlzLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xuICAgIC8vICAgICByZXR1cm4gcmVzdWx0O1xuICAgIC8vIH1cblxuICAgIC8vIEFkZCBvYmplY3RzIGF0IHRoaXMgbGV2ZWxcbiAgICAvLyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQsIG5vZGVEYXRhKTtcblxuICAgIC8vIEFkZCBjaGlsZCBkYXRhXG4gICAgLy8gQHRvZG8gdW53cmFwIHJlY3Vyc2lvbiBpbnRvIGEgcXVldWUgLyBsb29wLCB0aGF0J3MgZmFzdGVyIGluIEpTXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXG4gICAgLy8gZm9yICh2YXIgaSA9IDAsIE4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgLy8gICAgIGNoaWxkcmVuW2ldLmFhYmJRdWVyeShhYWJiLCByZXN1bHQpO1xuICAgIC8vIH1cblxuICAgIHZhciBxdWV1ZSA9IFt0aGlzXTtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub2RlID0gcXVldWUucG9wKCk7XG4gICAgICAgIGlmIChub2RlLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LCBub2RlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHF1ZXVlLCBub2RlLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHRtcEFBQkIgPSBuZXcgQUFCQigpO1xuXG4vKipcbiAqIEdldCBhbGwgZGF0YSwgcG90ZW50aWFsbHkgaW50ZXJzZWN0ZWQgYnkgYSByYXkuXG4gKiBAbWV0aG9kIHJheVF1ZXJ5XG4gKiBAcGFyYW0gIHtSYXl9IHJheVxuICogQHBhcmFtICB7VHJhbnNmb3JtfSB0cmVlVHJhbnNmb3JtXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0XG4gKiBAcmV0dXJuIHthcnJheX0gVGhlIFwicmVzdWx0XCIgb2JqZWN0XG4gKi9cbk9jdHJlZU5vZGUucHJvdG90eXBlLnJheVF1ZXJ5ID0gZnVuY3Rpb24ocmF5LCB0cmVlVHJhbnNmb3JtLCByZXN1bHQpIHtcblxuICAgIC8vIFVzZSBhYWJiIHF1ZXJ5IGZvciBub3cuXG4gICAgLy8gQHRvZG8gaW1wbGVtZW50IHJlYWwgcmF5IHF1ZXJ5IHdoaWNoIG5lZWRzIGxlc3MgbG9va3Vwc1xuICAgIHJheS5nZXRBQUJCKHRtcEFBQkIpO1xuICAgIHRtcEFBQkIudG9Mb2NhbEZyYW1lKHRyZWVUcmFuc2Zvcm0sIHRtcEFBQkIpO1xuICAgIHRoaXMuYWFiYlF1ZXJ5KHRtcEFBQkIsIHJlc3VsdCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHJlbW92ZUVtcHR5Tm9kZXNcbiAqL1xuT2N0cmVlTm9kZS5wcm90b3R5cGUucmVtb3ZlRW1wdHlOb2RlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBxdWV1ZSA9IFt0aGlzXTtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub2RlID0gcXVldWUucG9wKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZighbm9kZS5jaGlsZHJlbltpXS5kYXRhLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocXVldWUsIG5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFBvb2w7XG5cbi8qKlxuICogRm9yIHBvb2xpbmcgb2JqZWN0cyB0aGF0IGNhbiBiZSByZXVzZWQuXG4gKiBAY2xhc3MgUG9vbFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBvb2woKXtcbiAgICAvKipcbiAgICAgKiBUaGUgcG9vbGVkIG9iamVjdHNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBvYmplY3RzXG4gICAgICovXG4gICAgdGhpcy5vYmplY3RzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBvZiB0aGUgb2JqZWN0c1xuICAgICAqIEBwcm9wZXJ0eSB7bWl4ZWR9IHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBPYmplY3Q7XG59XG5cbi8qKlxuICogUmVsZWFzZSBhbiBvYmplY3QgYWZ0ZXIgdXNlXG4gKiBAbWV0aG9kIHJlbGVhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuUG9vbC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIE5hcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5hcmdzOyBpKyspe1xuICAgICAgICB0aGlzLm9iamVjdHMucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdFxuICogQG1ldGhvZCBnZXRcbiAqIEByZXR1cm4ge21peGVkfVxuICovXG5Qb29sLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMub2JqZWN0cy5sZW5ndGg9PT0wKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0T2JqZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0cy5wb3AoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdCBhbiBvYmplY3QuIFNob3VsZCBiZSBpbXBsbWVudGVkIGluIGVhY2ggc3ViY2xhc3MuXG4gKiBAbWV0aG9kIGNvbnN0cnVjdE9iamVjdFxuICogQHJldHVybiB7bWl4ZWR9XG4gKi9cblBvb2wucHJvdG90eXBlLmNvbnN0cnVjdE9iamVjdCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc3RydWN0T2JqZWN0KCkgbm90IGltcGxlbWVudGVkIGluIHRoaXMgUG9vbCBzdWJjbGFzcyB5ZXQhXCIpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHJlc2l6ZVxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAqIEByZXR1cm4ge1Bvb2x9IFNlbGYsIGZvciBjaGFpbmluZ1xuICovXG5Qb29sLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHZhciBvYmplY3RzID0gdGhpcy5vYmplY3RzO1xuXG4gICAgd2hpbGUgKG9iamVjdHMubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgICBvYmplY3RzLnBvcCgpO1xuICAgIH1cblxuICAgIHdoaWxlIChvYmplY3RzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgICAgb2JqZWN0cy5wdXNoKHRoaXMuY29uc3RydWN0T2JqZWN0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSBUdXBsZURpY3Rpb25hcnk7XG5cbi8qKlxuICogQGNsYXNzIFR1cGxlRGljdGlvbmFyeVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFR1cGxlRGljdGlvbmFyeSgpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHN0b3JhZ2VcbiAgICAgKiBAcHJvcGVydHkgZGF0YVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0geyBrZXlzOltdIH07XG59XG5cbi8qKlxuICogQG1ldGhvZCBnZXRcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSwgaikge1xuICAgIGlmIChpID4gaikge1xuICAgICAgICAvLyBzd2FwXG4gICAgICAgIHZhciB0ZW1wID0gajtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGkgPSB0ZW1wO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhW2krJy0nK2pdO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGksIGosIHZhbHVlKSB7XG4gICAgaWYgKGkgPiBqKSB7XG4gICAgICAgIHZhciB0ZW1wID0gajtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGkgPSB0ZW1wO1xuICAgIH1cbiAgICB2YXIga2V5ID0gaSsnLScrajtcblxuICAgIC8vIENoZWNrIGlmIGtleSBhbHJlYWR5IGV4aXN0c1xuICAgIGlmKCF0aGlzLmdldChpLGopKXtcbiAgICAgICAgdGhpcy5kYXRhLmtleXMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YVtrZXldID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICBrZXlzID0gZGF0YS5rZXlzO1xuICAgIHdoaWxlKGtleXMubGVuZ3RoID4gMCl7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBkZWxldGUgZGF0YVtrZXldO1xuICAgIH1cbn07XG4iLCJmdW5jdGlvbiBVdGlscygpe31cblxubW9kdWxlLmV4cG9ydHMgPSBVdGlscztcblxuLyoqXG4gKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGVmYXVsdHNcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuIE1heSBiZSBmYWxzeTogaW4gdGhpcyBjYXNlLCBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRlZmF1bHRzIEFuIG9iamVjdCBjb250YWluaW5nIGRlZmF1bHQgdmFsdWVzLlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgbW9kaWZpZWQgb3B0aW9ucyBvYmplY3QuXG4gKi9cblV0aWxzLmRlZmF1bHRzID0gZnVuY3Rpb24ob3B0aW9ucywgZGVmYXVsdHMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgZm9yKHZhciBrZXkgaW4gZGVmYXVsdHMpe1xuICAgICAgICBpZighKGtleSBpbiBvcHRpb25zKSl7XG4gICAgICAgICAgICBvcHRpb25zW2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBWZWMzUG9vbDtcblxudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBQb29sID0gcmVxdWlyZSgnLi9Qb29sJyk7XG5cbi8qKlxuICogQGNsYXNzIFZlYzNQb29sXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFBvb2xcbiAqL1xuZnVuY3Rpb24gVmVjM1Bvb2woKXtcbiAgICBQb29sLmNhbGwodGhpcyk7XG4gICAgdGhpcy50eXBlID0gVmVjMztcbn1cblZlYzNQb29sLnByb3RvdHlwZSA9IG5ldyBQb29sKCk7XG5cbi8qKlxuICogQ29uc3RydWN0IGEgdmVjdG9yXG4gKiBAbWV0aG9kIGNvbnN0cnVjdE9iamVjdFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuVmVjM1Bvb2wucHJvdG90eXBlLmNvbnN0cnVjdE9iamVjdCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5ldyBWZWMzKCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBOYXJyb3dwaGFzZTtcblxudmFyIEFBQkIgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQUFCQicpO1xudmFyIEJvZHkgPSByZXF1aXJlKCcuLi9vYmplY3RzL0JvZHknKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9TaGFwZScpO1xudmFyIFJheSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9SYXknKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcbnZhciBDb252ZXhQb2x5aGVkcm9uID0gcmVxdWlyZSgnLi4vc2hhcGVzL0NvbnZleFBvbHloZWRyb24nKTtcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgU29sdmVyID0gcmVxdWlyZSgnLi4vc29sdmVyL1NvbHZlcicpO1xudmFyIFZlYzNQb29sID0gcmVxdWlyZSgnLi4vdXRpbHMvVmVjM1Bvb2wnKTtcbnZhciBDb250YWN0RXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XG52YXIgRnJpY3Rpb25FcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uJyk7XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIGZvciB0aGUgV29ybGQuIEdlbmVyYXRlcyBDb250YWN0RXF1YXRpb25zLlxuICogQGNsYXNzIE5hcnJvd3BoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0b2RvIFNwaGVyZS1Db252ZXhQb2x5aGVkcm9uIGNvbnRhY3RzXG4gKiBAdG9kbyBDb250YWN0IHJlZHVjdGlvblxuICogQHRvZG8gIHNob3VsZCBtb3ZlIG1ldGhvZHMgdG8gcHJvdG90eXBlXG4gKi9cbmZ1bmN0aW9uIE5hcnJvd3BoYXNlKHdvcmxkKXtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHN0b3JhZ2Ugb2YgcG9vbGVkIGNvbnRhY3QgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNvbnRhY3RQb2ludFBvb2xcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RQb2ludFBvb2wgPSBbXTtcblxuICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBbXTtcblxuICAgIHRoaXMucmVzdWx0ID0gW107XG4gICAgdGhpcy5mcmljdGlvblJlc3VsdCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogUG9vbGVkIHZlY3RvcnMuXG4gICAgICogQHByb3BlcnR5IHtWZWMzUG9vbH0gdjNwb29sXG4gICAgICovXG4gICAgdGhpcy52M3Bvb2wgPSBuZXcgVmVjM1Bvb2woKTtcblxuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbiAgICB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBlbmFibGVGcmljdGlvblJlZHVjdGlvblxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBNYWtlIGEgY29udGFjdCBvYmplY3QsIGJ5IHVzaW5nIHRoZSBpbnRlcm5hbCBwb29sIG9yIGNyZWF0aW5nIGEgbmV3IG9uZS5cbiAqIEBtZXRob2QgY3JlYXRlQ29udGFjdEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJpXG4gKiBAcGFyYW0ge0JvZHl9IGJqXG4gKiBAcGFyYW0ge1NoYXBlfSBzaVxuICogQHBhcmFtIHtTaGFwZX0gc2pcbiAqIEBwYXJhbSB7U2hhcGV9IG92ZXJyaWRlU2hhcGVBXG4gKiBAcGFyYW0ge1NoYXBlfSBvdmVycmlkZVNoYXBlQlxuICogQHJldHVybiB7Q29udGFjdEVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlQ29udGFjdEVxdWF0aW9uID0gZnVuY3Rpb24oYmksIGJqLCBzaSwgc2osIG92ZXJyaWRlU2hhcGVBLCBvdmVycmlkZVNoYXBlQil7XG4gICAgdmFyIGM7XG4gICAgaWYodGhpcy5jb250YWN0UG9pbnRQb29sLmxlbmd0aCl7XG4gICAgICAgIGMgPSB0aGlzLmNvbnRhY3RQb2ludFBvb2wucG9wKCk7XG4gICAgICAgIGMuYmkgPSBiaTtcbiAgICAgICAgYy5iaiA9IGJqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGMgPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJpLCBiaik7XG4gICAgfVxuXG4gICAgYy5lbmFibGVkID0gYmkuY29sbGlzaW9uUmVzcG9uc2UgJiYgYmouY29sbGlzaW9uUmVzcG9uc2UgJiYgc2kuY29sbGlzaW9uUmVzcG9uc2UgJiYgc2ouY29sbGlzaW9uUmVzcG9uc2U7XG5cbiAgICB2YXIgY20gPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7XG5cbiAgICBjLnJlc3RpdHV0aW9uID0gY20ucmVzdGl0dXRpb247XG5cbiAgICBjLnNldFNwb29rUGFyYW1zKFxuICAgICAgICBjbS5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MsXG4gICAgICAgIGNtLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24sXG4gICAgICAgIHRoaXMud29ybGQuZHRcbiAgICApO1xuXG4gICAgdmFyIG1hdEEgPSBzaS5tYXRlcmlhbCB8fCBiaS5tYXRlcmlhbDtcbiAgICB2YXIgbWF0QiA9IHNqLm1hdGVyaWFsIHx8IGJqLm1hdGVyaWFsO1xuICAgIGlmKG1hdEEgJiYgbWF0QiAmJiBtYXRBLnJlc3RpdHV0aW9uID49IDAgJiYgbWF0Qi5yZXN0aXR1dGlvbiA+PSAwKXtcbiAgICAgICAgYy5yZXN0aXR1dGlvbiA9IG1hdEEucmVzdGl0dXRpb24gKiBtYXRCLnJlc3RpdHV0aW9uO1xuICAgIH1cblxuICAgIGMuc2kgPSBvdmVycmlkZVNoYXBlQSB8fCBzaTtcbiAgICBjLnNqID0gb3ZlcnJpZGVTaGFwZUIgfHwgc2o7XG5cbiAgICByZXR1cm4gYztcbn07XG5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0ID0gZnVuY3Rpb24oY29udGFjdEVxdWF0aW9uLCBvdXRBcnJheSl7XG4gICAgdmFyIGJvZHlBID0gY29udGFjdEVxdWF0aW9uLmJpO1xuICAgIHZhciBib2R5QiA9IGNvbnRhY3RFcXVhdGlvbi5iajtcbiAgICB2YXIgc2hhcGVBID0gY29udGFjdEVxdWF0aW9uLnNpO1xuICAgIHZhciBzaGFwZUIgPSBjb250YWN0RXF1YXRpb24uc2o7XG5cbiAgICB2YXIgd29ybGQgPSB0aGlzLndvcmxkO1xuICAgIHZhciBjbSA9IHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbDtcblxuICAgIC8vIElmIGZyaWN0aW9uIG9yIHJlc3RpdHV0aW9uIHdlcmUgc3BlY2lmaWVkIGluIHRoZSBtYXRlcmlhbCwgdXNlIHRoZW1cbiAgICB2YXIgZnJpY3Rpb24gPSBjbS5mcmljdGlvbjtcbiAgICB2YXIgbWF0QSA9IHNoYXBlQS5tYXRlcmlhbCB8fCBib2R5QS5tYXRlcmlhbDtcbiAgICB2YXIgbWF0QiA9IHNoYXBlQi5tYXRlcmlhbCB8fCBib2R5Qi5tYXRlcmlhbDtcbiAgICBpZihtYXRBICYmIG1hdEIgJiYgbWF0QS5mcmljdGlvbiA+PSAwICYmIG1hdEIuZnJpY3Rpb24gPj0gMCl7XG4gICAgICAgIGZyaWN0aW9uID0gbWF0QS5mcmljdGlvbiAqIG1hdEIuZnJpY3Rpb247XG4gICAgfVxuXG4gICAgaWYoZnJpY3Rpb24gPiAwKXtcblxuICAgICAgICAvLyBDcmVhdGUgMiB0YW5nZW50IGVxdWF0aW9uc1xuICAgICAgICB2YXIgbXVnID0gZnJpY3Rpb24gKiB3b3JsZC5ncmF2aXR5Lmxlbmd0aCgpO1xuICAgICAgICB2YXIgcmVkdWNlZE1hc3MgPSAoYm9keUEuaW52TWFzcyArIGJvZHlCLmludk1hc3MpO1xuICAgICAgICBpZihyZWR1Y2VkTWFzcyA+IDApe1xuICAgICAgICAgICAgcmVkdWNlZE1hc3MgPSAxL3JlZHVjZWRNYXNzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb29sID0gdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbDtcbiAgICAgICAgdmFyIGMxID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYm9keUEsYm9keUIsbXVnKnJlZHVjZWRNYXNzKTtcbiAgICAgICAgdmFyIGMyID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYm9keUEsYm9keUIsbXVnKnJlZHVjZWRNYXNzKTtcblxuICAgICAgICBjMS5iaSA9IGMyLmJpID0gYm9keUE7XG4gICAgICAgIGMxLmJqID0gYzIuYmogPSBib2R5QjtcbiAgICAgICAgYzEubWluRm9yY2UgPSBjMi5taW5Gb3JjZSA9IC1tdWcqcmVkdWNlZE1hc3M7XG4gICAgICAgIGMxLm1heEZvcmNlID0gYzIubWF4Rm9yY2UgPSBtdWcqcmVkdWNlZE1hc3M7XG5cbiAgICAgICAgLy8gQ29weSBvdmVyIHRoZSByZWxhdGl2ZSB2ZWN0b3JzXG4gICAgICAgIGMxLnJpLmNvcHkoY29udGFjdEVxdWF0aW9uLnJpKTtcbiAgICAgICAgYzEucmouY29weShjb250YWN0RXF1YXRpb24ucmopO1xuICAgICAgICBjMi5yaS5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaSk7XG4gICAgICAgIGMyLnJqLmNvcHkoY29udGFjdEVxdWF0aW9uLnJqKTtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgdGFuZ2VudHNcbiAgICAgICAgY29udGFjdEVxdWF0aW9uLm5pLnRhbmdlbnRzKGMxLnQsIGMyLnQpO1xuXG4gICAgICAgIC8vIFNldCBzcG9vayBwYXJhbXNcbiAgICAgICAgYzEuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIHdvcmxkLmR0KTtcbiAgICAgICAgYzIuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIHdvcmxkLmR0KTtcblxuICAgICAgICBjMS5lbmFibGVkID0gYzIuZW5hYmxlZCA9IGNvbnRhY3RFcXVhdGlvbi5lbmFibGVkO1xuXG4gICAgICAgIG91dEFycmF5LnB1c2goYzEsIGMyKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgYXZlcmFnZU5vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgYXZlcmFnZUNvbnRhY3RQb2ludEEgPSBuZXcgVmVjMygpO1xudmFyIGF2ZXJhZ2VDb250YWN0UG9pbnRCID0gbmV3IFZlYzMoKTtcblxuLy8gVGFrZSB0aGUgYXZlcmFnZSBOIGxhdGVzdCBjb250YWN0IHBvaW50IG9uIHRoZSBwbGFuZS5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlID0gZnVuY3Rpb24obnVtQ29udGFjdHMpe1xuICAgIC8vIFRoZSBsYXN0IGNvbnRhY3RFcXVhdGlvblxuICAgIHZhciBjID0gdGhpcy5yZXN1bHRbdGhpcy5yZXN1bHQubGVuZ3RoIC0gMV07XG5cbiAgICAvLyBDcmVhdGUgdGhlIHJlc3VsdDogdHdvIFwiYXZlcmFnZVwiIGZyaWN0aW9uIGVxdWF0aW9uc1xuICAgIGlmICghdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KGMsIHRoaXMuZnJpY3Rpb25SZXN1bHQpIHx8IG51bUNvbnRhY3RzID09PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZjEgPSB0aGlzLmZyaWN0aW9uUmVzdWx0W3RoaXMuZnJpY3Rpb25SZXN1bHQubGVuZ3RoIC0gMl07XG4gICAgdmFyIGYyID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDFdO1xuXG4gICAgYXZlcmFnZU5vcm1hbC5zZXRaZXJvKCk7XG4gICAgYXZlcmFnZUNvbnRhY3RQb2ludEEuc2V0WmVybygpO1xuICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRCLnNldFplcm8oKTtcblxuICAgIHZhciBib2R5QSA9IGMuYmk7XG4gICAgdmFyIGJvZHlCID0gYy5iajtcbiAgICBmb3IodmFyIGk9MDsgaSE9PW51bUNvbnRhY3RzOyBpKyspe1xuICAgICAgICBjID0gdGhpcy5yZXN1bHRbdGhpcy5yZXN1bHQubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICBpZihjLmJvZHlBICE9PSBib2R5QSl7XG4gICAgICAgICAgICBhdmVyYWdlTm9ybWFsLnZhZGQoYy5uaSwgYXZlcmFnZU5vcm1hbCk7XG4gICAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50QS52YWRkKGMucmksIGF2ZXJhZ2VDb250YWN0UG9pbnRBKTtcbiAgICAgICAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRCLnZhZGQoYy5yaiwgYXZlcmFnZUNvbnRhY3RQb2ludEIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXZlcmFnZU5vcm1hbC52c3ViKGMubmksIGF2ZXJhZ2VOb3JtYWwpO1xuICAgICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEEudmFkZChjLnJqLCBhdmVyYWdlQ29udGFjdFBvaW50QSk7XG4gICAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmksIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpbnZOdW1Db250YWN0cyA9IDEgLyBudW1Db250YWN0cztcbiAgICBhdmVyYWdlQ29udGFjdFBvaW50QS5zY2FsZShpbnZOdW1Db250YWN0cywgZjEucmkpO1xuICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRCLnNjYWxlKGludk51bUNvbnRhY3RzLCBmMS5yaik7XG4gICAgZjIucmkuY29weShmMS5yaSk7IC8vIFNob3VsZCBiZSB0aGUgc2FtZVxuICAgIGYyLnJqLmNvcHkoZjEucmopO1xuICAgIGF2ZXJhZ2VOb3JtYWwubm9ybWFsaXplKCk7XG4gICAgYXZlcmFnZU5vcm1hbC50YW5nZW50cyhmMS50LCBmMi50KTtcbiAgICAvLyByZXR1cm4gZXE7XG59O1xuXG5cbnZhciB0bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciB0bXBWZWMyID0gbmV3IFZlYzMoKTtcbnZhciB0bXBRdWF0MSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG52YXIgdG1wUXVhdDIgPSBuZXcgUXVhdGVybmlvbigpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGFsbCBjb250YWN0cyBiZXR3ZWVuIGEgbGlzdCBvZiBib2R5IHBhaXJzXG4gKiBAbWV0aG9kIGdldENvbnRhY3RzXG4gKiBAcGFyYW0ge2FycmF5fSBwMSBBcnJheSBvZiBib2R5IGluZGljZXNcbiAqIEBwYXJhbSB7YXJyYXl9IHAyIEFycmF5IG9mIGJvZHkgaW5kaWNlc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBcnJheSB0byBzdG9yZSBnZW5lcmF0ZWQgY29udGFjdHNcbiAqIEBwYXJhbSB7YXJyYXl9IG9sZGNvbnRhY3RzIE9wdGlvbmFsLiBBcnJheSBvZiByZXVzYWJsZSBjb250YWN0IG9iamVjdHNcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmdldENvbnRhY3RzID0gZnVuY3Rpb24ocDEsIHAyLCB3b3JsZCwgcmVzdWx0LCBvbGRjb250YWN0cywgZnJpY3Rpb25SZXN1bHQsIGZyaWN0aW9uUG9vbCl7XG4gICAgLy8gU2F2ZSBvbGQgY29udGFjdCBvYmplY3RzXG4gICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gb2xkY29udGFjdHM7XG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IGZyaWN0aW9uUG9vbDtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gZnJpY3Rpb25SZXN1bHQ7XG5cbiAgICB2YXIgcWkgPSB0bXBRdWF0MTtcbiAgICB2YXIgcWogPSB0bXBRdWF0MjtcbiAgICB2YXIgeGkgPSB0bXBWZWMxO1xuICAgIHZhciB4aiA9IHRtcFZlYzI7XG5cbiAgICBmb3IodmFyIGs9MCwgTj1wMS5sZW5ndGg7IGshPT1OOyBrKyspe1xuXG4gICAgICAgIC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBib2RpZXNcbiAgICAgICAgdmFyIGJpID0gcDFba10sXG4gICAgICAgICAgICBiaiA9IHAyW2tdO1xuXG4gICAgICAgIC8vIEdldCBjb250YWN0IG1hdGVyaWFsXG4gICAgICAgIHZhciBib2R5Q29udGFjdE1hdGVyaWFsID0gbnVsbDtcbiAgICAgICAgaWYoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpe1xuICAgICAgICAgICAgYm9keUNvbnRhY3RNYXRlcmlhbCA9IHdvcmxkLmdldENvbnRhY3RNYXRlcmlhbChiaS5tYXRlcmlhbCxiai5tYXRlcmlhbCkgfHwgbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBqdXN0VGVzdCA9IChcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAoYmkudHlwZSAmIEJvZHkuS0lORU1BVElDKSAmJiAoYmoudHlwZSAmIEJvZHkuU1RBVElDKVxuICAgICAgICAgICAgKSB8fCAoXG4gICAgICAgICAgICAgICAgKGJpLnR5cGUgJiBCb2R5LlNUQVRJQykgJiYgKGJqLnR5cGUgJiBCb2R5LktJTkVNQVRJQylcbiAgICAgICAgICAgICkgfHwgKFxuICAgICAgICAgICAgICAgIChiaS50eXBlICYgQm9keS5LSU5FTUFUSUMpICYmIChiai50eXBlICYgQm9keS5LSU5FTUFUSUMpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaS5zaGFwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJpLnF1YXRlcm5pb24ubXVsdChiaS5zaGFwZU9yaWVudGF0aW9uc1tpXSwgcWkpO1xuICAgICAgICAgICAgYmkucXVhdGVybmlvbi52bXVsdChiaS5zaGFwZU9mZnNldHNbaV0sIHhpKTtcbiAgICAgICAgICAgIHhpLnZhZGQoYmkucG9zaXRpb24sIHhpKTtcbiAgICAgICAgICAgIHZhciBzaSA9IGJpLnNoYXBlc1tpXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiai5zaGFwZXMubGVuZ3RoOyBqKyspIHtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgd29ybGQgdHJhbnNmb3JtIG9mIHNoYXBlc1xuICAgICAgICAgICAgICAgIGJqLnF1YXRlcm5pb24ubXVsdChiai5zaGFwZU9yaWVudGF0aW9uc1tqXSwgcWopO1xuICAgICAgICAgICAgICAgIGJqLnF1YXRlcm5pb24udm11bHQoYmouc2hhcGVPZmZzZXRzW2pdLCB4aik7XG4gICAgICAgICAgICAgICAgeGoudmFkZChiai5wb3NpdGlvbiwgeGopO1xuICAgICAgICAgICAgICAgIHZhciBzaiA9IGJqLnNoYXBlc1tqXTtcblxuICAgICAgICAgICAgICAgIGlmKCEoKHNpLmNvbGxpc2lvbkZpbHRlck1hc2sgJiBzai5jb2xsaXNpb25GaWx0ZXJHcm91cCkgJiYgKHNqLmNvbGxpc2lvbkZpbHRlck1hc2sgJiBzaS5jb2xsaXNpb25GaWx0ZXJHcm91cCkpKXtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKXtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGNvbGxpc2lvbiBtYXRlcmlhbFxuICAgICAgICAgICAgICAgIHZhciBzaGFwZUNvbnRhY3RNYXRlcmlhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYoc2kubWF0ZXJpYWwgJiYgc2oubWF0ZXJpYWwpe1xuICAgICAgICAgICAgICAgICAgICBzaGFwZUNvbnRhY3RNYXRlcmlhbCA9IHdvcmxkLmdldENvbnRhY3RNYXRlcmlhbChzaS5tYXRlcmlhbCxzai5tYXRlcmlhbCkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWwgPSBzaGFwZUNvbnRhY3RNYXRlcmlhbCB8fCBib2R5Q29udGFjdE1hdGVyaWFsIHx8IHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY29udGFjdHNcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZXIgPSB0aGlzW3NpLnR5cGUgfCBzai50eXBlXTtcbiAgICAgICAgICAgICAgICBpZihyZXNvbHZlcil7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpLnR5cGUgPCBzai50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSByZXNvbHZlci5jYWxsKHRoaXMsIHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqLCBqdXN0VGVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSByZXNvbHZlci5jYWxsKHRoaXMsIHNqLCBzaSwgeGosIHhpLCBxaiwgcWksIGJqLCBiaSwgc2ksIHNqLCBqdXN0VGVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihyZXR2YWwgJiYganVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgb3ZlcmxhcFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ybGQuc2hhcGVPdmVybGFwS2VlcGVyLnNldChzaS5pZCwgc2ouaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ybGQuYm9keU92ZXJsYXBLZWVwZXIuc2V0KGJpLmlkLCBiai5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbnVtV2FybmluZ3MgPSAwO1xudmFyIG1heFdhcm5pbmdzID0gMTA7XG5cbmZ1bmN0aW9uIHdhcm4obXNnKXtcbiAgICBpZihudW1XYXJuaW5ncyA+IG1heFdhcm5pbmdzKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG51bVdhcm5pbmdzKys7XG5cbiAgICBjb25zb2xlLndhcm4obXNnKTtcbn1cblxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmJveEJveCA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNpLm1hdGVyaWFsO1xuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNqLm1hdGVyaWFsO1xuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNqLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIHJldHVybiB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLHhpLHhqLHFpLHFqLGJpLGJqLHNpLHNqLGp1c3RUZXN0KTtcbn07XG5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuYm94Q29udmV4ID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmoscnNpLHJzaixqdXN0VGVzdCl7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgcmV0dXJuIHRoaXMuY29udmV4Q29udmV4KHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixzaix4aSx4aixxaSxxaixiaSxiaixzaSxzaixqdXN0VGVzdCk7XG59O1xuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuUEFSVElDTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib3hQYXJ0aWNsZSA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNpLm1hdGVyaWFsO1xuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIHJldHVybiB0aGlzLmNvbnZleFBhcnRpY2xlKHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixzaix4aSx4aixxaSxxaixiaSxiaixzaSxzaixqdXN0VGVzdCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc3BoZXJlU3BoZXJlXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlNQSEVSRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZVNwaGVyZSA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIHhpLmRpc3RhbmNlU3F1YXJlZCh4aikgPCBNYXRoLnBvdyhzaS5yYWRpdXMgKyBzai5yYWRpdXMsIDIpO1xuICAgIH1cblxuICAgIC8vIFdlIHdpbGwgaGF2ZSBvbmx5IG9uZSBjb250YWN0IGluIHRoaXMgY2FzZVxuICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaik7XG5cbiAgICAvLyBDb250YWN0IG5vcm1hbFxuICAgIHhqLnZzdWIoeGksIHIubmkpO1xuICAgIHIubmkubm9ybWFsaXplKCk7XG5cbiAgICAvLyBDb250YWN0IHBvaW50IGxvY2F0aW9uc1xuICAgIHIucmkuY29weShyLm5pKTtcbiAgICByLnJqLmNvcHkoci5uaSk7XG4gICAgci5yaS5tdWx0KHNpLnJhZGl1cywgci5yaSk7XG4gICAgci5yai5tdWx0KC1zai5yYWRpdXMsIHIucmopO1xuXG4gICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuXG4gICAgci5yai52YWRkKHhqLCByLnJqKTtcbiAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xuXG4gICAgdGhpcy5yZXN1bHQucHVzaChyKTtcblxuICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBwbGFuZVRyaW1lc2hcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG52YXIgcGxhbmVUcmltZXNoX25vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgcGxhbmVUcmltZXNoX3JlbHBvcyA9IG5ldyBWZWMzKCk7XG52YXIgcGxhbmVUcmltZXNoX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUExBTkUgfCBTaGFwZS50eXBlcy5UUklNRVNIXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVUcmltZXNoID0gZnVuY3Rpb24oXG4gICAgcGxhbmVTaGFwZSxcbiAgICB0cmltZXNoU2hhcGUsXG4gICAgcGxhbmVQb3MsXG4gICAgdHJpbWVzaFBvcyxcbiAgICBwbGFuZVF1YXQsXG4gICAgdHJpbWVzaFF1YXQsXG4gICAgcGxhbmVCb2R5LFxuICAgIHRyaW1lc2hCb2R5LFxuICAgIHJzaSxcbiAgICByc2osXG4gICAganVzdFRlc3Rcbil7XG4gICAgLy8gTWFrZSBjb250YWN0cyFcbiAgICB2YXIgdiA9IG5ldyBWZWMzKCk7XG5cbiAgICB2YXIgbm9ybWFsID0gcGxhbmVUcmltZXNoX25vcm1hbDtcbiAgICBub3JtYWwuc2V0KDAsMCwxKTtcbiAgICBwbGFuZVF1YXQudm11bHQobm9ybWFsLG5vcm1hbCk7IC8vIFR1cm4gbm9ybWFsIGFjY29yZGluZyB0byBwbGFuZVxuXG4gICAgZm9yKHZhciBpPTA7IGk8dHJpbWVzaFNoYXBlLnZlcnRpY2VzLmxlbmd0aCAvIDM7IGkrKyl7XG5cbiAgICAgICAgLy8gR2V0IHdvcmxkIHZlcnRleCBmcm9tIHRyaW1lc2hcbiAgICAgICAgdHJpbWVzaFNoYXBlLmdldFZlcnRleChpLCB2KTtcblxuICAgICAgICAvLyBTYWZlIHVwXG4gICAgICAgIHZhciB2MiA9IG5ldyBWZWMzKCk7XG4gICAgICAgIHYyLmNvcHkodik7XG4gICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdjIsIHYpO1xuXG4gICAgICAgIC8vIENoZWNrIHBsYW5lIHNpZGVcbiAgICAgICAgdmFyIHJlbHBvcyA9IHBsYW5lVHJpbWVzaF9yZWxwb3M7XG4gICAgICAgIHYudnN1YihwbGFuZVBvcywgcmVscG9zKTtcbiAgICAgICAgdmFyIGRvdCA9IG5vcm1hbC5kb3QocmVscG9zKTtcblxuICAgICAgICBpZihkb3QgPD0gMC4wKXtcbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksdHJpbWVzaEJvZHkscGxhbmVTaGFwZSx0cmltZXNoU2hhcGUscnNpLHJzaik7XG5cbiAgICAgICAgICAgIHIubmkuY29weShub3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbCBpcyB0aGUgcGxhbmUgbm9ybWFsXG5cbiAgICAgICAgICAgIC8vIEdldCB2ZXJ0ZXggcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXG4gICAgICAgICAgICB2YXIgcHJvamVjdGVkID0gcGxhbmVUcmltZXNoX3Byb2plY3RlZDtcbiAgICAgICAgICAgIG5vcm1hbC5zY2FsZShyZWxwb3MuZG90KG5vcm1hbCksIHByb2plY3RlZCk7XG4gICAgICAgICAgICB2LnZzdWIocHJvamVjdGVkLHByb2plY3RlZCk7XG5cbiAgICAgICAgICAgIC8vIHJpIGlzIHRoZSBwcm9qZWN0ZWQgd29ybGQgcG9zaXRpb24gbWludXMgcGxhbmUgcG9zaXRpb25cbiAgICAgICAgICAgIHIucmkuY29weShwcm9qZWN0ZWQpO1xuICAgICAgICAgICAgci5yaS52c3ViKHBsYW5lQm9keS5wb3NpdGlvbiwgci5yaSk7XG5cbiAgICAgICAgICAgIHIucmouY29weSh2KTtcbiAgICAgICAgICAgIHIucmoudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHJlc3VsdFxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQG1ldGhvZCBzcGhlcmVUcmltZXNoXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzcGhlcmVTaGFwZVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgdHJpbWVzaFNoYXBlXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICBzcGhlcmVQb3NcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHRyaW1lc2hQb3NcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHNwaGVyZVF1YXRcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHRyaW1lc2hRdWF0XG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBzcGhlcmVCb2R5XG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICB0cmltZXNoQm9keVxuICovXG52YXIgc3BoZXJlVHJpbWVzaF9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfcmVscG9zID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlVHJpbWVzaF92ID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3YyID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhBID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhCID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3IgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvclVuaXQgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVQb3MgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfdG1wID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3ZhID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3ZiID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3ZjID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlQUFCQiA9IG5ldyBBQUJCKCk7XG52YXIgc3BoZXJlVHJpbWVzaF90cmlhbmdsZXMgPSBbXTtcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5UUklNRVNIXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlVHJpbWVzaCA9IGZ1bmN0aW9uIChcbiAgICBzcGhlcmVTaGFwZSxcbiAgICB0cmltZXNoU2hhcGUsXG4gICAgc3BoZXJlUG9zLFxuICAgIHRyaW1lc2hQb3MsXG4gICAgc3BoZXJlUXVhdCxcbiAgICB0cmltZXNoUXVhdCxcbiAgICBzcGhlcmVCb2R5LFxuICAgIHRyaW1lc2hCb2R5LFxuICAgIHJzaSxcbiAgICByc2osXG4gICAganVzdFRlc3Rcbikge1xuXG4gICAgdmFyIGVkZ2VWZXJ0ZXhBID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QTtcbiAgICB2YXIgZWRnZVZlcnRleEIgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhCO1xuICAgIHZhciBlZGdlVmVjdG9yID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yO1xuICAgIHZhciBlZGdlVmVjdG9yVW5pdCA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvclVuaXQ7XG4gICAgdmFyIGxvY2FsU3BoZXJlUG9zID0gc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZVBvcztcbiAgICB2YXIgdG1wID0gc3BoZXJlVHJpbWVzaF90bXA7XG4gICAgdmFyIGxvY2FsU3BoZXJlQUFCQiA9IHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVBQUJCO1xuICAgIHZhciB2MiA9IHNwaGVyZVRyaW1lc2hfdjI7XG4gICAgdmFyIHJlbHBvcyA9IHNwaGVyZVRyaW1lc2hfcmVscG9zO1xuICAgIHZhciB0cmlhbmdsZXMgPSBzcGhlcmVUcmltZXNoX3RyaWFuZ2xlcztcblxuICAgIC8vIENvbnZlcnQgc3BoZXJlIHBvc2l0aW9uIHRvIGxvY2FsIGluIHRoZSB0cmltZXNoXG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCBzcGhlcmVQb3MsIGxvY2FsU3BoZXJlUG9zKTtcblxuICAgIC8vIEdldCB0aGUgYWFiYiBvZiB0aGUgc3BoZXJlIGxvY2FsbHkgaW4gdGhlIHRyaW1lc2hcbiAgICB2YXIgc3BoZXJlUmFkaXVzID0gc3BoZXJlU2hhcGUucmFkaXVzO1xuICAgIGxvY2FsU3BoZXJlQUFCQi5sb3dlckJvdW5kLnNldChcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueCAtIHNwaGVyZVJhZGl1cyxcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueSAtIHNwaGVyZVJhZGl1cyxcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueiAtIHNwaGVyZVJhZGl1c1xuICAgICk7XG4gICAgbG9jYWxTcGhlcmVBQUJCLnVwcGVyQm91bmQuc2V0KFxuICAgICAgICBsb2NhbFNwaGVyZVBvcy54ICsgc3BoZXJlUmFkaXVzLFxuICAgICAgICBsb2NhbFNwaGVyZVBvcy55ICsgc3BoZXJlUmFkaXVzLFxuICAgICAgICBsb2NhbFNwaGVyZVBvcy56ICsgc3BoZXJlUmFkaXVzXG4gICAgKTtcblxuICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZXNJbkFBQkIobG9jYWxTcGhlcmVBQUJCLCB0cmlhbmdsZXMpO1xuICAgIC8vZm9yICh2YXIgaSA9IDA7IGkgPCB0cmltZXNoU2hhcGUuaW5kaWNlcy5sZW5ndGggLyAzOyBpKyspIHRyaWFuZ2xlcy5wdXNoKGkpOyAvLyBBbGxcblxuICAgIC8vIFZlcnRpY2VzXG4gICAgdmFyIHYgPSBzcGhlcmVUcmltZXNoX3Y7XG4gICAgdmFyIHJhZGl1c1NxdWFyZWQgPSBzcGhlcmVTaGFwZS5yYWRpdXMgKiBzcGhlcmVTaGFwZS5yYWRpdXM7XG4gICAgZm9yKHZhciBpPTA7IGk8dHJpYW5nbGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyBqKyspIHtcblxuICAgICAgICAgICAgdHJpbWVzaFNoYXBlLmdldFZlcnRleCh0cmltZXNoU2hhcGUuaW5kaWNlc1t0cmlhbmdsZXNbaV0gKiAzICsgal0sIHYpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB2ZXJ0ZXggb3ZlcmxhcCBpbiBzcGhlcmVcbiAgICAgICAgICAgIHYudnN1Yihsb2NhbFNwaGVyZVBvcywgcmVscG9zKTtcblxuICAgICAgICAgICAgaWYocmVscG9zLm5vcm0yKCkgPD0gcmFkaXVzU3F1YXJlZCl7XG5cbiAgICAgICAgICAgICAgICAvLyBTYWZlIHVwXG4gICAgICAgICAgICAgICAgdjIuY29weSh2KTtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHYyLCB2KTtcblxuICAgICAgICAgICAgICAgIHYudnN1YihzcGhlcmVQb3MsIHJlbHBvcyk7XG5cbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSx0cmltZXNoQm9keSxzcGhlcmVTaGFwZSx0cmltZXNoU2hhcGUscnNpLHJzaik7XG4gICAgICAgICAgICAgICAgci5uaS5jb3B5KHJlbHBvcyk7XG4gICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgIC8vIHJpIGlzIHRoZSB2ZWN0b3IgZnJvbSBzcGhlcmUgY2VudGVyIHRvIHRoZSBzcGhlcmUgc3VyZmFjZVxuICAgICAgICAgICAgICAgIHIucmkuY29weShyLm5pKTtcbiAgICAgICAgICAgICAgICByLnJpLnNjYWxlKHNwaGVyZVNoYXBlLnJhZGl1cywgci5yaSk7XG4gICAgICAgICAgICAgICAgci5yaS52YWRkKHNwaGVyZVBvcywgci5yaSk7XG4gICAgICAgICAgICAgICAgci5yaS52c3ViKHNwaGVyZUJvZHkucG9zaXRpb24sIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgci5yai5jb3B5KHYpO1xuICAgICAgICAgICAgICAgIHIucmoudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSByZXN1bHRcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGFsbCBlZGdlc1xuICAgIGZvcih2YXIgaT0wOyBpPHRyaWFuZ2xlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG5cbiAgICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArIGpdLCBlZGdlVmVydGV4QSk7XG4gICAgICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KHRyaW1lc2hTaGFwZS5pbmRpY2VzW3RyaWFuZ2xlc1tpXSAqIDMgKyAoKGorMSklMyldLCBlZGdlVmVydGV4Qik7XG4gICAgICAgICAgICBlZGdlVmVydGV4Qi52c3ViKGVkZ2VWZXJ0ZXhBLCBlZGdlVmVjdG9yKTtcblxuICAgICAgICAgICAgLy8gUHJvamVjdCBzcGhlcmUgcG9zaXRpb24gdG8gdGhlIGVkZ2VcbiAgICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEIsIHRtcCk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25BbG9uZ0VkZ2VCID0gdG1wLmRvdChlZGdlVmVjdG9yKTtcblxuICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3IpO1xuXG4gICAgICAgICAgICBpZihwb3NpdGlvbkFsb25nRWRnZUEgPiAwICYmIHBvc2l0aW9uQWxvbmdFZGdlQiA8IDApe1xuXG4gICAgICAgICAgICAgICAgLy8gTm93IGNoZWNrIHRoZSBvcnRob2dvbmFsIGRpc3RhbmNlIGZyb20gZWRnZSB0byBzcGhlcmUgY2VudGVyXG4gICAgICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTtcblxuICAgICAgICAgICAgICAgIGVkZ2VWZWN0b3JVbml0LmNvcHkoZWRnZVZlY3Rvcik7XG4gICAgICAgICAgICAgICAgZWRnZVZlY3RvclVuaXQubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25BbG9uZ0VkZ2VBID0gdG1wLmRvdChlZGdlVmVjdG9yVW5pdCk7XG5cbiAgICAgICAgICAgICAgICBlZGdlVmVjdG9yVW5pdC5zY2FsZShwb3NpdGlvbkFsb25nRWRnZUEsIHRtcCk7XG4gICAgICAgICAgICAgICAgdG1wLnZhZGQoZWRnZVZlcnRleEEsIHRtcCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0bXAgaXMgbm93IHRoZSBzcGhlcmUgY2VudGVyIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgZWRnZSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSB0cmltZXNoIGZyYW1lXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSB0bXAuZGlzdGFuY2VUbyhsb2NhbFNwaGVyZVBvcyk7XG4gICAgICAgICAgICAgICAgaWYoZGlzdCA8IHNwaGVyZVNoYXBlLnJhZGl1cyl7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHNwaGVyZUJvZHksIHRyaW1lc2hCb2R5LCBzcGhlcmVTaGFwZSwgdHJpbWVzaFNoYXBlLHJzaSxyc2opO1xuXG4gICAgICAgICAgICAgICAgICAgIHRtcC52c3ViKGxvY2FsU3BoZXJlUG9zLCByLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgci5uaS5zY2FsZShzcGhlcmVTaGFwZS5yYWRpdXMsIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdG1wLCB0bXApO1xuICAgICAgICAgICAgICAgICAgICB0bXAudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSh0cmltZXNoUXVhdCwgci5uaSwgci5uaSk7XG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmlhbmdsZSBmYWNlc1xuICAgIHZhciB2YSA9IHNwaGVyZVRyaW1lc2hfdmE7XG4gICAgdmFyIHZiID0gc3BoZXJlVHJpbWVzaF92YjtcbiAgICB2YXIgdmMgPSBzcGhlcmVUcmltZXNoX3ZjO1xuICAgIHZhciBub3JtYWwgPSBzcGhlcmVUcmltZXNoX25vcm1hbDtcbiAgICBmb3IodmFyIGk9MCwgTiA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgIT09IE47IGkrKyl7XG4gICAgICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZVZlcnRpY2VzKHRyaWFuZ2xlc1tpXSwgdmEsIHZiLCB2Yyk7XG4gICAgICAgIHRyaW1lc2hTaGFwZS5nZXROb3JtYWwodHJpYW5nbGVzW2ldLCBub3JtYWwpO1xuICAgICAgICBsb2NhbFNwaGVyZVBvcy52c3ViKHZhLCB0bXApO1xuICAgICAgICB2YXIgZGlzdCA9IHRtcC5kb3Qobm9ybWFsKTtcbiAgICAgICAgbm9ybWFsLnNjYWxlKGRpc3QsIHRtcCk7XG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIodG1wLCB0bXApO1xuXG4gICAgICAgIC8vIHRtcCBpcyBub3cgdGhlIHNwaGVyZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIHRyaWFuZ2xlIHBsYW5lXG4gICAgICAgIGRpc3QgPSB0bXAuZGlzdGFuY2VUbyhsb2NhbFNwaGVyZVBvcyk7XG4gICAgICAgIGlmKFJheS5wb2ludEluVHJpYW5nbGUodG1wLCB2YSwgdmIsIHZjKSAmJiBkaXN0IDwgc3BoZXJlU2hhcGUucmFkaXVzKXtcbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHNwaGVyZVNoYXBlLCB0cmltZXNoU2hhcGUscnNpLHJzaik7XG5cbiAgICAgICAgICAgIHRtcC52c3ViKGxvY2FsU3BoZXJlUG9zLCByLm5pKTtcbiAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICByLm5pLnNjYWxlKHNwaGVyZVNoYXBlLnJhZGl1cywgci5yaSk7XG5cbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdG1wLCB0bXApO1xuICAgICAgICAgICAgdG1wLnZzdWIodHJpbWVzaEJvZHkucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHRyaW1lc2hRdWF0LCByLm5pLCByLm5pKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpO1xuXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdHJpYW5nbGVzLmxlbmd0aCA9IDA7XG59O1xuXG52YXIgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlID0gbmV3IFZlYzMoKTtcbnZhciBwbGFuZV90b19zcGhlcmVfb3J0aG8gPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2Qgc3BoZXJlUGxhbmVcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuUExBTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVQbGFuZSA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xuICAgIC8vIFdlIHdpbGwgaGF2ZSBvbmUgY29udGFjdCBpbiB0aGlzIGNhc2VcbiAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xuXG4gICAgLy8gQ29udGFjdCBub3JtYWxcbiAgICByLm5pLnNldCgwLDAsMSk7XG4gICAgcWoudm11bHQoci5uaSwgci5uaSk7XG4gICAgci5uaS5uZWdhdGUoci5uaSk7IC8vIGJvZHkgaSBpcyB0aGUgc3BoZXJlLCBmbGlwIG5vcm1hbFxuICAgIHIubmkubm9ybWFsaXplKCk7IC8vIE5lZWRlZD9cblxuICAgIC8vIFZlY3RvciBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gY29udGFjdCBwb2ludFxuICAgIHIubmkubXVsdChzaS5yYWRpdXMsIHIucmkpO1xuXG4gICAgLy8gUHJvamVjdCBkb3duIHNwaGVyZSBvbiBwbGFuZVxuICAgIHhpLnZzdWIoeGosIHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSk7XG4gICAgci5uaS5tdWx0KHIubmkuZG90KHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSksIHBsYW5lX3RvX3NwaGVyZV9vcnRobyk7XG4gICAgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLnZzdWIocGxhbmVfdG9fc3BoZXJlX29ydGhvLHIucmopOyAvLyBUaGUgc3BoZXJlIHBvc2l0aW9uIHByb2plY3RlZCB0byBwbGFuZVxuXG4gICAgaWYoLXBvaW50X29uX3BsYW5lX3RvX3NwaGVyZS5kb3Qoci5uaSkgPD0gc2kucmFkaXVzKXtcblxuICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIGJvZHlcbiAgICAgICAgdmFyIHJpID0gci5yaTtcbiAgICAgICAgdmFyIHJqID0gci5yajtcbiAgICAgICAgcmkudmFkZCh4aSwgcmkpO1xuICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7XG4gICAgICAgIHJqLnZhZGQoeGosIHJqKTtcbiAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopO1xuXG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICB9XG59O1xuXG4vLyBTZWUgaHR0cDovL2J1bGxldHBoeXNpY3MuY29tL0J1bGxldC9CdWxsZXRGdWxsL1NwaGVyZVRyaWFuZ2xlRGV0ZWN0b3JfOGNwcF9zb3VyY2UuaHRtbFxudmFyIHBvaW50SW5Qb2x5Z29uX2VkZ2UgPSBuZXcgVmVjMygpO1xudmFyIHBvaW50SW5Qb2x5Z29uX2VkZ2VfeF9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIHBvaW50SW5Qb2x5Z29uX3Z0cCA9IG5ldyBWZWMzKCk7XG5mdW5jdGlvbiBwb2ludEluUG9seWdvbih2ZXJ0cywgbm9ybWFsLCBwKXtcbiAgICB2YXIgcG9zaXRpdmVSZXN1bHQgPSBudWxsO1xuICAgIHZhciBOID0gdmVydHMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcblxuICAgICAgICAvLyBHZXQgZWRnZSB0byB0aGUgbmV4dCB2ZXJ0ZXhcbiAgICAgICAgdmFyIGVkZ2UgPSBwb2ludEluUG9seWdvbl9lZGdlO1xuICAgICAgICB2ZXJ0c1soaSsxKSAlIChOKV0udnN1Yih2LGVkZ2UpO1xuXG4gICAgICAgIC8vIEdldCBjcm9zcyBwcm9kdWN0IGJldHdlZW4gcG9seWdvbiBub3JtYWwgYW5kIHRoZSBlZGdlXG4gICAgICAgIHZhciBlZGdlX3hfbm9ybWFsID0gcG9pbnRJblBvbHlnb25fZWRnZV94X25vcm1hbDtcbiAgICAgICAgLy92YXIgZWRnZV94X25vcm1hbCA9IG5ldyBWZWMzKCk7XG4gICAgICAgIGVkZ2UuY3Jvc3Mobm9ybWFsLGVkZ2VfeF9ub3JtYWwpO1xuXG4gICAgICAgIC8vIEdldCB2ZWN0b3IgYmV0d2VlbiBwb2ludCBhbmQgY3VycmVudCB2ZXJ0ZXhcbiAgICAgICAgdmFyIHZlcnRleF90b19wID0gcG9pbnRJblBvbHlnb25fdnRwO1xuICAgICAgICBwLnZzdWIodix2ZXJ0ZXhfdG9fcCk7XG5cbiAgICAgICAgLy8gVGhpcyBkb3QgcHJvZHVjdCBkZXRlcm1pbmVzIHdoaWNoIHNpZGUgb2YgdGhlIGVkZ2UgdGhlIHBvaW50IGlzXG4gICAgICAgIHZhciByID0gZWRnZV94X25vcm1hbC5kb3QodmVydGV4X3RvX3ApO1xuXG4gICAgICAgIC8vIElmIGFsbCBzdWNoIGRvdCBwcm9kdWN0cyBoYXZlIHNhbWUgc2lnbiwgd2UgYXJlIGluc2lkZSB0aGUgcG9seWdvbi5cbiAgICAgICAgaWYocG9zaXRpdmVSZXN1bHQ9PT1udWxsIHx8IChyPjAgJiYgcG9zaXRpdmVSZXN1bHQ9PT10cnVlKSB8fCAocjw9MCAmJiBwb3NpdGl2ZVJlc3VsdD09PWZhbHNlKSl7XG4gICAgICAgICAgICBpZihwb3NpdGl2ZVJlc3VsdD09PW51bGwpe1xuICAgICAgICAgICAgICAgIHBvc2l0aXZlUmVzdWx0ID0gcj4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVuY291bnRlcmVkIHNvbWUgb3RoZXIgc2lnbi4gRXhpdC5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGdvdCBoZXJlLCBhbGwgZG90IHByb2R1Y3RzIHdlcmUgb2YgdGhlIHNhbWUgc2lnbi5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGJveF90b19zcGhlcmUgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9ucyA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQm94X25zMSA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQm94X25zMiA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQm94X3NpZGVzID0gW25ldyBWZWMzKCksbmV3IFZlYzMoKSxuZXcgVmVjMygpLG5ldyBWZWMzKCksbmV3IFZlYzMoKSxuZXcgVmVjMygpXTtcbnZhciBzcGhlcmVCb3hfc3BoZXJlX3RvX2Nvcm5lciA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQm94X3NpZGVfbnMgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9zaWRlX25zMSA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQm94X3NpZGVfbnMyID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHNwaGVyZUJveFxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5CT1hdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVCb3ggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGp1c3RUZXN0KXtcbiAgICB2YXIgdjNwb29sID0gdGhpcy52M3Bvb2w7XG5cbiAgICAvLyB3ZSByZWZlciB0byB0aGUgYm94IGFzIGJvZHkgalxuICAgIHZhciBzaWRlcyA9IHNwaGVyZUJveF9zaWRlcztcbiAgICB4aS52c3ViKHhqLGJveF90b19zcGhlcmUpO1xuICAgIHNqLmdldFNpZGVOb3JtYWxzKHNpZGVzLHFqKTtcbiAgICB2YXIgUiA9ICAgICBzaS5yYWRpdXM7XG4gICAgdmFyIHBlbmV0cmF0aW5nX3NpZGVzID0gW107XG5cbiAgICAvLyBDaGVjayBzaWRlIChwbGFuZSkgaW50ZXJzZWN0aW9uc1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gICAgLy8gU3RvcmUgdGhlIHJlc3VsdGluZyBzaWRlIHBlbmV0cmF0aW9uIGluZm9cbiAgICB2YXIgc2lkZV9ucyA9IHNwaGVyZUJveF9zaWRlX25zO1xuICAgIHZhciBzaWRlX25zMSA9IHNwaGVyZUJveF9zaWRlX25zMTtcbiAgICB2YXIgc2lkZV9uczIgPSBzcGhlcmVCb3hfc2lkZV9uczI7XG4gICAgdmFyIHNpZGVfaCA9IG51bGw7XG4gICAgdmFyIHNpZGVfcGVuZXRyYXRpb25zID0gMDtcbiAgICB2YXIgc2lkZV9kb3QxID0gMDtcbiAgICB2YXIgc2lkZV9kb3QyID0gMDtcbiAgICB2YXIgc2lkZV9kaXN0YW5jZSA9IG51bGw7XG4gICAgZm9yKHZhciBpZHg9MCxuc2lkZXM9c2lkZXMubGVuZ3RoOyBpZHghPT1uc2lkZXMgJiYgZm91bmQ9PT1mYWxzZTsgaWR4Kyspe1xuICAgICAgICAvLyBHZXQgdGhlIHBsYW5lIHNpZGUgbm9ybWFsIChucylcbiAgICAgICAgdmFyIG5zID0gc3BoZXJlQm94X25zO1xuICAgICAgICBucy5jb3B5KHNpZGVzW2lkeF0pO1xuXG4gICAgICAgIHZhciBoID0gbnMubm9ybSgpO1xuICAgICAgICBucy5ub3JtYWxpemUoKTtcblxuICAgICAgICAvLyBUaGUgbm9ybWFsL2Rpc3RhbmNlIGRvdCBwcm9kdWN0IHRlbGxzIHdoaWNoIHNpZGUgb2YgdGhlIHBsYW5lIHdlIGFyZVxuICAgICAgICB2YXIgZG90ID0gYm94X3RvX3NwaGVyZS5kb3QobnMpO1xuXG4gICAgICAgIGlmKGRvdDxoK1IgJiYgZG90PjApe1xuICAgICAgICAgICAgLy8gSW50ZXJzZWN0cyBwbGFuZS4gTm93IGNoZWNrIHRoZSBvdGhlciB0d28gZGltZW5zaW9uc1xuICAgICAgICAgICAgdmFyIG5zMSA9IHNwaGVyZUJveF9uczE7XG4gICAgICAgICAgICB2YXIgbnMyID0gc3BoZXJlQm94X25zMjtcbiAgICAgICAgICAgIG5zMS5jb3B5KHNpZGVzWyhpZHgrMSklM10pO1xuICAgICAgICAgICAgbnMyLmNvcHkoc2lkZXNbKGlkeCsyKSUzXSk7XG4gICAgICAgICAgICB2YXIgaDEgPSBuczEubm9ybSgpO1xuICAgICAgICAgICAgdmFyIGgyID0gbnMyLm5vcm0oKTtcbiAgICAgICAgICAgIG5zMS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIG5zMi5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHZhciBkb3QxID0gYm94X3RvX3NwaGVyZS5kb3QobnMxKTtcbiAgICAgICAgICAgIHZhciBkb3QyID0gYm94X3RvX3NwaGVyZS5kb3QobnMyKTtcbiAgICAgICAgICAgIGlmKGRvdDE8aDEgJiYgZG90MT4taDEgJiYgZG90MjxoMiAmJiBkb3QyPi1oMil7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBNYXRoLmFicyhkb3QtaC1SKTtcbiAgICAgICAgICAgICAgICBpZihzaWRlX2Rpc3RhbmNlPT09bnVsbCB8fCBkaXN0IDwgc2lkZV9kaXN0YW5jZSl7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfZGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBzaWRlX2RvdDEgPSBkb3QxO1xuICAgICAgICAgICAgICAgICAgICBzaWRlX2RvdDIgPSBkb3QyO1xuICAgICAgICAgICAgICAgICAgICBzaWRlX2ggPSBoO1xuICAgICAgICAgICAgICAgICAgICBzaWRlX25zLmNvcHkobnMpO1xuICAgICAgICAgICAgICAgICAgICBzaWRlX25zMS5jb3B5KG5zMSk7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfbnMyLmNvcHkobnMyKTtcbiAgICAgICAgICAgICAgICAgICAgc2lkZV9wZW5ldHJhdGlvbnMrKztcblxuICAgICAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihzaWRlX3BlbmV0cmF0aW9ucyl7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcbiAgICAgICAgc2lkZV9ucy5tdWx0KC1SLHIucmkpOyAvLyBTcGhlcmUgclxuICAgICAgICByLm5pLmNvcHkoc2lkZV9ucyk7XG4gICAgICAgIHIubmkubmVnYXRlKHIubmkpOyAvLyBOb3JtYWwgc2hvdWxkIGJlIG91dCBvZiBzcGhlcmVcbiAgICAgICAgc2lkZV9ucy5tdWx0KHNpZGVfaCxzaWRlX25zKTtcbiAgICAgICAgc2lkZV9uczEubXVsdChzaWRlX2RvdDEsc2lkZV9uczEpO1xuICAgICAgICBzaWRlX25zLnZhZGQoc2lkZV9uczEsc2lkZV9ucyk7XG4gICAgICAgIHNpZGVfbnMyLm11bHQoc2lkZV9kb3QyLHNpZGVfbnMyKTtcbiAgICAgICAgc2lkZV9ucy52YWRkKHNpZGVfbnMyLHIucmopO1xuXG4gICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG4gICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XG4gICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG4gICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGNvcm5lcnNcbiAgICB2YXIgcmogPSB2M3Bvb2wuZ2V0KCk7XG4gICAgdmFyIHNwaGVyZV90b19jb3JuZXIgPSBzcGhlcmVCb3hfc3BoZXJlX3RvX2Nvcm5lcjtcbiAgICBmb3IodmFyIGo9MDsgaiE9PTIgJiYgIWZvdW5kOyBqKyspe1xuICAgICAgICBmb3IodmFyIGs9MDsgayE9PTIgJiYgIWZvdW5kOyBrKyspe1xuICAgICAgICAgICAgZm9yKHZhciBsPTA7IGwhPT0yICYmICFmb3VuZDsgbCsrKXtcbiAgICAgICAgICAgICAgICByai5zZXQoMCwwLDApO1xuICAgICAgICAgICAgICAgIGlmKGope1xuICAgICAgICAgICAgICAgICAgICByai52YWRkKHNpZGVzWzBdLHJqKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByai52c3ViKHNpZGVzWzBdLHJqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoayl7XG4gICAgICAgICAgICAgICAgICAgIHJqLnZhZGQoc2lkZXNbMV0scmopO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJqLnZzdWIoc2lkZXNbMV0scmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihsKXtcbiAgICAgICAgICAgICAgICAgICAgcmoudmFkZChzaWRlc1syXSxyaik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmoudnN1YihzaWRlc1syXSxyaik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV29ybGQgcG9zaXRpb24gb2YgY29ybmVyXG4gICAgICAgICAgICAgICAgeGoudmFkZChyaixzcGhlcmVfdG9fY29ybmVyKTtcbiAgICAgICAgICAgICAgICBzcGhlcmVfdG9fY29ybmVyLnZzdWIoeGksc3BoZXJlX3RvX2Nvcm5lcik7XG5cbiAgICAgICAgICAgICAgICBpZihzcGhlcmVfdG9fY29ybmVyLm5vcm0yKCkgPCBSKlIpe1xuICAgICAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaik7XG4gICAgICAgICAgICAgICAgICAgIHIucmkuY29weShzcGhlcmVfdG9fY29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgci5yaS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgci5uaS5jb3B5KHIucmkpO1xuICAgICAgICAgICAgICAgICAgICByLnJpLm11bHQoUixyLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgci5yai5jb3B5KHJqKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xuICAgICAgICAgICAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICAgICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuICAgICAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICAgICAgICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdjNwb29sLnJlbGVhc2UocmopO1xuICAgIHJqID0gbnVsbDtcblxuICAgIC8vIENoZWNrIGVkZ2VzXG4gICAgdmFyIGVkZ2VUYW5nZW50ID0gdjNwb29sLmdldCgpO1xuICAgIHZhciBlZGdlQ2VudGVyID0gdjNwb29sLmdldCgpO1xuICAgIHZhciByID0gdjNwb29sLmdldCgpOyAvLyByID0gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlclxuICAgIHZhciBvcnRob2dvbmFsID0gdjNwb29sLmdldCgpO1xuICAgIHZhciBkaXN0ID0gdjNwb29sLmdldCgpO1xuICAgIHZhciBOc2lkZXMgPSBzaWRlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBqPTA7IGohPT1Oc2lkZXMgJiYgIWZvdW5kOyBqKyspe1xuICAgICAgICBmb3IodmFyIGs9MDsgayE9PU5zaWRlcyAmJiAhZm91bmQ7IGsrKyl7XG4gICAgICAgICAgICBpZihqJTMgIT09IGslMyl7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGVkZ2UgdGFuZ2VudFxuICAgICAgICAgICAgICAgIHNpZGVzW2tdLmNyb3NzKHNpZGVzW2pdLGVkZ2VUYW5nZW50KTtcbiAgICAgICAgICAgICAgICBlZGdlVGFuZ2VudC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICBzaWRlc1tqXS52YWRkKHNpZGVzW2tdLCBlZGdlQ2VudGVyKTtcbiAgICAgICAgICAgICAgICByLmNvcHkoeGkpO1xuICAgICAgICAgICAgICAgIHIudnN1YihlZGdlQ2VudGVyLHIpO1xuICAgICAgICAgICAgICAgIHIudnN1Yih4aixyKTtcbiAgICAgICAgICAgICAgICB2YXIgb3J0aG9ub3JtID0gci5kb3QoZWRnZVRhbmdlbnQpOyAvLyBkaXN0YW5jZSBmcm9tIGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBjZW50ZXIgaW4gdGhlIHRhbmdlbnQgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgZWRnZVRhbmdlbnQubXVsdChvcnRob25vcm0sb3J0aG9nb25hbCk7IC8vIFZlY3RvciBmcm9tIGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBjZW50ZXIgaW4gdGhlIHRhbmdlbnQgZGlyZWN0aW9uXG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aGlyZCBzaWRlIG9ydGhvZ29uYWwgdG8gdGhpcyBvbmVcbiAgICAgICAgICAgICAgICB2YXIgbCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUobD09PWolMyB8fCBsPT09ayUzKXtcbiAgICAgICAgICAgICAgICAgICAgbCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHZlYyBmcm9tIGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBwcm9qZWN0ZWQgdG8gdGhlIHBsYW5lIG9ydGhvZ29uYWwgdG8gdGhlIGVkZ2UgdGFuZ2VudFxuICAgICAgICAgICAgICAgIGRpc3QuY29weSh4aSk7XG4gICAgICAgICAgICAgICAgZGlzdC52c3ViKG9ydGhvZ29uYWwsZGlzdCk7XG4gICAgICAgICAgICAgICAgZGlzdC52c3ViKGVkZ2VDZW50ZXIsZGlzdCk7XG4gICAgICAgICAgICAgICAgZGlzdC52c3ViKHhqLGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gRGlzdGFuY2VzIGluIHRhbmdlbnQgZGlyZWN0aW9uIGFuZCBkaXN0YW5jZSBpbiB0aGUgcGxhbmUgb3J0aG9nb25hbCB0byBpdFxuICAgICAgICAgICAgICAgIHZhciB0ZGlzdCA9IE1hdGguYWJzKG9ydGhvbm9ybSk7XG4gICAgICAgICAgICAgICAgdmFyIG5kaXN0ID0gZGlzdC5ub3JtKCk7XG5cbiAgICAgICAgICAgICAgICBpZih0ZGlzdCA8IHNpZGVzW2xdLm5vcm0oKSAmJiBuZGlzdDxSKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaik7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VDZW50ZXIudmFkZChvcnRob2dvbmFsLHJlcy5yaik7IC8vIGJveCByalxuICAgICAgICAgICAgICAgICAgICByZXMucmouY29weShyZXMucmopO1xuICAgICAgICAgICAgICAgICAgICBkaXN0Lm5lZ2F0ZShyZXMubmkpO1xuICAgICAgICAgICAgICAgICAgICByZXMubmkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLmNvcHkocmVzLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZhZGQoeGoscmVzLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZzdWIoeGkscmVzLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXMucmkubXVsdChSLHJlcy5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZhZGQoeGksIHJlcy5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS52c3ViKGJpLnBvc2l0aW9uLCByZXMucmkpO1xuICAgICAgICAgICAgICAgICAgICByZXMucmoudmFkZCh4aiwgcmVzLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJqLnZzdWIoYmoucG9zaXRpb24sIHJlcy5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QocmVzLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdjNwb29sLnJlbGVhc2UoZWRnZVRhbmdlbnQsZWRnZUNlbnRlcixyLG9ydGhvZ29uYWwsZGlzdCk7XG59O1xuXG52YXIgY29udmV4X3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X2VkZ2UgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF9lZGdlVW5pdCA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X3NwaGVyZVRvQ29ybmVyID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVDb252ZXhfd29ybGRDb3JuZXIgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF93b3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X3dvcmxkUG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF93b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF9wZW5ldHJhdGlvblZlYyA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X3NwaGVyZVRvV29ybGRQb2ludCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBzcGhlcmVDb252ZXhcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZUNvbnZleCA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xuICAgIHZhciB2M3Bvb2wgPSB0aGlzLnYzcG9vbDtcbiAgICB4aS52c3ViKHhqLGNvbnZleF90b19zcGhlcmUpO1xuICAgIHZhciBub3JtYWxzID0gc2ouZmFjZU5vcm1hbHM7XG4gICAgdmFyIGZhY2VzID0gc2ouZmFjZXM7XG4gICAgdmFyIHZlcnRzID0gc2oudmVydGljZXM7XG4gICAgdmFyIFIgPSAgICAgc2kucmFkaXVzO1xuICAgIHZhciBwZW5ldHJhdGluZ19zaWRlcyA9IFtdO1xuXG4gICAgLy8gaWYoY29udmV4X3RvX3NwaGVyZS5ub3JtMigpID4gc2kuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzai5ib3VuZGluZ1NwaGVyZVJhZGl1cyl7XG4gICAgLy8gICAgIHJldHVybjtcbiAgICAvLyB9XG5cbiAgICAvLyBDaGVjayBjb3JuZXJzXG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVydHNbaV07XG5cbiAgICAgICAgLy8gV29ybGQgcG9zaXRpb24gb2YgY29ybmVyXG4gICAgICAgIHZhciB3b3JsZENvcm5lciA9IHNwaGVyZUNvbnZleF93b3JsZENvcm5lcjtcbiAgICAgICAgcWoudm11bHQodix3b3JsZENvcm5lcik7XG4gICAgICAgIHhqLnZhZGQod29ybGRDb3JuZXIsd29ybGRDb3JuZXIpO1xuICAgICAgICB2YXIgc3BoZXJlX3RvX2Nvcm5lciA9IHNwaGVyZUNvbnZleF9zcGhlcmVUb0Nvcm5lcjtcbiAgICAgICAgd29ybGRDb3JuZXIudnN1Yih4aSwgc3BoZXJlX3RvX2Nvcm5lcik7XG4gICAgICAgIGlmKHNwaGVyZV90b19jb3JuZXIubm9ybTIoKSA8IFIgKiBSKXtcbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaik7XG4gICAgICAgICAgICByLnJpLmNvcHkoc3BoZXJlX3RvX2Nvcm5lcik7XG4gICAgICAgICAgICByLnJpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgci5uaS5jb3B5KHIucmkpO1xuICAgICAgICAgICAgci5yaS5tdWx0KFIsci5yaSk7XG4gICAgICAgICAgICB3b3JsZENvcm5lci52c3ViKHhqLHIucmopO1xuXG4gICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICAgICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTtcblxuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuICAgICAgICAgICAgci5yai52YWRkKHhqLCByLnJqKTtcbiAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBzaWRlIChwbGFuZSkgaW50ZXJzZWN0aW9uc1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIGZvcih2YXIgaT0wLCBuZmFjZXM9ZmFjZXMubGVuZ3RoOyBpIT09bmZhY2VzICYmIGZvdW5kPT09ZmFsc2U7IGkrKyl7XG4gICAgICAgIHZhciBub3JtYWwgPSBub3JtYWxzW2ldO1xuICAgICAgICB2YXIgZmFjZSA9IGZhY2VzW2ldO1xuXG4gICAgICAgIC8vIEdldCB3b3JsZC10cmFuc2Zvcm1lZCBub3JtYWwgb2YgdGhlIGZhY2VcbiAgICAgICAgdmFyIHdvcmxkTm9ybWFsID0gc3BoZXJlQ29udmV4X3dvcmxkTm9ybWFsO1xuICAgICAgICBxai52bXVsdChub3JtYWwsd29ybGROb3JtYWwpO1xuXG4gICAgICAgIC8vIEdldCBhIHdvcmxkIHZlcnRleCBmcm9tIHRoZSBmYWNlXG4gICAgICAgIHZhciB3b3JsZFBvaW50ID0gc3BoZXJlQ29udmV4X3dvcmxkUG9pbnQ7XG4gICAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2VbMF1dLHdvcmxkUG9pbnQpO1xuICAgICAgICB3b3JsZFBvaW50LnZhZGQoeGosd29ybGRQb2ludCk7XG5cbiAgICAgICAgLy8gR2V0IGEgcG9pbnQgb24gdGhlIHNwaGVyZSwgY2xvc2VzdCB0byB0aGUgZmFjZSBub3JtYWxcbiAgICAgICAgdmFyIHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSA9IHNwaGVyZUNvbnZleF93b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmU7XG4gICAgICAgIHdvcmxkTm9ybWFsLm11bHQoLVIsIHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSk7XG4gICAgICAgIHhpLnZhZGQod29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lLCB3b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUpO1xuXG4gICAgICAgIC8vIFZlY3RvciBmcm9tIGEgZmFjZSBwb2ludCB0byB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgc3BoZXJlXG4gICAgICAgIHZhciBwZW5ldHJhdGlvblZlYyA9IHNwaGVyZUNvbnZleF9wZW5ldHJhdGlvblZlYztcbiAgICAgICAgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lLnZzdWIod29ybGRQb2ludCxwZW5ldHJhdGlvblZlYyk7XG5cbiAgICAgICAgLy8gVGhlIHBlbmV0cmF0aW9uLiBOZWdhdGl2ZSB2YWx1ZSBtZWFucyBvdmVybGFwLlxuICAgICAgICB2YXIgcGVuZXRyYXRpb24gPSBwZW5ldHJhdGlvblZlYy5kb3Qod29ybGROb3JtYWwpO1xuXG4gICAgICAgIHZhciB3b3JsZFBvaW50VG9TcGhlcmUgPSBzcGhlcmVDb252ZXhfc3BoZXJlVG9Xb3JsZFBvaW50O1xuICAgICAgICB4aS52c3ViKHdvcmxkUG9pbnQsIHdvcmxkUG9pbnRUb1NwaGVyZSk7XG5cbiAgICAgICAgaWYocGVuZXRyYXRpb24gPCAwICYmIHdvcmxkUG9pbnRUb1NwaGVyZS5kb3Qod29ybGROb3JtYWwpPjApe1xuICAgICAgICAgICAgLy8gSW50ZXJzZWN0cyBwbGFuZS4gTm93IGNoZWNrIGlmIHRoZSBzcGhlcmUgaXMgaW5zaWRlIHRoZSBmYWNlIHBvbHlnb25cbiAgICAgICAgICAgIHZhciBmYWNlVmVydHMgPSBbXTsgLy8gRmFjZSB2ZXJ0aWNlcywgaW4gd29ybGQgY29vcmRzXG4gICAgICAgICAgICBmb3IodmFyIGo9MCwgTnZlcnRzPWZhY2UubGVuZ3RoOyBqIT09TnZlcnRzOyBqKyspe1xuICAgICAgICAgICAgICAgIHZhciB3b3JsZFZlcnRleCA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlW2pdXSwgd29ybGRWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgIHhqLnZhZGQod29ybGRWZXJ0ZXgsd29ybGRWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgIGZhY2VWZXJ0cy5wdXNoKHdvcmxkVmVydGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYocG9pbnRJblBvbHlnb24oZmFjZVZlcnRzLHdvcmxkTm9ybWFsLHhpKSl7IC8vIElzIHRoZSBzcGhlcmUgY2VudGVyIGluIHRoZSBmYWNlIHBvbHlnb24/XG4gICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaik7XG5cbiAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1SLCByLnJpKTsgLy8gQ29udGFjdCBvZmZzZXQsIGZyb20gc3BoZXJlIGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICAgICAgd29ybGROb3JtYWwubmVnYXRlKHIubmkpOyAvLyBOb3JtYWwgcG9pbnRpbmcgb3V0IG9mIHNwaGVyZVxuXG4gICAgICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uVmVjMiA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1wZW5ldHJhdGlvbiwgcGVuZXRyYXRpb25WZWMyKTtcbiAgICAgICAgICAgICAgICB2YXIgcGVuZXRyYXRpb25TcGhlcmVQb2ludCA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1SLCBwZW5ldHJhdGlvblNwaGVyZVBvaW50KTtcblxuICAgICAgICAgICAgICAgIC8veGkudnN1Yih4aikudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50KS52YWRkKHBlbmV0cmF0aW9uVmVjMiAsIHIucmopO1xuICAgICAgICAgICAgICAgIHhpLnZzdWIoeGosci5yaik7XG4gICAgICAgICAgICAgICAgci5yai52YWRkKHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQsci5yaik7XG4gICAgICAgICAgICAgICAgci5yai52YWRkKHBlbmV0cmF0aW9uVmVjMiAsIHIucmopO1xuXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuICAgICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cbiAgICAgICAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG5cbiAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwZW5ldHJhdGlvblZlYzIpO1xuICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZWxlYXNlIHdvcmxkIHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqPTAsIE5mYWNldmVydHM9ZmFjZVZlcnRzLmxlbmd0aDsgaiE9PU5mYWNldmVydHM7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBvbmx5IGV4cGVjdCAqb25lKiBmYWNlIGNvbnRhY3RcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZT9cbiAgICAgICAgICAgICAgICBmb3IodmFyIGo9MDsgaiE9PWZhY2UubGVuZ3RoOyBqKyspe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0d28gd29ybGQgdHJhbnNmb3JtZWQgdmVydGljZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYxID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdjIgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2VbKGorMSklZmFjZS5sZW5ndGhdXSwgdjEpO1xuICAgICAgICAgICAgICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWyhqKzIpJWZhY2UubGVuZ3RoXV0sIHYyKTtcbiAgICAgICAgICAgICAgICAgICAgeGoudmFkZCh2MSwgdjEpO1xuICAgICAgICAgICAgICAgICAgICB4ai52YWRkKHYyLCB2Mik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IGVkZ2UgdmVjdG9yXG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGdlID0gc3BoZXJlQ29udmV4X2VkZ2U7XG4gICAgICAgICAgICAgICAgICAgIHYyLnZzdWIodjEsZWRnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBzYW1lIHZlY3RvciwgYnV0IG5vcm1hbGl6ZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2VVbml0ID0gc3BoZXJlQ29udmV4X2VkZ2VVbml0O1xuICAgICAgICAgICAgICAgICAgICBlZGdlLnVuaXQoZWRnZVVuaXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHAgaXMgeGkgcHJvamVjdGVkIG9udG8gdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2MV90b194aSA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgeGkudnN1Yih2MSwgdjFfdG9feGkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG90ID0gdjFfdG9feGkuZG90KGVkZ2VVbml0KTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZVVuaXQubXVsdChkb3QsIHApO1xuICAgICAgICAgICAgICAgICAgICBwLnZhZGQodjEsIHApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgYSB2ZWN0b3IgZnJvbSBwIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHNwaGVyZVxuICAgICAgICAgICAgICAgICAgICB2YXIgeGlfdG9fcCA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC52c3ViKHhpLCB4aV90b19wKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb2xsaXNpb24gaWYgdGhlIGVkZ2Utc3BoZXJlIGRpc3RhbmNlIGlzIGxlc3MgdGhhbiB0aGUgcmFkaXVzXG4gICAgICAgICAgICAgICAgICAgIC8vIEFORCBpZiBwIGlzIGluIGJldHdlZW4gdjEgYW5kIHYyXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvdCA+IDAgJiYgZG90KmRvdDxlZGdlLm5vcm0yKCkgJiYgeGlfdG9fcC5ub3JtMigpIDwgUipSKXsgLy8gQ29sbGlzaW9uIGlmIHRoZSBlZGdlLXNwaGVyZSBkaXN0YW5jZSBpcyBsZXNzIHRoYW4gdGhlIHJhZGl1c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWRnZSBjb250YWN0IVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAudnN1Yih4aixyLnJqKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcC52c3ViKHhpLHIubmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgci5uaS5tdWx0KFIsci5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgICAgICAgICAgICAgICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVsZWFzZSB3b3JsZCB2ZXJ0aWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqPTAsIE5mYWNldmVydHM9ZmFjZVZlcnRzLmxlbmd0aDsgaiE9PU5mYWNldmVydHM7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoZmFjZVZlcnRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UocCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh4aV90b19wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxX3RvX3hpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjEpO1xuICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2Mik7XG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHApO1xuICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh4aV90b19wKTtcbiAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjFfdG9feGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVsZWFzZSB3b3JsZCB2ZXJ0aWNlc1xuICAgICAgICAgICAgZm9yKHZhciBqPTAsIE5mYWNldmVydHM9ZmFjZVZlcnRzLmxlbmd0aDsgaiE9PU5mYWNldmVydHM7IGorKyl7XG4gICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoZmFjZVZlcnRzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBwbGFuZUJveF9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIHBsYW5lX3RvX2Nvcm5lciA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBwbGFuZUJveFxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuQk9YXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVCb3ggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGp1c3RUZXN0KXtcbiAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzai5tYXRlcmlhbDtcbiAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzai5jb2xsaXNpb25SZXNwb25zZTtcbiAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uaWQgPSBzai5pZDtcbiAgICByZXR1cm4gdGhpcy5wbGFuZUNvbnZleChzaSxzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24seGkseGoscWkscWosYmksYmosc2ksc2osanVzdFRlc3QpO1xufTtcblxudmFyIHBsYW5lQ29udmV4X3YgPSBuZXcgVmVjMygpO1xudmFyIHBsYW5lQ29udmV4X25vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgcGxhbmVDb252ZXhfcmVscG9zID0gbmV3IFZlYzMoKTtcbnZhciBwbGFuZUNvbnZleF9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2QgcGxhbmVDb252ZXhcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUExBTkUgfCBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVDb252ZXggPSBmdW5jdGlvbihcbiAgICBwbGFuZVNoYXBlLFxuICAgIGNvbnZleFNoYXBlLFxuICAgIHBsYW5lUG9zaXRpb24sXG4gICAgY29udmV4UG9zaXRpb24sXG4gICAgcGxhbmVRdWF0LFxuICAgIGNvbnZleFF1YXQsXG4gICAgcGxhbmVCb2R5LFxuICAgIGNvbnZleEJvZHksXG4gICAgc2ksXG4gICAgc2osXG4gICAganVzdFRlc3Rcbil7XG4gICAgLy8gU2ltcGx5IHJldHVybiB0aGUgcG9pbnRzIGJlaGluZCB0aGUgcGxhbmUuXG4gICAgdmFyIHdvcmxkVmVydGV4ID0gcGxhbmVDb252ZXhfdixcbiAgICAgICAgd29ybGROb3JtYWwgPSBwbGFuZUNvbnZleF9ub3JtYWw7XG4gICAgd29ybGROb3JtYWwuc2V0KDAsMCwxKTtcbiAgICBwbGFuZVF1YXQudm11bHQod29ybGROb3JtYWwsd29ybGROb3JtYWwpOyAvLyBUdXJuIG5vcm1hbCBhY2NvcmRpbmcgdG8gcGxhbmUgb3JpZW50YXRpb25cblxuICAgIHZhciBudW1Db250YWN0cyA9IDA7XG4gICAgdmFyIHJlbHBvcyA9IHBsYW5lQ29udmV4X3JlbHBvcztcbiAgICBmb3IodmFyIGkgPSAwOyBpICE9PSBjb252ZXhTaGFwZS52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG5cbiAgICAgICAgLy8gR2V0IHdvcmxkIGNvbnZleCB2ZXJ0ZXhcbiAgICAgICAgd29ybGRWZXJ0ZXguY29weShjb252ZXhTaGFwZS52ZXJ0aWNlc1tpXSk7XG4gICAgICAgIGNvbnZleFF1YXQudm11bHQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4KTtcbiAgICAgICAgY29udmV4UG9zaXRpb24udmFkZCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgpO1xuICAgICAgICB3b3JsZFZlcnRleC52c3ViKHBsYW5lUG9zaXRpb24sIHJlbHBvcyk7XG5cbiAgICAgICAgdmFyIGRvdCA9IHdvcmxkTm9ybWFsLmRvdChyZWxwb3MpO1xuICAgICAgICBpZihkb3QgPD0gMC4wKXtcbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksIGNvbnZleEJvZHksIHBsYW5lU2hhcGUsIGNvbnZleFNoYXBlLCBzaSwgc2opO1xuXG4gICAgICAgICAgICAvLyBHZXQgdmVydGV4IHBvc2l0aW9uIHByb2plY3RlZCBvbiBwbGFuZVxuICAgICAgICAgICAgdmFyIHByb2plY3RlZCA9IHBsYW5lQ29udmV4X3Byb2plY3RlZDtcbiAgICAgICAgICAgIHdvcmxkTm9ybWFsLm11bHQod29ybGROb3JtYWwuZG90KHJlbHBvcykscHJvamVjdGVkKTtcbiAgICAgICAgICAgIHdvcmxkVmVydGV4LnZzdWIocHJvamVjdGVkLCBwcm9qZWN0ZWQpO1xuICAgICAgICAgICAgcHJvamVjdGVkLnZzdWIocGxhbmVQb3NpdGlvbiwgci5yaSk7IC8vIEZyb20gcGxhbmUgdG8gdmVydGV4IHByb2plY3RlZCBvbiBwbGFuZVxuXG4gICAgICAgICAgICByLm5pLmNvcHkod29ybGROb3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbCBpcyB0aGUgcGxhbmUgbm9ybWFsIG91dCBmcm9tIHBsYW5lXG5cbiAgICAgICAgICAgIC8vIHJqIGlzIG5vdyBqdXN0IHRoZSB2ZWN0b3IgZnJvbSB0aGUgY29udmV4IGNlbnRlciB0byB0aGUgdmVydGV4XG4gICAgICAgICAgICB3b3JsZFZlcnRleC52c3ViKGNvbnZleFBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBpdCByZWxhdGl2ZSB0byB0aGUgYm9keVxuICAgICAgICAgICAgci5yaS52YWRkKHBsYW5lUG9zaXRpb24sIHIucmkpO1xuICAgICAgICAgICAgci5yaS52c3ViKHBsYW5lQm9keS5wb3NpdGlvbiwgci5yaSk7XG4gICAgICAgICAgICByLnJqLnZhZGQoY29udmV4UG9zaXRpb24sIHIucmopO1xuICAgICAgICAgICAgci5yai52c3ViKGNvbnZleEJvZHkucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgbnVtQ29udGFjdHMrKztcbiAgICAgICAgICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uICYmIG51bUNvbnRhY3RzKXtcbiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKTtcbiAgICB9XG59O1xuXG52YXIgY29udmV4Q29udmV4X3NlcEF4aXMgPSBuZXcgVmVjMygpO1xudmFyIGNvbnZleENvbnZleF9xID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbnZleENvbnZleFxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4Q29udmV4ID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmoscnNpLHJzaixqdXN0VGVzdCxmYWNlTGlzdEEsZmFjZUxpc3RCKXtcbiAgICB2YXIgc2VwQXhpcyA9IGNvbnZleENvbnZleF9zZXBBeGlzO1xuXG4gICAgaWYoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKHNpLmZpbmRTZXBhcmF0aW5nQXhpcyhzaix4aSxxaSx4aixxaixzZXBBeGlzLGZhY2VMaXN0QSxmYWNlTGlzdEIpKXtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICB2YXIgcSA9IGNvbnZleENvbnZleF9xO1xuICAgICAgICBzaS5jbGlwQWdhaW5zdEh1bGwoeGkscWksc2oseGoscWosc2VwQXhpcywtMTAwLDEwMCxyZXMpO1xuICAgICAgICB2YXIgbnVtQ29udGFjdHMgPSAwO1xuICAgICAgICBmb3IodmFyIGogPSAwOyBqICE9PSByZXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKSxcbiAgICAgICAgICAgICAgICByaSA9IHIucmksXG4gICAgICAgICAgICAgICAgcmogPSByLnJqO1xuICAgICAgICAgICAgc2VwQXhpcy5uZWdhdGUoci5uaSk7XG4gICAgICAgICAgICByZXNbal0ubm9ybWFsLm5lZ2F0ZShxKTtcbiAgICAgICAgICAgIHEubXVsdChyZXNbal0uZGVwdGgsIHEpO1xuICAgICAgICAgICAgcmVzW2pdLnBvaW50LnZhZGQocSwgcmkpO1xuICAgICAgICAgICAgcmouY29weShyZXNbal0ucG9pbnQpO1xuXG4gICAgICAgICAgICAvLyBDb250YWN0IHBvaW50cyBhcmUgaW4gd29ybGQgY29vcmRpbmF0ZXMuIFRyYW5zZm9ybSBiYWNrIHRvIHJlbGF0aXZlXG4gICAgICAgICAgICByaS52c3ViKHhpLHJpKTtcbiAgICAgICAgICAgIHJqLnZzdWIoeGoscmopO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xuICAgICAgICAgICAgcmkudmFkZCh4aSwgcmkpO1xuICAgICAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpO1xuICAgICAgICAgICAgcmoudmFkZCh4aiwgcmopO1xuICAgICAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopO1xuXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgbnVtQ29udGFjdHMrKztcbiAgICAgICAgICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiAmJiBudW1Db250YWN0cyl7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEBtZXRob2QgY29udmV4VHJpbWVzaFxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuLy8gTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04gfCBTaGFwZS50eXBlcy5UUklNRVNIXSA9XG4vLyBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4VHJpbWVzaCA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osZmFjZUxpc3RBLGZhY2VMaXN0Qil7XG4vLyAgICAgdmFyIHNlcEF4aXMgPSBjb252ZXhDb252ZXhfc2VwQXhpcztcblxuLy8gICAgIGlmKHhpLmRpc3RhbmNlVG8oeGopID4gc2kuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzai5ib3VuZGluZ1NwaGVyZVJhZGl1cyl7XG4vLyAgICAgICAgIHJldHVybjtcbi8vICAgICB9XG5cbi8vICAgICAvLyBDb25zdHJ1Y3QgYSB0ZW1wIGh1bGwgZm9yIGVhY2ggdHJpYW5nbGVcbi8vICAgICB2YXIgaHVsbEIgPSBuZXcgQ29udmV4UG9seWhlZHJvbigpO1xuXG4vLyAgICAgaHVsbEIuZmFjZXMgPSBbWzAsMSwyXV07XG4vLyAgICAgdmFyIHZhID0gbmV3IFZlYzMoKTtcbi8vICAgICB2YXIgdmIgPSBuZXcgVmVjMygpO1xuLy8gICAgIHZhciB2YyA9IG5ldyBWZWMzKCk7XG4vLyAgICAgaHVsbEIudmVydGljZXMgPSBbXG4vLyAgICAgICAgIHZhLFxuLy8gICAgICAgICB2Yixcbi8vICAgICAgICAgdmNcbi8vICAgICBdO1xuXG4vLyAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzai5pbmRpY2VzLmxlbmd0aCAvIDM7IGkrKykge1xuXG4vLyAgICAgICAgIHZhciB0cmlhbmdsZU5vcm1hbCA9IG5ldyBWZWMzKCk7XG4vLyAgICAgICAgIHNqLmdldE5vcm1hbChpLCB0cmlhbmdsZU5vcm1hbCk7XG4vLyAgICAgICAgIGh1bGxCLmZhY2VOb3JtYWxzID0gW3RyaWFuZ2xlTm9ybWFsXTtcblxuLy8gICAgICAgICBzai5nZXRUcmlhbmdsZVZlcnRpY2VzKGksIHZhLCB2YiwgdmMpO1xuXG4vLyAgICAgICAgIHZhciBkID0gc2kudGVzdFNlcEF4aXModHJpYW5nbGVOb3JtYWwsIGh1bGxCLCB4aSwgcWksIHhqLCBxaik7XG4vLyAgICAgICAgIGlmKCFkKXtcbi8vICAgICAgICAgICAgIHRyaWFuZ2xlTm9ybWFsLnNjYWxlKC0xLCB0cmlhbmdsZU5vcm1hbCk7XG4vLyAgICAgICAgICAgICBkID0gc2kudGVzdFNlcEF4aXModHJpYW5nbGVOb3JtYWwsIGh1bGxCLCB4aSwgcWksIHhqLCBxaik7XG5cbi8vICAgICAgICAgICAgIGlmKCFkKXtcbi8vICAgICAgICAgICAgICAgICBjb250aW51ZTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuXG4vLyAgICAgICAgIHZhciByZXMgPSBbXTtcbi8vICAgICAgICAgdmFyIHEgPSBjb252ZXhDb252ZXhfcTtcbi8vICAgICAgICAgc2kuY2xpcEFnYWluc3RIdWxsKHhpLHFpLGh1bGxCLHhqLHFqLHRyaWFuZ2xlTm9ybWFsLC0xMDAsMTAwLHJlcyk7XG4vLyAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogIT09IHJlcy5sZW5ndGg7IGorKyl7XG4vLyAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opLFxuLy8gICAgICAgICAgICAgICAgIHJpID0gci5yaSxcbi8vICAgICAgICAgICAgICAgICByaiA9IHIucmo7XG4vLyAgICAgICAgICAgICByLm5pLmNvcHkodHJpYW5nbGVOb3JtYWwpO1xuLy8gICAgICAgICAgICAgci5uaS5uZWdhdGUoci5uaSk7XG4vLyAgICAgICAgICAgICByZXNbal0ubm9ybWFsLm5lZ2F0ZShxKTtcbi8vICAgICAgICAgICAgIHEubXVsdChyZXNbal0uZGVwdGgsIHEpO1xuLy8gICAgICAgICAgICAgcmVzW2pdLnBvaW50LnZhZGQocSwgcmkpO1xuLy8gICAgICAgICAgICAgcmouY29weShyZXNbal0ucG9pbnQpO1xuXG4vLyAgICAgICAgICAgICAvLyBDb250YWN0IHBvaW50cyBhcmUgaW4gd29ybGQgY29vcmRpbmF0ZXMuIFRyYW5zZm9ybSBiYWNrIHRvIHJlbGF0aXZlXG4vLyAgICAgICAgICAgICByaS52c3ViKHhpLHJpKTtcbi8vICAgICAgICAgICAgIHJqLnZzdWIoeGoscmopO1xuXG4vLyAgICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xuLy8gICAgICAgICAgICAgcmkudmFkZCh4aSwgcmkpO1xuLy8gICAgICAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpO1xuLy8gICAgICAgICAgICAgcmoudmFkZCh4aiwgcmopO1xuLy8gICAgICAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopO1xuXG4vLyAgICAgICAgICAgICByZXN1bHQucHVzaChyKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vIH07XG5cbnZhciBwYXJ0aWNsZVBsYW5lX25vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgcGFydGljbGVQbGFuZV9yZWxwb3MgPSBuZXcgVmVjMygpO1xudmFyIHBhcnRpY2xlUGxhbmVfcHJvamVjdGVkID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHBhcnRpY2xlUGxhbmVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHJlc3VsdFxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLlBBUlRJQ0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVQYXJ0aWNsZSA9IGZ1bmN0aW9uKHNqLHNpLHhqLHhpLHFqLHFpLGJqLGJpLHJzaSxyc2osanVzdFRlc3Qpe1xuICAgIHZhciBub3JtYWwgPSBwYXJ0aWNsZVBsYW5lX25vcm1hbDtcbiAgICBub3JtYWwuc2V0KDAsMCwxKTtcbiAgICBiai5xdWF0ZXJuaW9uLnZtdWx0KG5vcm1hbCxub3JtYWwpOyAvLyBUdXJuIG5vcm1hbCBhY2NvcmRpbmcgdG8gcGxhbmUgb3JpZW50YXRpb25cbiAgICB2YXIgcmVscG9zID0gcGFydGljbGVQbGFuZV9yZWxwb3M7XG4gICAgeGkudnN1Yihiai5wb3NpdGlvbixyZWxwb3MpO1xuICAgIHZhciBkb3QgPSBub3JtYWwuZG90KHJlbHBvcyk7XG4gICAgaWYoZG90IDw9IDAuMCl7XG5cbiAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xuICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWwgaXMgdGhlIHBsYW5lIG5vcm1hbFxuICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTtcbiAgICAgICAgci5yaS5zZXQoMCwwLDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGVcblxuICAgICAgICAvLyBHZXQgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXG4gICAgICAgIHZhciBwcm9qZWN0ZWQgPSBwYXJ0aWNsZVBsYW5lX3Byb2plY3RlZDtcbiAgICAgICAgbm9ybWFsLm11bHQobm9ybWFsLmRvdCh4aSkscHJvamVjdGVkKTtcbiAgICAgICAgeGkudnN1Yihwcm9qZWN0ZWQscHJvamVjdGVkKTtcbiAgICAgICAgLy9wcm9qZWN0ZWQudmFkZChiai5wb3NpdGlvbixwcm9qZWN0ZWQpO1xuXG4gICAgICAgIC8vIHJqIGlzIG5vdyB0aGUgcHJvamVjdGVkIHdvcmxkIHBvc2l0aW9uIG1pbnVzIHBsYW5lIHBvc2l0aW9uXG4gICAgICAgIHIucmouY29weShwcm9qZWN0ZWQpO1xuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgfVxufTtcblxudmFyIHBhcnRpY2xlU3BoZXJlX25vcm1hbCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBwYXJ0aWNsZVNwaGVyZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuU1BIRVJFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlUGFydGljbGUgPSBmdW5jdGlvbihzaixzaSx4aix4aSxxaixxaSxiaixiaSxyc2kscnNqLGp1c3RUZXN0KXtcbiAgICAvLyBUaGUgbm9ybWFsIGlzIHRoZSB1bml0IHZlY3RvciBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gcGFydGljbGUgY2VudGVyXG4gICAgdmFyIG5vcm1hbCA9IHBhcnRpY2xlU3BoZXJlX25vcm1hbDtcbiAgICBub3JtYWwuc2V0KDAsMCwxKTtcbiAgICB4aS52c3ViKHhqLG5vcm1hbCk7XG4gICAgdmFyIGxlbmd0aFNxdWFyZWQgPSBub3JtYWwubm9ybTIoKTtcblxuICAgIGlmKGxlbmd0aFNxdWFyZWQgPD0gc2oucmFkaXVzICogc2oucmFkaXVzKXtcbiAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcbiAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICByLnJqLmNvcHkobm9ybWFsKTtcbiAgICAgICAgci5yai5tdWx0KHNqLnJhZGl1cyxyLnJqKTtcbiAgICAgICAgci5uaS5jb3B5KG5vcm1hbCk7IC8vIENvbnRhY3Qgbm9ybWFsXG4gICAgICAgIHIubmkubmVnYXRlKHIubmkpO1xuICAgICAgICByLnJpLnNldCgwLDAsMCk7IC8vIENlbnRlciBvZiBwYXJ0aWNsZVxuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgfVxufTtcblxuLy8gV0lQXG52YXIgY3FqID0gbmV3IFF1YXRlcm5pb24oKTtcbnZhciBjb252ZXhQYXJ0aWNsZV9sb2NhbCA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4UGFydGljbGVfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBjb252ZXhQYXJ0aWNsZV9wZW5ldHJhdGVkRmFjZU5vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4UGFydGljbGVfd29ybGRQZW5ldHJhdGlvblZlYyA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjb252ZXhQYXJ0aWNsZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleFBhcnRpY2xlID0gZnVuY3Rpb24oc2osc2kseGoseGkscWoscWksYmosYmkscnNpLHJzaixqdXN0VGVzdCl7XG4gICAgdmFyIHBlbmV0cmF0ZWRGYWNlSW5kZXggPSAtMTtcbiAgICB2YXIgcGVuZXRyYXRlZEZhY2VOb3JtYWwgPSBjb252ZXhQYXJ0aWNsZV9wZW5ldHJhdGVkRmFjZU5vcm1hbDtcbiAgICB2YXIgd29ybGRQZW5ldHJhdGlvblZlYyA9IGNvbnZleFBhcnRpY2xlX3dvcmxkUGVuZXRyYXRpb25WZWM7XG4gICAgdmFyIG1pblBlbmV0cmF0aW9uID0gbnVsbDtcbiAgICB2YXIgbnVtRGV0ZWN0ZWRGYWNlcyA9IDA7XG5cbiAgICAvLyBDb252ZXJ0IHBhcnRpY2xlIHBvc2l0aW9uIHhpIHRvIGxvY2FsIGNvb3JkcyBpbiB0aGUgY29udmV4XG4gICAgdmFyIGxvY2FsID0gY29udmV4UGFydGljbGVfbG9jYWw7XG4gICAgbG9jYWwuY29weSh4aSk7XG4gICAgbG9jYWwudnN1Yih4aixsb2NhbCk7IC8vIENvbnZlcnQgcG9zaXRpb24gdG8gcmVsYXRpdmUgdGhlIGNvbnZleCBvcmlnaW5cbiAgICBxai5jb25qdWdhdGUoY3FqKTtcbiAgICBjcWoudm11bHQobG9jYWwsbG9jYWwpO1xuXG4gICAgaWYoc2oucG9pbnRJc0luc2lkZShsb2NhbCkpe1xuXG4gICAgICAgIGlmKHNqLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBzai5jb21wdXRlV29ybGRWZXJ0aWNlcyh4aixxaik7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2oud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIHNqLmNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzKHFqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBlYWNoIHdvcmxkIHBvbHlnb24gaW4gdGhlIHBvbHloZWRyYVxuICAgICAgICBmb3IodmFyIGk9MCxuZmFjZXM9c2ouZmFjZXMubGVuZ3RoOyBpIT09bmZhY2VzOyBpKyspe1xuXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3Qgd29ybGQgZmFjZSB2ZXJ0aWNlc1xuICAgICAgICAgICAgdmFyIHZlcnRzID0gWyBzai53b3JsZFZlcnRpY2VzWyBzai5mYWNlc1tpXVswXSBdIF07XG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gc2oud29ybGRGYWNlTm9ybWFsc1tpXTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaG93IG11Y2ggdGhlIHBhcnRpY2xlIHBlbmV0cmF0ZXMgdGhlIHBvbHlnb24gcGxhbmUuXG4gICAgICAgICAgICB4aS52c3ViKHZlcnRzWzBdLGNvbnZleFBhcnRpY2xlX3ZlcnRleFRvUGFydGljbGUpO1xuICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uID0gLW5vcm1hbC5kb3QoY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSk7XG4gICAgICAgICAgICBpZihtaW5QZW5ldHJhdGlvbj09PW51bGwgfHwgTWF0aC5hYnMocGVuZXRyYXRpb24pPE1hdGguYWJzKG1pblBlbmV0cmF0aW9uKSl7XG5cbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1pblBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb247XG4gICAgICAgICAgICAgICAgcGVuZXRyYXRlZEZhY2VJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwuY29weShub3JtYWwpO1xuICAgICAgICAgICAgICAgIG51bURldGVjdGVkRmFjZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHBlbmV0cmF0ZWRGYWNlSW5kZXghPT0tMSl7XG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWN0XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xuICAgICAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwubXVsdChtaW5QZW5ldHJhdGlvbiwgd29ybGRQZW5ldHJhdGlvblZlYyk7XG5cbiAgICAgICAgICAgIC8vIHJqIGlzIHRoZSBwYXJ0aWNsZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIGZhY2VcbiAgICAgICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudmFkZCh4aSx3b3JsZFBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudnN1Yih4aix3b3JsZFBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgIHIucmouY29weSh3b3JsZFBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgIC8vdmFyIHByb2plY3RlZFRvRmFjZSA9IHhpLnZzdWIoeGopLnZhZGQod29ybGRQZW5ldHJhdGlvblZlYyk7XG4gICAgICAgICAgICAvL3Byb2plY3RlZFRvRmFjZS5jb3B5KHIucmopO1xuXG4gICAgICAgICAgICAvL3FqLnZtdWx0KHIucmosci5yaik7XG4gICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5uZWdhdGUoIHIubmkgKTsgLy8gQ29udGFjdCBub3JtYWxcbiAgICAgICAgICAgIHIucmkuc2V0KDAsMCwwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlXG5cbiAgICAgICAgICAgIHZhciByaSA9IHIucmksXG4gICAgICAgICAgICAgICAgcmogPSByLnJqO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xuICAgICAgICAgICAgcmkudmFkZCh4aSwgcmkpO1xuICAgICAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpO1xuICAgICAgICAgICAgcmoudmFkZCh4aiwgcmopO1xuICAgICAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopO1xuXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUG9pbnQgZm91bmQgaW5zaWRlIGNvbnZleCwgYnV0IGRpZCBub3QgZmluZCBwZW5ldHJhdGluZyBmYWNlIVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmJveEhlaWdodGZpZWxkID0gZnVuY3Rpb24gKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osanVzdFRlc3Qpe1xuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNpLm1hdGVyaWFsO1xuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIHJldHVybiB0aGlzLmNvbnZleEhlaWdodGZpZWxkKHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixzaix4aSx4aixxaSxxaixiaSxiaixzaSxzaixqdXN0VGVzdCk7XG59O1xuXG52YXIgY29udmV4SGVpZ2h0ZmllbGRfdG1wMSA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4SGVpZ2h0ZmllbGRfdG1wMiA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4SGVpZ2h0ZmllbGRfZmFjZUxpc3QgPSBbMF07XG5cbi8qKlxuICogQG1ldGhvZCBjb252ZXhIZWlnaHRmaWVsZFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxEXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4SGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiAoXG4gICAgY29udmV4U2hhcGUsXG4gICAgaGZTaGFwZSxcbiAgICBjb252ZXhQb3MsXG4gICAgaGZQb3MsXG4gICAgY29udmV4UXVhdCxcbiAgICBoZlF1YXQsXG4gICAgY29udmV4Qm9keSxcbiAgICBoZkJvZHksXG4gICAgcnNpLFxuICAgIHJzaixcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuZGF0YSxcbiAgICAgICAgdyA9IGhmU2hhcGUuZWxlbWVudFNpemUsXG4gICAgICAgIHJhZGl1cyA9IGNvbnZleFNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzLFxuICAgICAgICB3b3JsZFBpbGxhck9mZnNldCA9IGNvbnZleEhlaWdodGZpZWxkX3RtcDIsXG4gICAgICAgIGZhY2VMaXN0ID0gY29udmV4SGVpZ2h0ZmllbGRfZmFjZUxpc3Q7XG5cbiAgICAvLyBHZXQgc3BoZXJlIHBvc2l0aW9uIHRvIGhlaWdodGZpZWxkIGxvY2FsIVxuICAgIHZhciBsb2NhbENvbnZleFBvcyA9IGNvbnZleEhlaWdodGZpZWxkX3RtcDE7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKGhmUG9zLCBoZlF1YXQsIGNvbnZleFBvcywgbG9jYWxDb252ZXhQb3MpO1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIGlNaW5YID0gTWF0aC5mbG9vcigobG9jYWxDb252ZXhQb3MueCAtIHJhZGl1cykgLyB3KSAtIDEsXG4gICAgICAgIGlNYXhYID0gTWF0aC5jZWlsKChsb2NhbENvbnZleFBvcy54ICsgcmFkaXVzKSAvIHcpICsgMSxcbiAgICAgICAgaU1pblkgPSBNYXRoLmZsb29yKChsb2NhbENvbnZleFBvcy55IC0gcmFkaXVzKSAvIHcpIC0gMSxcbiAgICAgICAgaU1heFkgPSBNYXRoLmNlaWwoKGxvY2FsQ29udmV4UG9zLnkgKyByYWRpdXMpIC8gdykgKyAxO1xuXG4gICAgLy8gQmFpbCBvdXQgaWYgd2UgYXJlIG91dCBvZiB0aGUgdGVycmFpblxuICAgIGlmKGlNYXhYIDwgMCB8fCBpTWF4WSA8IDAgfHwgaU1pblggPiBkYXRhLmxlbmd0aCB8fCBpTWluWSA+IGRhdGFbMF0ubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzXG4gICAgaWYoaU1pblggPCAwKXsgaU1pblggPSAwOyB9XG4gICAgaWYoaU1heFggPCAwKXsgaU1heFggPSAwOyB9XG4gICAgaWYoaU1pblkgPCAwKXsgaU1pblkgPSAwOyB9XG4gICAgaWYoaU1heFkgPCAwKXsgaU1heFkgPSAwOyB9XG4gICAgaWYoaU1pblggPj0gZGF0YS5sZW5ndGgpeyBpTWluWCA9IGRhdGEubGVuZ3RoIC0gMTsgfVxuICAgIGlmKGlNYXhYID49IGRhdGEubGVuZ3RoKXsgaU1heFggPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICBpZihpTWF4WSA+PSBkYXRhWzBdLmxlbmd0aCl7IGlNYXhZID0gZGF0YVswXS5sZW5ndGggLSAxOyB9XG4gICAgaWYoaU1pblkgPj0gZGF0YVswXS5sZW5ndGgpeyBpTWluWSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsgfVxuXG4gICAgdmFyIG1pbk1heCA9IFtdO1xuICAgIGhmU2hhcGUuZ2V0UmVjdE1pbk1heChpTWluWCwgaU1pblksIGlNYXhYLCBpTWF4WSwgbWluTWF4KTtcbiAgICB2YXIgbWluID0gbWluTWF4WzBdO1xuICAgIHZhciBtYXggPSBtaW5NYXhbMV07XG5cbiAgICAvLyBCYWlsIG91dCBpZiB3ZSdyZSBjYW50IHRvdWNoIHRoZSBib3VuZGluZyBoZWlnaHQgYm94XG4gICAgaWYobG9jYWxDb252ZXhQb3MueiAtIHJhZGl1cyA+IG1heCB8fCBsb2NhbENvbnZleFBvcy56ICsgcmFkaXVzIDwgbWluKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvcih2YXIgaSA9IGlNaW5YOyBpIDwgaU1heFg7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaiA9IGlNaW5ZOyBqIDwgaU1heFk7IGorKyl7XG5cbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gTG93ZXIgdHJpYW5nbGVcbiAgICAgICAgICAgIGhmU2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgZmFsc2UpO1xuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XG4gICAgICAgICAgICBpZiAoY29udmV4UG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBjb252ZXhTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdGluZyA9IHRoaXMuY29udmV4Q29udmV4KGNvbnZleFNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgY29udmV4UG9zLCB3b3JsZFBpbGxhck9mZnNldCwgY29udmV4UXVhdCwgaGZRdWF0LCBjb252ZXhCb2R5LCBoZkJvZHksIG51bGwsIG51bGwsIGp1c3RUZXN0LCBmYWNlTGlzdCwgbnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0ICYmIGludGVyc2VjdGluZyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwcGVyIHRyaWFuZ2xlXG4gICAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpO1xuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XG4gICAgICAgICAgICBpZiAoY29udmV4UG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBjb252ZXhTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdGluZyA9IHRoaXMuY29udmV4Q29udmV4KGNvbnZleFNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgY29udmV4UG9zLCB3b3JsZFBpbGxhck9mZnNldCwgY29udmV4UXVhdCwgaGZRdWF0LCBjb252ZXhCb2R5LCBoZkJvZHksIG51bGwsIG51bGwsIGp1c3RUZXN0LCBmYWNlTGlzdCwgbnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0ICYmIGludGVyc2VjdGluZyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgc3BoZXJlSGVpZ2h0ZmllbGRfdG1wMSA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlSGVpZ2h0ZmllbGRfdG1wMiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBzcGhlcmVIZWlnaHRmaWVsZFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTERdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uIChcbiAgICBzcGhlcmVTaGFwZSxcbiAgICBoZlNoYXBlLFxuICAgIHNwaGVyZVBvcyxcbiAgICBoZlBvcyxcbiAgICBzcGhlcmVRdWF0LFxuICAgIGhmUXVhdCxcbiAgICBzcGhlcmVCb2R5LFxuICAgIGhmQm9keSxcbiAgICByc2ksXG4gICAgcnNqLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciBkYXRhID0gaGZTaGFwZS5kYXRhLFxuICAgICAgICByYWRpdXMgPSBzcGhlcmVTaGFwZS5yYWRpdXMsXG4gICAgICAgIHcgPSBoZlNoYXBlLmVsZW1lbnRTaXplLFxuICAgICAgICB3b3JsZFBpbGxhck9mZnNldCA9IHNwaGVyZUhlaWdodGZpZWxkX3RtcDI7XG5cbiAgICAvLyBHZXQgc3BoZXJlIHBvc2l0aW9uIHRvIGhlaWdodGZpZWxkIGxvY2FsIVxuICAgIHZhciBsb2NhbFNwaGVyZVBvcyA9IHNwaGVyZUhlaWdodGZpZWxkX3RtcDE7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKGhmUG9zLCBoZlF1YXQsIHNwaGVyZVBvcywgbG9jYWxTcGhlcmVQb3MpO1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIGlNaW5YID0gTWF0aC5mbG9vcigobG9jYWxTcGhlcmVQb3MueCAtIHJhZGl1cykgLyB3KSAtIDEsXG4gICAgICAgIGlNYXhYID0gTWF0aC5jZWlsKChsb2NhbFNwaGVyZVBvcy54ICsgcmFkaXVzKSAvIHcpICsgMSxcbiAgICAgICAgaU1pblkgPSBNYXRoLmZsb29yKChsb2NhbFNwaGVyZVBvcy55IC0gcmFkaXVzKSAvIHcpIC0gMSxcbiAgICAgICAgaU1heFkgPSBNYXRoLmNlaWwoKGxvY2FsU3BoZXJlUG9zLnkgKyByYWRpdXMpIC8gdykgKyAxO1xuXG4gICAgLy8gQmFpbCBvdXQgaWYgd2UgYXJlIG91dCBvZiB0aGUgdGVycmFpblxuICAgIGlmKGlNYXhYIDwgMCB8fCBpTWF4WSA8IDAgfHwgaU1pblggPiBkYXRhLmxlbmd0aCB8fCBpTWF4WSA+IGRhdGFbMF0ubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzXG4gICAgaWYoaU1pblggPCAwKXsgaU1pblggPSAwOyB9XG4gICAgaWYoaU1heFggPCAwKXsgaU1heFggPSAwOyB9XG4gICAgaWYoaU1pblkgPCAwKXsgaU1pblkgPSAwOyB9XG4gICAgaWYoaU1heFkgPCAwKXsgaU1heFkgPSAwOyB9XG4gICAgaWYoaU1pblggPj0gZGF0YS5sZW5ndGgpeyBpTWluWCA9IGRhdGEubGVuZ3RoIC0gMTsgfVxuICAgIGlmKGlNYXhYID49IGRhdGEubGVuZ3RoKXsgaU1heFggPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICBpZihpTWF4WSA+PSBkYXRhWzBdLmxlbmd0aCl7IGlNYXhZID0gZGF0YVswXS5sZW5ndGggLSAxOyB9XG4gICAgaWYoaU1pblkgPj0gZGF0YVswXS5sZW5ndGgpeyBpTWluWSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsgfVxuXG4gICAgdmFyIG1pbk1heCA9IFtdO1xuICAgIGhmU2hhcGUuZ2V0UmVjdE1pbk1heChpTWluWCwgaU1pblksIGlNYXhYLCBpTWF4WSwgbWluTWF4KTtcbiAgICB2YXIgbWluID0gbWluTWF4WzBdO1xuICAgIHZhciBtYXggPSBtaW5NYXhbMV07XG5cbiAgICAvLyBCYWlsIG91dCBpZiB3ZSdyZSBjYW50IHRvdWNoIHRoZSBib3VuZGluZyBoZWlnaHQgYm94XG4gICAgaWYobG9jYWxTcGhlcmVQb3MueiAtIHJhZGl1cyA+IG1heCB8fCBsb2NhbFNwaGVyZVBvcy56ICsgcmFkaXVzIDwgbWluKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcbiAgICBmb3IodmFyIGkgPSBpTWluWDsgaSA8IGlNYXhYOyBpKyspe1xuICAgICAgICBmb3IodmFyIGogPSBpTWluWTsgaiA8IGlNYXhZOyBqKyspe1xuXG4gICAgICAgICAgICB2YXIgbnVtQ29udGFjdHNCZWZvcmUgPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIExvd2VyIHRyaWFuZ2xlXG4gICAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHNwaGVyZVBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc3BoZXJlU2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RpbmcgPSB0aGlzLnNwaGVyZUNvbnZleChzcGhlcmVTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIHNwaGVyZVBvcywgd29ybGRQaWxsYXJPZmZzZXQsIHNwaGVyZVF1YXQsIGhmUXVhdCwgc3BoZXJlQm9keSwgaGZCb2R5LCBzcGhlcmVTaGFwZSwgaGZTaGFwZSwganVzdFRlc3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCAmJiBpbnRlcnNlY3Rpbmcpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcHBlciB0cmlhbmdsZVxuICAgICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCB0cnVlKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHNwaGVyZVBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc3BoZXJlU2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RpbmcgPSB0aGlzLnNwaGVyZUNvbnZleChzcGhlcmVTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIHNwaGVyZVBvcywgd29ybGRQaWxsYXJPZmZzZXQsIHNwaGVyZVF1YXQsIGhmUXVhdCwgc3BoZXJlQm9keSwgaGZCb2R5LCBzcGhlcmVTaGFwZSwgaGZTaGFwZSwganVzdFRlc3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCAmJiBpbnRlcnNlY3Rpbmcpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbnVtQ29udGFjdHMgPSByZXN1bHQubGVuZ3RoIC0gbnVtQ29udGFjdHNCZWZvcmU7XG5cbiAgICAgICAgICAgIGlmKG51bUNvbnRhY3RzID4gMil7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIC8vIFNraXAgYWxsIGJ1dCAxXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG51bUNvbnRhY3RzIC0gMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIvKiBnbG9iYWwgcGVyZm9ybWFuY2UgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXb3JsZDtcblxudmFyIFNoYXBlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBHU1NvbHZlciA9IHJlcXVpcmUoJy4uL3NvbHZlci9HU1NvbHZlcicpO1xudmFyIENvbnRhY3RFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcbnZhciBOYXJyb3dwaGFzZSA9IHJlcXVpcmUoJy4vTmFycm93cGhhc2UnKTtcbnZhciBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4uL3V0aWxzL0V2ZW50VGFyZ2V0Jyk7XG52YXIgQXJyYXlDb2xsaXNpb25NYXRyaXggPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXgnKTtcbnZhciBPdmVybGFwS2VlcGVyID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL092ZXJsYXBLZWVwZXInKTtcbnZhciBNYXRlcmlhbCA9IHJlcXVpcmUoJy4uL21hdGVyaWFsL01hdGVyaWFsJyk7XG52YXIgQ29udGFjdE1hdGVyaWFsID0gcmVxdWlyZSgnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJyk7XG52YXIgQm9keSA9IHJlcXVpcmUoJy4uL29iamVjdHMvQm9keScpO1xudmFyIFR1cGxlRGljdGlvbmFyeSA9IHJlcXVpcmUoJy4uL3V0aWxzL1R1cGxlRGljdGlvbmFyeScpO1xudmFyIFJheWNhc3RSZXN1bHQgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xudmFyIEFBQkIgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQUFCQicpO1xudmFyIFJheSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9SYXknKTtcbnZhciBOYWl2ZUJyb2FkcGhhc2UgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyk7XG5cbi8qKlxuICogVGhlIHBoeXNpY3Mgd29ybGRcbiAqIEBjbGFzcyBXb3JsZFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5ncmF2aXR5XVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbGxvd1NsZWVwXVxuICogQHBhcmFtIHtCcm9hZHBoYXNlfSBbb3B0aW9ucy5icm9hZHBoYXNlXVxuICogQHBhcmFtIHtTb2x2ZXJ9IFtvcHRpb25zLnNvbHZlcl1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucXVhdE5vcm1hbGl6ZUZhc3RdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucXVhdE5vcm1hbGl6ZVNraXBdXG4gKi9cbmZ1bmN0aW9uIFdvcmxkKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIEV2ZW50VGFyZ2V0LmFwcGx5KHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudGx5IC8gbGFzdCB1c2VkIHRpbWVzdGVwLiBJcyBzZXQgdG8gLTEgaWYgbm90IGF2YWlsYWJsZS4gVGhpcyB2YWx1ZSBpcyB1cGRhdGVkIGJlZm9yZSBlYWNoIGludGVybmFsIHN0ZXAsIHdoaWNoIG1lYW5zIHRoYXQgaXQgaXMgXCJmcmVzaFwiIGluc2lkZSBldmVudCBjYWxsYmFja3MuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGR0XG4gICAgICovXG4gICAgdGhpcy5kdCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYm9kaWVzIGdvIHRvIHNsZWVwIHdoZW4gdGhleSd2ZSBiZWVuIGluYWN0aXZlXG4gICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHRoaXMuYWxsb3dTbGVlcCA9ICEhb3B0aW9ucy5hbGxvd1NsZWVwO1xuXG4gICAgLyoqXG4gICAgICogQWxsIHRoZSBjdXJyZW50IGNvbnRhY3RzIChpbnN0YW5jZXMgb2YgQ29udGFjdEVxdWF0aW9uKSBpbiB0aGUgd29ybGQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdHMgPSBbXTtcbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBIb3cgb2Z0ZW4gdG8gbm9ybWFsaXplIHF1YXRlcm5pb25zLiBTZXQgdG8gMCBmb3IgZXZlcnkgc3RlcCwgMSBmb3IgZXZlcnkgc2Vjb25kIGV0Yy4uIEEgbGFyZ2VyIHZhbHVlIGluY3JlYXNlcyBwZXJmb3JtYW5jZS4gSWYgYm9kaWVzIHRlbmQgdG8gZXhwbG9kZSwgc2V0IHRvIGEgc21hbGxlciB2YWx1ZSAoemVybyB0byBiZSBzdXJlIG5vdGhpbmcgY2FuIGdvIHdyb25nKS5cbiAgICAgKiBAcHJvcGVydHkgcXVhdE5vcm1hbGl6ZVNraXBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnF1YXROb3JtYWxpemVTa2lwID0gb3B0aW9ucy5xdWF0Tm9ybWFsaXplU2tpcCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5xdWF0Tm9ybWFsaXplU2tpcCA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byB1c2UgZmFzdCBxdWF0ZXJuaW9uIG5vcm1hbGl6YXRpb24uIEl0IGlzIG9mdGVuIGVub3VnaCBhY2N1cmF0ZSB0byB1c2UuIElmIGJvZGllcyB0ZW5kIHRvIGV4cGxvZGUsIHNldCB0byBmYWxzZS5cbiAgICAgKiBAcHJvcGVydHkgcXVhdE5vcm1hbGl6ZUZhc3RcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFF1YXRlcm5pb24ubm9ybWFsaXplRmFzdFxuICAgICAqIEBzZWUgUXVhdGVybmlvbi5ub3JtYWxpemVcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHRoaXMucXVhdE5vcm1hbGl6ZUZhc3QgPSBvcHRpb25zLnF1YXROb3JtYWxpemVGYXN0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnF1YXROb3JtYWxpemVGYXN0IDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2FsbC1jbG9jayB0aW1lIHNpbmNlIHNpbXVsYXRpb24gc3RhcnRcbiAgICAgKiBAcHJvcGVydHkgdGltZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aW1lID0gMC4wO1xuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHRpbWVzdGVwcyB0YWtlbiBzaW5jZSBzdGFydFxuICAgICAqIEBwcm9wZXJ0eSBzdGVwbnVtYmVyXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0ZXBudW1iZXIgPSAwO1xuXG4gICAgLy8vIERlZmF1bHQgYW5kIGxhc3QgdGltZXN0ZXAgc2l6ZXNcbiAgICB0aGlzLmRlZmF1bHRfZHQgPSAxLzYwO1xuXG4gICAgdGhpcy5uZXh0SWQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5XG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5ncmF2aXR5ID0gbmV3IFZlYzMoKTtcbiAgICBpZihvcHRpb25zLmdyYXZpdHkpe1xuICAgICAgICB0aGlzLmdyYXZpdHkuY29weShvcHRpb25zLmdyYXZpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBicm9hZHBoYXNlIGFsZ29yaXRobSB0byB1c2UuIERlZmF1bHQgaXMgTmFpdmVCcm9hZHBoYXNlXG4gICAgICogQHByb3BlcnR5IGJyb2FkcGhhc2VcbiAgICAgKiBAdHlwZSB7QnJvYWRwaGFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJyb2FkcGhhc2UgPSBvcHRpb25zLmJyb2FkcGhhc2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYnJvYWRwaGFzZSA6IG5ldyBOYWl2ZUJyb2FkcGhhc2UoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBib2RpZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ib2RpZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzb2x2ZXIgYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdCBpcyBHU1NvbHZlclxuICAgICAqIEBwcm9wZXJ0eSBzb2x2ZXJcbiAgICAgKiBAdHlwZSB7U29sdmVyfVxuICAgICAqL1xuICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc29sdmVyIDogbmV3IEdTU29sdmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG5hcnJvd3BoYXNlXG4gICAgICogQHR5cGUge05hcnJvd3BoYXNlfVxuICAgICAqL1xuICAgIHRoaXMubmFycm93cGhhc2UgPSBuZXcgTmFycm93cGhhc2UodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Q29sbGlzaW9uTWF0cml4fSBjb2xsaXNpb25NYXRyaXhcblx0ICogQHR5cGUge0FycmF5Q29sbGlzaW9uTWF0cml4fVxuXHQgKi9cblx0dGhpcy5jb2xsaXNpb25NYXRyaXggPSBuZXcgQXJyYXlDb2xsaXNpb25NYXRyaXgoKTtcblxuICAgIC8qKlxuICAgICAqIENvbGxpc2lvbk1hdHJpeCBmcm9tIHRoZSBwcmV2aW91cyBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXlDb2xsaXNpb25NYXRyaXh9IGNvbGxpc2lvbk1hdHJpeFByZXZpb3VzXG5cdCAqIEB0eXBlIHtBcnJheUNvbGxpc2lvbk1hdHJpeH1cblx0ICovXG5cdHRoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXMgPSBuZXcgQXJyYXlDb2xsaXNpb25NYXRyaXgoKTtcblxuICAgIHRoaXMuYm9keU92ZXJsYXBLZWVwZXIgPSBuZXcgT3ZlcmxhcEtlZXBlcigpO1xuICAgIHRoaXMuc2hhcGVPdmVybGFwS2VlcGVyID0gbmV3IE92ZXJsYXBLZWVwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEFsbCBhZGRlZCBtYXRlcmlhbHNcbiAgICAgKiBAcHJvcGVydHkgbWF0ZXJpYWxzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubWF0ZXJpYWxzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgY29udGFjdG1hdGVyaWFsc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RtYXRlcmlhbHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gbG9vayB1cCBhIENvbnRhY3RNYXRlcmlhbCBnaXZlbiB0d28gaW5zdGFuY2VzIG9mIE1hdGVyaWFsLlxuICAgICAqIEBwcm9wZXJ0eSB7VHVwbGVEaWN0aW9uYXJ5fSBjb250YWN0TWF0ZXJpYWxUYWJsZVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdE1hdGVyaWFsVGFibGUgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XG5cbiAgICB0aGlzLmRlZmF1bHRNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbChcImRlZmF1bHRcIik7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbnRhY3QgbWF0ZXJpYWwgaXMgdXNlZCBpZiBubyBzdWl0YWJsZSBjb250YWN0bWF0ZXJpYWwgaXMgZm91bmQgZm9yIGEgY29udGFjdC5cbiAgICAgKiBAcHJvcGVydHkgZGVmYXVsdENvbnRhY3RNYXRlcmlhbFxuICAgICAqIEB0eXBlIHtDb250YWN0TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsID0gbmV3IENvbnRhY3RNYXRlcmlhbCh0aGlzLmRlZmF1bHRNYXRlcmlhbCwgdGhpcy5kZWZhdWx0TWF0ZXJpYWwsIHsgZnJpY3Rpb246IDAuMywgcmVzdGl0dXRpb246IDAuMCB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBkb1Byb2ZpbGluZ1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZG9Qcm9maWxpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBwcm9maWxlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnByb2ZpbGUgPSB7XG4gICAgICAgIHNvbHZlOjAsXG4gICAgICAgIG1ha2VDb250YWN0Q29uc3RyYWludHM6MCxcbiAgICAgICAgYnJvYWRwaGFzZTowLFxuICAgICAgICBpbnRlZ3JhdGU6MCxcbiAgICAgICAgbmFycm93cGhhc2U6MCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGltZSBhY2N1bXVsYXRvciBmb3IgaW50ZXJwb2xhdGlvbi4gU2VlIGh0dHA6Ly9nYWZmZXJvbmdhbWVzLmNvbS9nYW1lLXBoeXNpY3MvZml4LXlvdXItdGltZXN0ZXAvXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGFjY3VtdWxhdG9yXG4gICAgICovXG4gICAgdGhpcy5hY2N1bXVsYXRvciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgc3Vic3lzdGVtc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnN1YnN5c3RlbXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkQm9keVxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keSBUaGUgYm9keSB0aGF0IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKi9cbiAgICB0aGlzLmFkZEJvZHlFdmVudCA9IHtcbiAgICAgICAgdHlwZTpcImFkZEJvZHlcIixcbiAgICAgICAgYm9keSA6IG51bGxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2hlZCBhZnRlciBhIGJvZHkgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgcmVtb3ZlQm9keVxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keSBUaGUgYm9keSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgd29ybGQuXG4gICAgICovXG4gICAgdGhpcy5yZW1vdmVCb2R5RXZlbnQgPSB7XG4gICAgICAgIHR5cGU6XCJyZW1vdmVCb2R5XCIsXG4gICAgICAgIGJvZHkgOiBudWxsXG4gICAgfTtcblxuICAgIHRoaXMuaWRUb0JvZHlNYXAgPSB7fTtcblxuICAgIHRoaXMuYnJvYWRwaGFzZS5zZXRXb3JsZCh0aGlzKTtcbn1cbldvcmxkLnByb3RvdHlwZSA9IG5ldyBFdmVudFRhcmdldCgpO1xuXG4vLyBUZW1wIHN0dWZmXG52YXIgdG1wQUFCQjEgPSBuZXcgQUFCQigpO1xudmFyIHRtcEFycmF5MSA9IFtdO1xudmFyIHRtcFJheSA9IG5ldyBSYXkoKTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbnRhY3QgbWF0ZXJpYWwgYmV0d2VlbiBtYXRlcmlhbHMgbTEgYW5kIG0yXG4gKiBAbWV0aG9kIGdldENvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtNYXRlcmlhbH0gbTFcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG0yXG4gKiBAcmV0dXJuIHtDb250YWN0TWF0ZXJpYWx9IFRoZSBjb250YWN0IG1hdGVyaWFsIGlmIGl0IHdhcyBmb3VuZC5cbiAqL1xuV29ybGQucHJvdG90eXBlLmdldENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKG0xLG0yKXtcbiAgICByZXR1cm4gdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5nZXQobTEuaWQsbTIuaWQpOyAvL3RoaXMuY29udGFjdG1hdGVyaWFsc1t0aGlzLm1hdHMyY21hdFtpK2oqdGhpcy5tYXRlcmlhbHMubGVuZ3RoXV07XG59O1xuXG4vKipcbiAqIEdldCBudW1iZXIgb2Ygb2JqZWN0cyBpbiB0aGUgd29ybGQuXG4gKiBAbWV0aG9kIG51bU9iamVjdHNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBkZXByZWNhdGVkXG4gKi9cbldvcmxkLnByb3RvdHlwZS5udW1PYmplY3RzID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ib2RpZXMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBTdG9yZSBvbGQgY29sbGlzaW9uIHN0YXRlIGluZm9cbiAqIEBtZXRob2QgY29sbGlzaW9uTWF0cml4VGlja1xuICovXG5Xb3JsZC5wcm90b3R5cGUuY29sbGlzaW9uTWF0cml4VGljayA9IGZ1bmN0aW9uKCl7XG5cdHZhciB0ZW1wID0gdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cztcblx0dGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cyA9IHRoaXMuY29sbGlzaW9uTWF0cml4O1xuXHR0aGlzLmNvbGxpc2lvbk1hdHJpeCA9IHRlbXA7XG5cdHRoaXMuY29sbGlzaW9uTWF0cml4LnJlc2V0KCk7XG5cbiAgICB0aGlzLmJvZHlPdmVybGFwS2VlcGVyLnRpY2soKTtcbiAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci50aWNrKCk7XG59O1xuXG4vKipcbiAqIEFkZCBhIHJpZ2lkIGJvZHkgdG8gdGhlIHNpbXVsYXRpb24uXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKiBAdG9kbyBJZiB0aGUgc2ltdWxhdGlvbiBoYXMgbm90IHlldCBzdGFydGVkLCB3aHkgcmVjcmV0ZSBhbmQgY29weSBhcnJheXMgZm9yIGVhY2ggYm9keT8gQWNjdW11bGF0ZSBpbiBkeW5hbWljIGFycmF5cyBpbiB0aGlzIGNhc2UuXG4gKiBAdG9kbyBBZGRpbmcgYW4gYXJyYXkgb2YgYm9kaWVzIHNob3VsZCBiZSBwb3NzaWJsZS4gVGhpcyB3b3VsZCBzYXZlIHNvbWUgbG9vcHMgdG9vXG4gKiBAZGVwcmVjYXRlZCBVc2UgLmFkZEJvZHkgaW5zdGVhZFxuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkID0gV29ybGQucHJvdG90eXBlLmFkZEJvZHkgPSBmdW5jdGlvbihib2R5KXtcbiAgICBpZih0aGlzLmJvZGllcy5pbmRleE9mKGJvZHkpICE9PSAtMSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYm9keS5pbmRleCA9IHRoaXMuYm9kaWVzLmxlbmd0aDtcbiAgICB0aGlzLmJvZGllcy5wdXNoKGJvZHkpO1xuICAgIGJvZHkud29ybGQgPSB0aGlzO1xuICAgIGJvZHkuaW5pdFBvc2l0aW9uLmNvcHkoYm9keS5wb3NpdGlvbik7XG4gICAgYm9keS5pbml0VmVsb2NpdHkuY29weShib2R5LnZlbG9jaXR5KTtcbiAgICBib2R5LnRpbWVMYXN0U2xlZXB5ID0gdGhpcy50aW1lO1xuICAgIGlmKGJvZHkgaW5zdGFuY2VvZiBCb2R5KXtcbiAgICAgICAgYm9keS5pbml0QW5ndWxhclZlbG9jaXR5LmNvcHkoYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xuICAgICAgICBib2R5LmluaXRRdWF0ZXJuaW9uLmNvcHkoYm9keS5xdWF0ZXJuaW9uKTtcbiAgICB9XG5cdHRoaXMuY29sbGlzaW9uTWF0cml4LnNldE51bU9iamVjdHModGhpcy5ib2RpZXMubGVuZ3RoKTtcbiAgICB0aGlzLmFkZEJvZHlFdmVudC5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmlkVG9Cb2R5TWFwW2JvZHkuaWRdID0gYm9keTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5hZGRCb2R5RXZlbnQpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBjb25zdHJhaW50IHRvIHRoZSBzaW11bGF0aW9uLlxuICogQG1ldGhvZCBhZGRDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZENvbnN0cmFpbnQgPSBmdW5jdGlvbihjKXtcbiAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goYyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjb25zdHJhaW50XG4gKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRcbiAqIEBwYXJhbSB7Q29uc3RyYWludH0gY1xuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludCA9IGZ1bmN0aW9uKGMpe1xuICAgIHZhciBpZHggPSB0aGlzLmNvbnN0cmFpbnRzLmluZGV4T2YoYyk7XG4gICAgaWYoaWR4IT09LTEpe1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzLnNwbGljZShpZHgsMSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSYXljYXN0IHRlc3RcbiAqIEBtZXRob2QgcmF5VGVzdFxuICogQHBhcmFtIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0ge1ZlYzN9IHRvXG4gKiBAcGFyYW0ge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxuICogQGRlcHJlY2F0ZWQgVXNlIC5yYXljYXN0QWxsLCAucmF5Y2FzdENsb3Nlc3Qgb3IgLnJheWNhc3RBbnkgaW5zdGVhZC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnJheVRlc3QgPSBmdW5jdGlvbihmcm9tLCB0bywgcmVzdWx0KXtcbiAgICBpZihyZXN1bHQgaW5zdGFuY2VvZiBSYXljYXN0UmVzdWx0KXtcbiAgICAgICAgLy8gRG8gcmF5Y2FzdGNsb3Nlc3RcbiAgICAgICAgdGhpcy5yYXljYXN0Q2xvc2VzdChmcm9tLCB0bywge1xuICAgICAgICAgICAgc2tpcEJhY2tmYWNlczogdHJ1ZVxuICAgICAgICB9LCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvIHJheWNhc3RBbGxcbiAgICAgICAgdGhpcy5yYXljYXN0QWxsKGZyb20sIHRvLCB7XG4gICAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlXG4gICAgICAgIH0sIHJlc3VsdCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSYXkgY2FzdCBhZ2FpbnN0IGFsbCBib2RpZXMuIFRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGhpdCB3aXRoIGEgUmF5Y2FzdFJlc3VsdCBhcyBzaW5nbGUgYXJndW1lbnQuXG4gKiBAbWV0aG9kIHJheWNhc3RBbGxcbiAqIEBwYXJhbSAge1ZlYzN9IGZyb21cbiAqIEBwYXJhbSAge1ZlYzN9IHRvXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaz0tMV1cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9LTFdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yYXljYXN0QWxsID0gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMsIGNhbGxiYWNrKXtcbiAgICBvcHRpb25zLm1vZGUgPSBSYXkuQUxMO1xuICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XG4gICAgb3B0aW9ucy50byA9IHRvO1xuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSYXkgY2FzdCwgYW5kIHN0b3AgYXQgdGhlIGZpcnN0IHJlc3VsdC4gTm90ZSB0aGF0IHRoZSBvcmRlciBpcyByYW5kb20gLSBidXQgdGhlIG1ldGhvZCBpcyBmYXN0LlxuICogQG1ldGhvZCByYXljYXN0QW55XG4gKiBAcGFyYW0gIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9LTFdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwPS0xXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cbiAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdEFueSA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zLCByZXN1bHQpe1xuICAgIG9wdGlvbnMubW9kZSA9IFJheS5BTlk7XG4gICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICBvcHRpb25zLnRvID0gdG87XG4gICAgb3B0aW9ucy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmF5IGNhc3QsIGFuZCByZXR1cm4gaW5mb3JtYXRpb24gb2YgdGhlIGNsb3Nlc3QgaGl0LlxuICogQG1ldGhvZCByYXljYXN0Q2xvc2VzdFxuICogQHBhcmFtICB7VmVjM30gZnJvbVxuICogQHBhcmFtICB7VmVjM30gdG9cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrPS0xXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cD0tMV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnJheWNhc3RDbG9zZXN0ID0gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMsIHJlc3VsdCl7XG4gICAgb3B0aW9ucy5tb2RlID0gUmF5LkNMT1NFU1Q7XG4gICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICBvcHRpb25zLnRvID0gdG87XG4gICAgb3B0aW9ucy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgcmlnaWQgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLlxuICogQG1ldGhvZCByZW1vdmVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQGRlcHJlY2F0ZWQgVXNlIC5yZW1vdmVCb2R5IGluc3RlYWRcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGJvZHkpe1xuICAgIGJvZHkud29ybGQgPSBudWxsO1xuICAgIHZhciBuID0gdGhpcy5ib2RpZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgYm9kaWVzID0gdGhpcy5ib2RpZXMsXG4gICAgICAgIGlkeCA9IGJvZGllcy5pbmRleE9mKGJvZHkpO1xuICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICBib2RpZXMuc3BsaWNlKGlkeCwgMSk7IC8vIFRvZG86IHNob3VsZCB1c2UgYSBnYXJiYWdlIGZyZWUgbWV0aG9kXG5cbiAgICAgICAgLy8gUmVjb21wdXRlIGluZGV4XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09Ym9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGJvZGllc1tpXS5pbmRleCA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXROdW1PYmplY3RzKG4pO1xuICAgICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5ID0gYm9keTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaWRUb0JvZHlNYXBbYm9keS5pZF07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLnJlbW92ZUJvZHlFdmVudCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYSByaWdpZCBib2R5IGZyb20gdGhlIHNpbXVsYXRpb24uXG4gKiBAbWV0aG9kIHJlbW92ZUJvZHlcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQm9keSA9IFdvcmxkLnByb3RvdHlwZS5yZW1vdmU7XG5cbldvcmxkLnByb3RvdHlwZS5nZXRCb2R5QnlJZCA9IGZ1bmN0aW9uKGlkKXtcbiAgICByZXR1cm4gdGhpcy5pZFRvQm9keU1hcFtpZF07XG59O1xuXG4vLyBUT0RPIE1ha2UgYSBmYXN0ZXIgbWFwXG5Xb3JsZC5wcm90b3R5cGUuZ2V0U2hhcGVCeUlkID0gZnVuY3Rpb24oaWQpe1xuICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcbiAgICBmb3IodmFyIGk9MCwgYmwgPSBib2RpZXMubGVuZ3RoOyBpPGJsOyBpKyspe1xuICAgICAgICB2YXIgc2hhcGVzID0gYm9kaWVzW2ldLnNoYXBlcztcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIHNsID0gc2hhcGVzLmxlbmd0aDsgaiA8IHNsOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tqXTtcbiAgICAgICAgICAgIGlmKHNoYXBlLmlkID09PSBpZCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGRzIGEgbWF0ZXJpYWwgdG8gdGhlIFdvcmxkLlxuICogQG1ldGhvZCBhZGRNYXRlcmlhbFxuICogQHBhcmFtIHtNYXRlcmlhbH0gbVxuICogQHRvZG8gTmVjZXNzYXJ5P1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkTWF0ZXJpYWwgPSBmdW5jdGlvbihtKXtcbiAgICB0aGlzLm1hdGVyaWFscy5wdXNoKG0pO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgY29udGFjdCBtYXRlcmlhbCB0byB0aGUgV29ybGRcbiAqIEBtZXRob2QgYWRkQ29udGFjdE1hdGVyaWFsXG4gKiBAcGFyYW0ge0NvbnRhY3RNYXRlcmlhbH0gY21hdFxuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkQ29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24oY21hdCkge1xuXG4gICAgLy8gQWRkIGNvbnRhY3QgbWF0ZXJpYWxcbiAgICB0aGlzLmNvbnRhY3RtYXRlcmlhbHMucHVzaChjbWF0KTtcblxuICAgIC8vIEFkZCBjdXJyZW50IGNvbnRhY3QgbWF0ZXJpYWwgdG8gdGhlIG1hdGVyaWFsIHRhYmxlXG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5zZXQoY21hdC5tYXRlcmlhbHNbMF0uaWQsY21hdC5tYXRlcmlhbHNbMV0uaWQsY21hdCk7XG59O1xuXG4vLyBwZXJmb3JtYW5jZS5ub3coKVxuaWYodHlwZW9mIHBlcmZvcm1hbmNlID09PSAndW5kZWZpbmVkJyl7XG4gICAgcGVyZm9ybWFuY2UgPSB7fTtcbn1cbmlmKCFwZXJmb3JtYW5jZS5ub3cpe1xuICAgIHZhciBub3dPZmZzZXQgPSBEYXRlLm5vdygpO1xuICAgIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCl7XG4gICAgICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XG4gICAgfVxuICAgIHBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xuICAgIH07XG59XG5cbnZhciBzdGVwX3RtcDEgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFN0ZXAgdGhlIHBoeXNpY3Mgd29ybGQgZm9yd2FyZCBpbiB0aW1lLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gbW9kZXMuIFRoZSBzaW1wbGUgbW9kZSBpcyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uLiBJbiB0aGlzIGNhc2UgeW91IG9ubHkgdXNlIHRoZSBmaXJzdCBhcmd1bWVudC4gVGhlIHNlY29uZCBjYXNlIHVzZXMgaW50ZXJwb2xhdGlvbi4gSW4gdGhhdCB5b3UgYWxzbyBwcm92aWRlIHRoZSB0aW1lIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCB1c2VkLCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIGZpeGVkIHRpbWVzdGVwcyB0byB0YWtlLlxuICpcbiAqIEBtZXRob2Qgc3RlcFxuICogQHBhcmFtIHtOdW1iZXJ9IGR0ICAgICAgICAgICAgICAgICAgICAgICBUaGUgZml4ZWQgdGltZSBzdGVwIHNpemUgdG8gdXNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lU2luY2VMYXN0Q2FsbGVkXSAgICBUaGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCBjYWxsZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gW21heFN1YlN0ZXBzPTEwXSAgICAgICAgIE1heGltdW0gbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHRvIHRha2UgcGVyIGZ1bmN0aW9uIGNhbGwuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uXG4gKiAgICAgd29ybGQuc3RlcCgxLzYwKTtcbiAqXG4gKiBAc2VlIGh0dHA6Ly9idWxsZXRwaHlzaWNzLm9yZy9tZWRpYXdpa2ktMS41LjgvaW5kZXgucGhwL1N0ZXBwaW5nX1RoZV9Xb3JsZFxuICovXG5Xb3JsZC5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKGR0LCB0aW1lU2luY2VMYXN0Q2FsbGVkLCBtYXhTdWJTdGVwcyl7XG4gICAgbWF4U3ViU3RlcHMgPSBtYXhTdWJTdGVwcyB8fCAxMDtcbiAgICB0aW1lU2luY2VMYXN0Q2FsbGVkID0gdGltZVNpbmNlTGFzdENhbGxlZCB8fCAwO1xuXG4gICAgaWYodGltZVNpbmNlTGFzdENhbGxlZCA9PT0gMCl7IC8vIEZpeGVkLCBzaW1wbGUgc3RlcHBpbmdcblxuICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IHRpbWVcbiAgICAgICAgdGhpcy50aW1lICs9IGR0O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yICs9IHRpbWVTaW5jZUxhc3RDYWxsZWQ7XG4gICAgICAgIHZhciBzdWJzdGVwcyA9IDA7XG4gICAgICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IGR0ICYmIHN1YnN0ZXBzIDwgbWF4U3ViU3RlcHMpIHtcbiAgICAgICAgICAgIC8vIERvIGZpeGVkIHN0ZXBzIHRvIGNhdGNoIHVwXG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG4gICAgICAgICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IGR0O1xuICAgICAgICAgICAgc3Vic3RlcHMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gKHRoaXMuYWNjdW11bGF0b3IgJSBkdCkgLyBkdDtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IHRoaXMuYm9kaWVzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5ib2RpZXNbal07XG4gICAgICAgICAgICBiLnByZXZpb3VzUG9zaXRpb24ubGVycChiLnBvc2l0aW9uLCB0LCBiLmludGVycG9sYXRlZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGIucHJldmlvdXNRdWF0ZXJuaW9uLnNsZXJwKGIucXVhdGVybmlvbiwgdCwgYi5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uKTtcbiAgICAgICAgICAgIGIucHJldmlvdXNRdWF0ZXJuaW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZSArPSB0aW1lU2luY2VMYXN0Q2FsbGVkO1xuICAgIH1cbn07XG5cbnZhclxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgdGhlIHdvcmxkIGhhcyBzdGVwcGVkIGZvcndhcmQgaW4gdGltZS5cbiAgICAgKiBAZXZlbnQgcG9zdFN0ZXBcbiAgICAgKi9cbiAgICBXb3JsZF9zdGVwX3Bvc3RTdGVwRXZlbnQgPSB7dHlwZTpcInBvc3RTdGVwXCJ9LCAvLyBSZXVzYWJsZSBldmVudCBvYmplY3RzIHRvIHNhdmUgbWVtb3J5XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2hlZCBiZWZvcmUgdGhlIHdvcmxkIHN0ZXBzIGZvcndhcmQgaW4gdGltZS5cbiAgICAgKiBAZXZlbnQgcHJlU3RlcFxuICAgICAqL1xuICAgIFdvcmxkX3N0ZXBfcHJlU3RlcEV2ZW50ID0ge3R5cGU6XCJwcmVTdGVwXCJ9LFxuICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50ID0ge3R5cGU6Qm9keS5DT0xMSURFX0VWRU5UX05BTUUsIGJvZHk6bnVsbCwgY29udGFjdDpudWxsIH0sXG4gICAgV29ybGRfc3RlcF9vbGRDb250YWN0cyA9IFtdLCAvLyBQb29scyBmb3IgdW51c2VkIG9iamVjdHNcbiAgICBXb3JsZF9zdGVwX2ZyaWN0aW9uRXF1YXRpb25Qb29sID0gW10sXG4gICAgV29ybGRfc3RlcF9wMSA9IFtdLCAvLyBSZXVzYWJsZSBhcnJheXMgZm9yIGNvbGxpc2lvbiBwYWlyc1xuICAgIFdvcmxkX3N0ZXBfcDIgPSBbXSxcbiAgICBXb3JsZF9zdGVwX2d2ZWMgPSBuZXcgVmVjMygpLCAvLyBUZW1wb3JhcnkgdmVjdG9ycyBhbmQgcXVhdHNcbiAgICBXb3JsZF9zdGVwX3ZpID0gbmV3IFZlYzMoKSxcbiAgICBXb3JsZF9zdGVwX3ZqID0gbmV3IFZlYzMoKSxcbiAgICBXb3JsZF9zdGVwX3dpID0gbmV3IFZlYzMoKSxcbiAgICBXb3JsZF9zdGVwX3dqID0gbmV3IFZlYzMoKSxcbiAgICBXb3JsZF9zdGVwX3QxID0gbmV3IFZlYzMoKSxcbiAgICBXb3JsZF9zdGVwX3QyID0gbmV3IFZlYzMoKSxcbiAgICBXb3JsZF9zdGVwX3JpeG4gPSBuZXcgVmVjMygpLFxuICAgIFdvcmxkX3N0ZXBfcmp4biA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF9zdGVwX3EgPSBuZXcgUXVhdGVybmlvbigpLFxuICAgIFdvcmxkX3N0ZXBfc3RlcF93ID0gbmV3IFF1YXRlcm5pb24oKSxcbiAgICBXb3JsZF9zdGVwX3N0ZXBfd3EgPSBuZXcgUXVhdGVybmlvbigpLFxuICAgIGludklfdGF1X2R0ID0gbmV3IFZlYzMoKTtcbldvcmxkLnByb3RvdHlwZS5pbnRlcm5hbFN0ZXAgPSBmdW5jdGlvbihkdCl7XG4gICAgdGhpcy5kdCA9IGR0O1xuXG4gICAgdmFyIHdvcmxkID0gdGhpcyxcbiAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgIGNvbnRhY3RzID0gdGhpcy5jb250YWN0cyxcbiAgICAgICAgcDEgPSBXb3JsZF9zdGVwX3AxLFxuICAgICAgICBwMiA9IFdvcmxkX3N0ZXBfcDIsXG4gICAgICAgIE4gPSB0aGlzLm51bU9iamVjdHMoKSxcbiAgICAgICAgYm9kaWVzID0gdGhpcy5ib2RpZXMsXG4gICAgICAgIHNvbHZlciA9IHRoaXMuc29sdmVyLFxuICAgICAgICBncmF2aXR5ID0gdGhpcy5ncmF2aXR5LFxuICAgICAgICBkb1Byb2ZpbGluZyA9IHRoaXMuZG9Qcm9maWxpbmcsXG4gICAgICAgIHByb2ZpbGUgPSB0aGlzLnByb2ZpbGUsXG4gICAgICAgIERZTkFNSUMgPSBCb2R5LkRZTkFNSUMsXG4gICAgICAgIHByb2ZpbGluZ1N0YXJ0LFxuICAgICAgICBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHMsXG4gICAgICAgIGZyaWN0aW9uRXF1YXRpb25Qb29sID0gV29ybGRfc3RlcF9mcmljdGlvbkVxdWF0aW9uUG9vbCxcbiAgICAgICAgZ25vcm0gPSBncmF2aXR5Lm5vcm0oKSxcbiAgICAgICAgZ3ggPSBncmF2aXR5LngsXG4gICAgICAgIGd5ID0gZ3Jhdml0eS55LFxuICAgICAgICBneiA9IGdyYXZpdHkueixcbiAgICAgICAgaT0wO1xuXG4gICAgaWYoZG9Qcm9maWxpbmcpe1xuICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cblxuICAgIC8vIEFkZCBncmF2aXR5IHRvIGFsbCBvYmplY3RzXG4gICAgZm9yKGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcbiAgICAgICAgaWYoYmkudHlwZSA9PT0gRFlOQU1JQyl7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXG4gICAgICAgICAgICB2YXIgZiA9IGJpLmZvcmNlLCBtID0gYmkubWFzcztcbiAgICAgICAgICAgIGYueCArPSBtKmd4O1xuICAgICAgICAgICAgZi55ICs9IG0qZ3k7XG4gICAgICAgICAgICBmLnogKz0gbSpnejtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzdWJzeXN0ZW1zXG4gICAgZm9yKHZhciBpPTAsIE5zdWJzeXN0ZW1zPXRoaXMuc3Vic3lzdGVtcy5sZW5ndGg7IGkhPT1Oc3Vic3lzdGVtczsgaSsrKXtcbiAgICAgICAgdGhpcy5zdWJzeXN0ZW1zW2ldLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIENvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICBpZihkb1Byb2ZpbGluZyl7IHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7IH1cbiAgICBwMS5sZW5ndGggPSAwOyAvLyBDbGVhbiB1cCBwYWlyIGFycmF5cyBmcm9tIGxhc3Qgc3RlcFxuICAgIHAyLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5icm9hZHBoYXNlLmNvbGxpc2lvblBhaXJzKHRoaXMscDEscDIpO1xuICAgIGlmKGRvUHJvZmlsaW5nKXsgcHJvZmlsZS5icm9hZHBoYXNlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDsgfVxuXG4gICAgLy8gUmVtb3ZlIGNvbnN0cmFpbmVkIHBhaXJzIHdpdGggY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZVxuICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5jb25zdHJhaW50czsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcbiAgICAgICAgaWYoIWMuY29sbGlkZUNvbm5lY3RlZCl7XG4gICAgICAgICAgICBmb3IodmFyIGogPSBwMS5sZW5ndGgtMTsgaj49MDsgai09MSl7XG4gICAgICAgICAgICAgICAgaWYoIChjLmJvZHlBID09PSBwMVtqXSAmJiBjLmJvZHlCID09PSBwMltqXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGMuYm9keUIgPT09IHAxW2pdICYmIGMuYm9keUEgPT09IHAyW2pdKSl7XG4gICAgICAgICAgICAgICAgICAgIHAxLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcDIuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29sbGlzaW9uTWF0cml4VGljaygpO1xuXG4gICAgLy8gR2VuZXJhdGUgY29udGFjdHNcbiAgICBpZihkb1Byb2ZpbGluZyl7IHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7IH1cbiAgICB2YXIgb2xkY29udGFjdHMgPSBXb3JsZF9zdGVwX29sZENvbnRhY3RzO1xuICAgIHZhciBOb2xkQ29udGFjdHMgPSBjb250YWN0cy5sZW5ndGg7XG5cbiAgICBmb3IoaT0wOyBpIT09Tm9sZENvbnRhY3RzOyBpKyspe1xuICAgICAgICBvbGRjb250YWN0cy5wdXNoKGNvbnRhY3RzW2ldKTtcbiAgICB9XG4gICAgY29udGFjdHMubGVuZ3RoID0gMDtcblxuICAgIC8vIFRyYW5zZmVyIEZyaWN0aW9uRXF1YXRpb24gZnJvbSBjdXJyZW50IGxpc3QgdG8gdGhlIHBvb2wgZm9yIHJldXNlXG4gICAgdmFyIE5vbGRGcmljdGlvbkVxdWF0aW9ucyA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoO1xuICAgIGZvcihpPTA7IGkhPT1Ob2xkRnJpY3Rpb25FcXVhdGlvbnM7IGkrKyl7XG4gICAgICAgIGZyaWN0aW9uRXF1YXRpb25Qb29sLnB1c2godGhpcy5mcmljdGlvbkVxdWF0aW9uc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoID0gMDtcblxuICAgIHRoaXMubmFycm93cGhhc2UuZ2V0Q29udGFjdHMoXG4gICAgICAgIHAxLFxuICAgICAgICBwMixcbiAgICAgICAgdGhpcyxcbiAgICAgICAgY29udGFjdHMsXG4gICAgICAgIG9sZGNvbnRhY3RzLCAvLyBUbyBiZSByZXVzZWRcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucyxcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblBvb2xcbiAgICApO1xuXG4gICAgaWYoZG9Qcm9maWxpbmcpe1xuICAgICAgICBwcm9maWxlLm5hcnJvd3BoYXNlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDtcbiAgICB9XG5cbiAgICAvLyBMb29wIG92ZXIgYWxsIGNvbGxpc2lvbnNcbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBmcmljdGlvbiBlcXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9uKHRoaXMuZnJpY3Rpb25FcXVhdGlvbnNbaV0pO1xuICAgIH1cblxuICAgIHZhciBuY29udGFjdHMgPSBjb250YWN0cy5sZW5ndGg7XG4gICAgZm9yKHZhciBrPTA7IGshPT1uY29udGFjdHM7IGsrKyl7XG5cbiAgICAgICAgLy8gQ3VycmVudCBjb250YWN0XG4gICAgICAgIHZhciBjID0gY29udGFjdHNba107XG5cbiAgICAgICAgLy8gR2V0IGN1cnJlbnQgY29sbGlzaW9uIGluZGVjZXNcbiAgICAgICAgdmFyIGJpID0gYy5iaSxcbiAgICAgICAgICAgIGJqID0gYy5iaixcbiAgICAgICAgICAgIHNpID0gYy5zaSxcbiAgICAgICAgICAgIHNqID0gYy5zajtcblxuICAgICAgICAvLyBHZXQgY29sbGlzaW9uIHByb3BlcnRpZXNcbiAgICAgICAgdmFyIGNtO1xuICAgICAgICBpZihiaS5tYXRlcmlhbCAmJiBiai5tYXRlcmlhbCl7XG4gICAgICAgICAgICBjbSA9IHRoaXMuZ2V0Q29udGFjdE1hdGVyaWFsKGJpLm1hdGVyaWFsLGJqLm1hdGVyaWFsKSB8fCB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbSA9IHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGMuZW5hYmxlZCA9IGJpLmNvbGxpc2lvblJlc3BvbnNlICYmIGJqLmNvbGxpc2lvblJlc3BvbnNlICYmIHNpLmNvbGxpc2lvblJlc3BvbnNlICYmIHNqLmNvbGxpc2lvblJlc3BvbnNlO1xuXG4gICAgICAgIHZhciBtdSA9IGNtLmZyaWN0aW9uO1xuICAgICAgICAvLyBjLnJlc3RpdHV0aW9uID0gY20ucmVzdGl0dXRpb247XG5cbiAgICAgICAgLy8gSWYgZnJpY3Rpb24gb3IgcmVzdGl0dXRpb24gd2VyZSBzcGVjaWZpZWQgaW4gdGhlIG1hdGVyaWFsLCB1c2UgdGhlbVxuICAgICAgICBpZihiaS5tYXRlcmlhbCAmJiBiai5tYXRlcmlhbCl7XG4gICAgICAgICAgICBpZihiaS5tYXRlcmlhbC5mcmljdGlvbiA+PSAwICYmIGJqLm1hdGVyaWFsLmZyaWN0aW9uID49IDApe1xuICAgICAgICAgICAgICAgIG11ID0gYmkubWF0ZXJpYWwuZnJpY3Rpb24gKiBiai5tYXRlcmlhbC5mcmljdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoYmkubWF0ZXJpYWwucmVzdGl0dXRpb24gPj0gMCAmJiBiai5tYXRlcmlhbC5yZXN0aXR1dGlvbiA+PSAwKXtcbiAgICAgICAgICAgICAgICBjLnJlc3RpdHV0aW9uID0gYmkubWF0ZXJpYWwucmVzdGl0dXRpb24gKiBiai5tYXRlcmlhbC5yZXN0aXR1dGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cdFx0Ly8gYy5zZXRTcG9va1BhcmFtcyhcbiAgLy8gICAgICAgICAgIGNtLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyxcbiAgLy8gICAgICAgICAgIGNtLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24sXG4gIC8vICAgICAgICAgICBkdFxuICAvLyAgICAgICApO1xuXG5cdFx0c29sdmVyLmFkZEVxdWF0aW9uKGMpO1xuXG5cdFx0Ly8gLy8gQWRkIGZyaWN0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb25cblx0XHQvLyBpZihtdSA+IDApe1xuXG5cdFx0Ly8gXHQvLyBDcmVhdGUgMiB0YW5nZW50IGVxdWF0aW9uc1xuXHRcdC8vIFx0dmFyIG11ZyA9IG11ICogZ25vcm07XG5cdFx0Ly8gXHR2YXIgcmVkdWNlZE1hc3MgPSAoYmkuaW52TWFzcyArIGJqLmludk1hc3MpO1xuXHRcdC8vIFx0aWYocmVkdWNlZE1hc3MgPiAwKXtcblx0XHQvLyBcdFx0cmVkdWNlZE1hc3MgPSAxL3JlZHVjZWRNYXNzO1xuXHRcdC8vIFx0fVxuXHRcdC8vIFx0dmFyIHBvb2wgPSBmcmljdGlvbkVxdWF0aW9uUG9vbDtcblx0XHQvLyBcdHZhciBjMSA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJpLGJqLG11ZypyZWR1Y2VkTWFzcyk7XG5cdFx0Ly8gXHR2YXIgYzIgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihiaSxiaixtdWcqcmVkdWNlZE1hc3MpO1xuXHRcdC8vIFx0dGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKGMxLCBjMik7XG5cblx0XHQvLyBcdGMxLmJpID0gYzIuYmkgPSBiaTtcblx0XHQvLyBcdGMxLmJqID0gYzIuYmogPSBiajtcblx0XHQvLyBcdGMxLm1pbkZvcmNlID0gYzIubWluRm9yY2UgPSAtbXVnKnJlZHVjZWRNYXNzO1xuXHRcdC8vIFx0YzEubWF4Rm9yY2UgPSBjMi5tYXhGb3JjZSA9IG11ZypyZWR1Y2VkTWFzcztcblxuXHRcdC8vIFx0Ly8gQ29weSBvdmVyIHRoZSByZWxhdGl2ZSB2ZWN0b3JzXG5cdFx0Ly8gXHRjMS5yaS5jb3B5KGMucmkpO1xuXHRcdC8vIFx0YzEucmouY29weShjLnJqKTtcblx0XHQvLyBcdGMyLnJpLmNvcHkoYy5yaSk7XG5cdFx0Ly8gXHRjMi5yai5jb3B5KGMucmopO1xuXG5cdFx0Ly8gXHQvLyBDb25zdHJ1Y3QgdGFuZ2VudHNcblx0XHQvLyBcdGMubmkudGFuZ2VudHMoYzEudCwgYzIudCk7XG5cbiAgLy8gICAgICAgICAgIC8vIFNldCBzcG9vayBwYXJhbXNcbiAgLy8gICAgICAgICAgIGMxLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCBkdCk7XG4gIC8vICAgICAgICAgICBjMi5zZXRTcG9va1BhcmFtcyhjbS5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzLCBjbS5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiwgZHQpO1xuXG4gIC8vICAgICAgICAgICBjMS5lbmFibGVkID0gYzIuZW5hYmxlZCA9IGMuZW5hYmxlZDtcblxuXHRcdC8vIFx0Ly8gQWRkIGVxdWF0aW9ucyB0byBzb2x2ZXJcblx0XHQvLyBcdHNvbHZlci5hZGRFcXVhdGlvbihjMSk7XG5cdFx0Ly8gXHRzb2x2ZXIuYWRkRXF1YXRpb24oYzIpO1xuXHRcdC8vIH1cblxuICAgICAgICBpZiggYmkuYWxsb3dTbGVlcCAmJlxuICAgICAgICAgICAgYmkudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmXG4gICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5TTEVFUElORyAmJlxuICAgICAgICAgICAgYmouc2xlZXBTdGF0ZSAgPT09IEJvZHkuQVdBS0UgJiZcbiAgICAgICAgICAgIGJqLnR5cGUgIT09IEJvZHkuU1RBVElDXG4gICAgICAgICl7XG4gICAgICAgICAgICB2YXIgc3BlZWRTcXVhcmVkQiA9IGJqLnZlbG9jaXR5Lm5vcm0yKCkgKyBiai5hbmd1bGFyVmVsb2NpdHkubm9ybTIoKTtcbiAgICAgICAgICAgIHZhciBzcGVlZExpbWl0U3F1YXJlZEIgPSBNYXRoLnBvdyhiai5zbGVlcFNwZWVkTGltaXQsMik7XG4gICAgICAgICAgICBpZihzcGVlZFNxdWFyZWRCID49IHNwZWVkTGltaXRTcXVhcmVkQioyKXtcbiAgICAgICAgICAgICAgICBiaS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggYmouYWxsb3dTbGVlcCAmJlxuICAgICAgICAgICAgYmoudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmXG4gICAgICAgICAgICBiai5zbGVlcFN0YXRlICA9PT0gQm9keS5TTEVFUElORyAmJlxuICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSAgPT09IEJvZHkuQVdBS0UgJiZcbiAgICAgICAgICAgIGJpLnR5cGUgIT09IEJvZHkuU1RBVElDXG4gICAgICAgICl7XG4gICAgICAgICAgICB2YXIgc3BlZWRTcXVhcmVkQSA9IGJpLnZlbG9jaXR5Lm5vcm0yKCkgKyBiaS5hbmd1bGFyVmVsb2NpdHkubm9ybTIoKTtcbiAgICAgICAgICAgIHZhciBzcGVlZExpbWl0U3F1YXJlZEEgPSBNYXRoLnBvdyhiaS5zbGVlcFNwZWVkTGltaXQsMik7XG4gICAgICAgICAgICBpZihzcGVlZFNxdWFyZWRBID49IHNwZWVkTGltaXRTcXVhcmVkQSoyKXtcbiAgICAgICAgICAgICAgICBiai5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgd2Uga25vdyB0aGF0IGkgYW5kIGogYXJlIGluIGNvbnRhY3QuIFNldCBjb2xsaXNpb24gbWF0cml4IHN0YXRlXG5cdFx0dGhpcy5jb2xsaXNpb25NYXRyaXguc2V0KGJpLCBiaiwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzLmdldChiaSwgYmopKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCBjb250YWN0IVxuICAgICAgICAgICAgLy8gV2UgcmV1c2UgdGhlIGNvbGxpZGVFdmVudCBvYmplY3QsIG90aGVyd2lzZSB3ZSB3aWxsIGVuZCB1cCBjcmVhdGluZyBuZXcgb2JqZWN0cyBmb3IgZWFjaCBuZXcgY29udGFjdCwgZXZlbiBpZiB0aGVyZSdzIG5vIGV2ZW50IGxpc3RlbmVyIGF0dGFjaGVkLlxuICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuYm9keSA9IGJqO1xuICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuY29udGFjdCA9IGM7XG4gICAgICAgICAgICBiaS5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50KTtcblxuICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuYm9keSA9IGJpO1xuICAgICAgICAgICAgYmouZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX2NvbGxpZGVFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHlPdmVybGFwS2VlcGVyLnNldChiaS5pZCwgYmouaWQpO1xuICAgICAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5zZXQoc2kuaWQsIHNqLmlkKTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXRDb250YWN0RXZlbnRzKCk7XG5cbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHByb2ZpbGUubWFrZUNvbnRhY3RDb25zdHJhaW50cyA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XG4gICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuXG4gICAgLy8gV2FrZSB1cCBib2RpZXNcbiAgICBmb3IoaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiaS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSl7XG4gICAgICAgICAgICBiaS53YWtlVXAoKTtcbiAgICAgICAgICAgIGJpLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgdXNlci1hZGRlZCBjb25zdHJhaW50c1xuICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5jb25zdHJhaW50czsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcbiAgICAgICAgYy51cGRhdGUoKTtcbiAgICAgICAgZm9yKHZhciBqPTAsIE5lcT1jLmVxdWF0aW9ucy5sZW5ndGg7IGohPT1OZXE7IGorKyl7XG4gICAgICAgICAgICB2YXIgZXEgPSBjLmVxdWF0aW9uc1tqXTtcbiAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbihlcSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb2x2ZSB0aGUgY29uc3RyYWluZWQgc3lzdGVtXG4gICAgc29sdmVyLnNvbHZlKGR0LHRoaXMpO1xuXG4gICAgaWYoZG9Qcm9maWxpbmcpe1xuICAgICAgICBwcm9maWxlLnNvbHZlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGNvbnRhY3RzIGZyb20gc29sdmVyXG4gICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuXG4gICAgLy8gQXBwbHkgZGFtcGluZywgc2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9idWxsZXQvaXNzdWVzL2RldGFpbD9pZD03NCBmb3IgZGV0YWlsc1xuICAgIHZhciBwb3cgPSBNYXRoLnBvdztcbiAgICBmb3IoaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiaS50eXBlICYgRFlOQU1JQyl7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXG4gICAgICAgICAgICB2YXIgbGQgPSBwb3coMS4wIC0gYmkubGluZWFyRGFtcGluZyxkdCk7XG4gICAgICAgICAgICB2YXIgdiA9IGJpLnZlbG9jaXR5O1xuICAgICAgICAgICAgdi5tdWx0KGxkLHYpO1xuICAgICAgICAgICAgdmFyIGF2ID0gYmkuYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgaWYoYXYpe1xuICAgICAgICAgICAgICAgIHZhciBhZCA9IHBvdygxLjAgLSBiaS5hbmd1bGFyRGFtcGluZyxkdCk7XG4gICAgICAgICAgICAgICAgYXYubXVsdChhZCxhdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9wcmVTdGVwRXZlbnQpO1xuXG4gICAgLy8gSW52b2tlIHByZS1zdGVwIGNhbGxiYWNrc1xuICAgIGZvcihpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG4gICAgICAgIGlmKGJpLnByZVN0ZXApe1xuICAgICAgICAgICAgYmkucHJlU3RlcC5jYWxsKGJpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIExlYXAgZnJvZ1xuICAgIC8vIHZuZXcgPSB2ICsgaCpmL21cbiAgICAvLyB4bmV3ID0geCArIGgqdm5ld1xuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gICAgdmFyIHN0ZXBudW1iZXIgPSB0aGlzLnN0ZXBudW1iZXI7XG4gICAgdmFyIHF1YXROb3JtYWxpemUgPSBzdGVwbnVtYmVyICUgKHRoaXMucXVhdE5vcm1hbGl6ZVNraXAgKyAxKSA9PT0gMDtcbiAgICB2YXIgcXVhdE5vcm1hbGl6ZUZhc3QgPSB0aGlzLnF1YXROb3JtYWxpemVGYXN0O1xuXG4gICAgZm9yKGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIGJvZGllc1tpXS5pbnRlZ3JhdGUoZHQsIHF1YXROb3JtYWxpemUsIHF1YXROb3JtYWxpemVGYXN0KTtcbiAgICB9XG4gICAgdGhpcy5jbGVhckZvcmNlcygpO1xuXG4gICAgdGhpcy5icm9hZHBoYXNlLmRpcnR5ID0gdHJ1ZTtcblxuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgcHJvZmlsZS5pbnRlZ3JhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0O1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB3b3JsZCB0aW1lXG4gICAgdGhpcy50aW1lICs9IGR0O1xuICAgIHRoaXMuc3RlcG51bWJlciArPSAxO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfcG9zdFN0ZXBFdmVudCk7XG5cbiAgICAvLyBJbnZva2UgcG9zdC1zdGVwIGNhbGxiYWNrc1xuICAgIGZvcihpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG4gICAgICAgIHZhciBwb3N0U3RlcCA9IGJpLnBvc3RTdGVwO1xuICAgICAgICBpZihwb3N0U3RlcCl7XG4gICAgICAgICAgICBwb3N0U3RlcC5jYWxsKGJpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNsZWVwaW5nIHVwZGF0ZVxuICAgIGlmKHRoaXMuYWxsb3dTbGVlcCl7XG4gICAgICAgIGZvcihpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuV29ybGQucHJvdG90eXBlLmVtaXRDb250YWN0RXZlbnRzID0gKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xuICAgIHZhciByZW1vdmFscyA9IFtdO1xuICAgIHZhciBiZWdpbkNvbnRhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTogJ2JlZ2luQ29udGFjdCcsXG4gICAgICAgIGJvZHlBOiBudWxsLFxuICAgICAgICBib2R5QjogbnVsbFxuICAgIH07XG4gICAgdmFyIGVuZENvbnRhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTogJ2VuZENvbnRhY3QnLFxuICAgICAgICBib2R5QTogbnVsbCxcbiAgICAgICAgYm9keUI6IG51bGxcbiAgICB9O1xuICAgIHZhciBiZWdpblNoYXBlQ29udGFjdEV2ZW50ID0ge1xuICAgICAgICB0eXBlOiAnYmVnaW5TaGFwZUNvbnRhY3QnLFxuICAgICAgICBib2R5QTogbnVsbCxcbiAgICAgICAgYm9keUI6IG51bGwsXG4gICAgICAgIHNoYXBlQTogbnVsbCxcbiAgICAgICAgc2hhcGVCOiBudWxsXG4gICAgfTtcbiAgICB2YXIgZW5kU2hhcGVDb250YWN0RXZlbnQgPSB7XG4gICAgICAgIHR5cGU6ICdlbmRTaGFwZUNvbnRhY3QnLFxuICAgICAgICBib2R5QTogbnVsbCxcbiAgICAgICAgYm9keUI6IG51bGwsXG4gICAgICAgIHNoYXBlQTogbnVsbCxcbiAgICAgICAgc2hhcGVCOiBudWxsXG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGhhc0JlZ2luQ29udGFjdCA9IHRoaXMuaGFzQW55RXZlbnRMaXN0ZW5lcignYmVnaW5Db250YWN0Jyk7XG4gICAgICAgIHZhciBoYXNFbmRDb250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdlbmRDb250YWN0Jyk7XG5cbiAgICAgICAgaWYoaGFzQmVnaW5Db250YWN0IHx8IGhhc0VuZENvbnRhY3Qpe1xuICAgICAgICAgICAgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5nZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaGFzQmVnaW5Db250YWN0KXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYWRkaXRpb25zLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGJlZ2luQ29udGFjdEV2ZW50LmJvZHlBID0gdGhpcy5nZXRCb2R5QnlJZChhZGRpdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIGJlZ2luQ29udGFjdEV2ZW50LmJvZHlCID0gdGhpcy5nZXRCb2R5QnlJZChhZGRpdGlvbnNbaSsxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGJlZ2luQ29udGFjdEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlZ2luQ29udGFjdEV2ZW50LmJvZHlBID0gYmVnaW5Db250YWN0RXZlbnQuYm9keUIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaGFzRW5kQ29udGFjdCl7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlbW92YWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGVuZENvbnRhY3RFdmVudC5ib2R5QSA9IHRoaXMuZ2V0Qm9keUJ5SWQocmVtb3ZhbHNbaV0pO1xuICAgICAgICAgICAgICAgIGVuZENvbnRhY3RFdmVudC5ib2R5QiA9IHRoaXMuZ2V0Qm9keUJ5SWQocmVtb3ZhbHNbaSsxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGVuZENvbnRhY3RFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRDb250YWN0RXZlbnQuYm9keUEgPSBlbmRDb250YWN0RXZlbnQuYm9keUIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkaXRpb25zLmxlbmd0aCA9IHJlbW92YWxzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgdmFyIGhhc0JlZ2luU2hhcGVDb250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdiZWdpblNoYXBlQ29udGFjdCcpO1xuICAgICAgICB2YXIgaGFzRW5kU2hhcGVDb250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdlbmRTaGFwZUNvbnRhY3QnKTtcblxuICAgICAgICBpZihoYXNCZWdpblNoYXBlQ29udGFjdCB8fCBoYXNFbmRTaGFwZUNvbnRhY3Qpe1xuICAgICAgICAgICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIuZ2V0RGlmZihhZGRpdGlvbnMsIHJlbW92YWxzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGhhc0JlZ2luU2hhcGVDb250YWN0KXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYWRkaXRpb25zLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZUEgPSB0aGlzLmdldFNoYXBlQnlJZChhZGRpdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZUIgPSB0aGlzLmdldFNoYXBlQnlJZChhZGRpdGlvbnNbaSsxXSk7XG4gICAgICAgICAgICAgICAgYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5zaGFwZUEgPSBzaGFwZUE7XG4gICAgICAgICAgICAgICAgYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBzaGFwZUI7XG4gICAgICAgICAgICAgICAgYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5ib2R5QSA9IHNoYXBlQS5ib2R5O1xuICAgICAgICAgICAgICAgIGJlZ2luU2hhcGVDb250YWN0RXZlbnQuYm9keUIgPSBzaGFwZUIuYm9keTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoYmVnaW5TaGFwZUNvbnRhY3RFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiZWdpblNoYXBlQ29udGFjdEV2ZW50LmJvZHlBID0gYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5ib2R5QiA9IGJlZ2luU2hhcGVDb250YWN0RXZlbnQuc2hhcGVBID0gYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaGFzRW5kU2hhcGVDb250YWN0KXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVtb3ZhbHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlQSA9IHRoaXMuZ2V0U2hhcGVCeUlkKHJlbW92YWxzW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGVCID0gdGhpcy5nZXRTaGFwZUJ5SWQocmVtb3ZhbHNbaSsxXSk7XG4gICAgICAgICAgICAgICAgZW5kU2hhcGVDb250YWN0RXZlbnQuc2hhcGVBID0gc2hhcGVBO1xuICAgICAgICAgICAgICAgIGVuZFNoYXBlQ29udGFjdEV2ZW50LnNoYXBlQiA9IHNoYXBlQjtcbiAgICAgICAgICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5ib2R5QSA9IHNoYXBlQS5ib2R5O1xuICAgICAgICAgICAgICAgIGVuZFNoYXBlQ29udGFjdEV2ZW50LmJvZHlCID0gc2hhcGVCLmJvZHk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGVuZFNoYXBlQ29udGFjdEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZFNoYXBlQ29udGFjdEV2ZW50LmJvZHlBID0gZW5kU2hhcGVDb250YWN0RXZlbnQuYm9keUIgPSBlbmRTaGFwZUNvbnRhY3RFdmVudC5zaGFwZUEgPSBlbmRTaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBTZXRzIGFsbCBib2R5IGZvcmNlcyBpbiB0aGUgd29ybGQgdG8gemVyby5cbiAqIEBtZXRob2QgY2xlYXJGb3JjZXNcbiAqL1xuV29ybGQucHJvdG90eXBlLmNsZWFyRm9yY2VzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gICAgdmFyIE4gPSBib2RpZXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSBOOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgIGZvcmNlID0gYi5mb3JjZSxcbiAgICAgICAgICAgIHRhdSA9IGIudG9ycXVlO1xuXG4gICAgICAgIGIuZm9yY2Uuc2V0KDAsMCwwKTtcbiAgICAgICAgYi50b3JxdWUuc2V0KDAsMCwwKTtcbiAgICB9XG59O1xuIl19
